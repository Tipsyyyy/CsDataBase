{"path":"课程/数字逻辑与计算机组成/课件/第4章 时序逻辑电路（2）.pdf","text":"同步时序逻辑设计步骤 状态图/状态表设计 状态化简和状态编码 电路设计和分析 1 第三讲 同步时序逻辑设计 3.1 同步时序逻辑设计步骤 2 需求分析 状态图/表 状态化简 状态编码 电路设计 电路分析 将文字描述逻辑抽象为数字设计模型 根据数字设计模型构建原始状态图/表 合并等价状态对，减少状态数量 每个状态赋予一个二进制编码 根据编码得到激励函数 和输出函数 能否自启动， 是否会挂起 3.2 需求分析 例：检测一连串0/1输入序列中是否出现“101” 3 1位输入端X； 1位输出端Z。 CP脉冲到来时， 根据当前X的值， 确定输入序列中 是否出现“101” 若是，则输出Z 为1；否则Z为0。 3.2 状态图/状态表设计 2. 构建状态图/表：分析系统内部的状态转换关系 I. 设定任一状态为电路初始状态； II. 从初始状态开始，分析每一个状态在不同输入作用下的状态转移 情况和输出取值； III. 如果某状态下出现的输出响应（次态、输出）不能用已有状态表 示，则产生新的状态； IV. 重复第II、III两步，直到不产生新状态为止。 4 S0X=0 /Z=0 S1 X=1/Z=0 S1：接收到“101”序列中第一个1 X=1 /Z=0 X=0/Z=0 S2 S2：接收到该序列中的10 X=0/Z=0 X=1/Z=1 S3：接收到一个“101”序列 S3 S0：初始状态，等待接收输入 X=0/Z=0 X=1/Z=0 3.2 状态图/状态表设计 2. 构建状态图/表 • 根据状态图构建状态表 X：输入数据；Z：检测结果 S：当前状态；S* ：次态 5 S1 S2 S3 S0 现态S X=0 X=1 S*/Z S0/0 S1/0 S2/0 S1/0 S0/0 S3/1 S2/0 S1/0 状态表 S0X=0 /Z=0 S1 X=1/Z=0 S1：接收到“101”序列中第一个1 X=1 /Z=0 X=0/Z=0 S2 S2：接收到该序列中的10 X=0/Z=0 X=1/Z=1 S3：接收到一个“101”序列 S3 S0：初始状态，等待接收输入 X=0/Z=0 X=1/Z=0 3.2 状态图/状态表设计 2. 构建状态图/表 • 构建状态图/表时，状态转移需满足下列两个条件。 互斥性：从每个状态出发的所有状态转换路径上的转换条件都 是互斥的，如本例中，转移条件分别是X=0和X=1，互斥。 完备性：从每个状态出发的所有状态转换路径上的转移表达式 的逻辑或等于1（逻辑真）。如X=0和X=1，0+1=1。 • 在状态图中，也可以使用逻辑表达式来表示转移条件。本例中， 可以使用X和�𝐗𝐗分别表示输入X=1和X=0。 6 S0X=0 /Z=0 S1 X=1/Z=0 X=1 /Z=0 X=0/Z=0 S2 X=0/Z=0 X=1/Z=1 S3 X=0/Z=0 X=1/Z=0 3.3a 状态化简 • 合并等价状态，以得到更加精简的状态表 • 两个状态等价指在所有输入组合下，它们的输出相同且次态相同 或次态等价 • 等价关系具有传递性 - 例如，若状态A和B等价，同时B和C等价，则A和C也等价。 状态A、B和C属于一个等价类，可以合并为一个状态。 7 S1和S3构成等价类，可合并 化简后，有3个状态 S1 S2 S3 S0 现态S X=0 X=1 S*/Z S0/0 S1/0 S2/0 S1/0 S0/0 S3/1 S2/0 S1/0 状态表 现态S X=0 X=1 S*/Z S0 S1 S2 S0/0 S2/0 S0/0 S1/0 S1/0 S1/1 3.3b 状态编码 • 对状态表中每个状态赋予唯一的二进制编码，也称状态赋值 • 寻找最优编码方案是一个非常复杂的问题 • 通常在具体设计时采用相邻法寻求较优编码方案： 准则1：若两个状态的次态相同，则其对应编码应尽量相邻 准则2：同一个现态的各个次态其编码应尽量相邻 准则3：若两个现态的输出相同，则它们的编码应尽量相邻 8 根据准则1：S0和S2可相邻 根据准则2： S0和S1、S1和S2可相邻 根据准则3： S0和S1可相邻 根据不同的取舍可得到不同编码方案 若S0和S1、S1和S2相邻，则编码方案为： S0:00，S1:01，S2:11 若S0和S2、S0和S1相邻，则编码方案为： S0:00，S1:01，S2:10 现态S X=0 X=1 S*/Z S0 S1 S2 S0/0 S2/0 S0/0 S1/0 S1/0 S1/1 3.4 电路设计（次态函数，输出函数）  在选定的状态编码方案基础上进行电路设计 9 Y1Y0 X=0 X=1 Y1*Y0*/Z 00 01 11 00/0 11/0 00/0 01/0 01/0 01/1  根据状态转移表，推导次态逻辑函数和输出逻辑函数  次态函数/次态方程为： Y1*=𝐘𝐘𝐘𝐘•Y0•�𝐗𝐗 Y0*= 𝐘𝐘𝐘𝐘•Y0•�𝐗𝐗+X •(𝐘𝐘𝐘𝐘• 𝐘𝐘𝟎𝟎+ 𝐘𝐘𝐘𝐘•Y0+Y1•Y0) = 𝐘𝐘𝐘𝐘•Y0+ X • 𝐘𝐘𝐘𝐘+ X • Y0 将无关项编码Y1Y0=10引入化简，则Y0*= 𝐘𝐘𝐘𝐘•Y0+ X  将无关项编码Y1Y0=10引入化简，则输出函数/输出方程为： Z=Y1•Y0•X+Y1• 𝐘𝐘𝟎𝟎•X=Y1•X 若编码方案S0:00，S1:01，S2:11 现态S X=0 X=1 S*/Z S0 S1 S2 S0/0 S2/0 S0/0 S1/0 S1/0 S1/1 生成状态转移表（下表是简化的） 3.4 电路设计（函数化简） 10 00 01 11 10 00/0 11/0 00/0 00/0 01/0 01/0 01/1 01/1 Y1*=𝐘𝐘𝐘𝐘•Y0•�𝐗𝐗 Y0*= 𝐘𝐘𝐘𝐘•Y0•�𝐗𝐗+X•(𝐘𝐘𝐘𝐘•𝐘𝐘𝟎𝟎+𝐘𝐘𝐘𝐘•Y0+Y1•Y0) = 𝐘𝐘𝐘𝐘•Y0•�𝐗𝐗+X•𝐘𝐘𝐘𝐘•𝐘𝐘𝟎𝟎+X•𝐘𝐘𝐘𝐘•Y0+X•Y1•Y0 = 𝐘𝐘𝐘𝐘•Y0•�𝐗𝐗+𝐘𝐘𝐘𝐘•Y0•X+X•𝐘𝐘𝐘𝐘•𝐘𝐘𝟎𝟎+X•𝐘𝐘𝐘𝐘•Y0+X•Y1•Y0+X•𝐘𝐘𝐘𝐘•Y0 = 𝐘𝐘𝐘𝐘•Y0+X•𝐘𝐘𝐘𝐘+X•Y0 将无关项编码Y1Y0=10引入化简，则 Y0*= 𝐘𝐘𝐘𝐘•Y0•�𝐗𝐗+X•(𝐘𝐘𝐘𝐘•𝐘𝐘𝟎𝟎+𝐘𝐘𝐘𝐘•Y0+Y1•Y0+Y1•𝐘𝐘𝟎𝟎) = 𝐘𝐘𝐘𝐘•Y0•�𝐗𝐗+X•𝐘𝐘𝐘𝐘•𝐘𝐘𝟎𝟎+X•𝐘𝐘𝐘𝐘•Y0+X•Y1•Y0+X•Y1•𝐘𝐘𝟎𝟎 = 𝐘𝐘𝐘𝐘•Y0•�𝐗𝐗+𝐘𝐘𝐘𝐘•Y0•X+X•𝐘𝐘𝐘𝐘•𝐘𝐘𝟎𝟎+X•𝐘𝐘𝐘𝐘•Y0+X•Y1•Y0+X•𝐘𝐘𝐘𝐘•Y0 +X•Y1•Y0+X•Y1•𝐘𝐘𝟎𝟎+X•𝐘𝐘𝐘𝐘•𝐘𝐘𝟎𝟎+X•Y1•𝐘𝐘𝟎𝟎 = 𝐘𝐘𝐘𝐘•Y0+X•𝐘𝐘𝐘𝐘+X•Y0+X•Y1+X•𝐘𝐘𝟎𝟎 = 𝐘𝐘𝐘𝐘•Y0+X 采用代数法化简 Y1Y0 X=0 X=1 Y1*Y0*/Z3.4 电路设计（函数化简） 11 利用卡诺图化简 Y1 Y0 X Y1*Y0*Z 状态转移表 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 0 0 0 0 1 0 1 1 0 0 1 0 d d d d d d 0 0 0 0 1 1 1 X Y1Y0 00 01 11 10 0 1 d d Y1* 1 1 X Y1Y0 00 01 11 10 0 1 d 11 Y0* X Y1Y0 00 01 11 10 0 1 1 Z d d d 3.4 电路设计（确定元件，画电路图） Q一直稳定输 出，代表的是 当前状态 要基于Q和激励 函数，计算出新 状态，传给D 要基于Q和 输入X，用 输出函数计 算出输出Z 需要几个D触发器呢? 12 回顾第10次课  锁存器：用输入信号电平 驱动双稳态元件变为 输入信号指定的状态（0或1）  触发器：由时钟信号边沿 驱动双稳态元件变为 输入信号指定的状态（0或1）  状态改变所需的时间：锁存（触发）延迟  SR锁存器（输入S和R决定Q），D锁存器（输入D决定Q，C电平控制）  D触发器（输入D决定Q，时钟边沿控制）： Clk-to-Q，setup，hold 带使能，带预置  T触发器（每个时钟边沿到来时，输出反转）  时序逻辑电路的设计： 状态图，状态化简，状态编码（若干规则） 状态转移表（若干真值表），逻辑表达式（函数）化简 13 回顾第10次课（续） 14 次态方程 激励方程 输出方程 3.4 电路设计（确定元件，画电路图） (1) 触发器存储着旧状态Y0，Y1 (2) 结合输入的X，激励模块和输出模 块计算出新状态和输出结果 (3) 新状态存入触发器，回到 (1) 15 3.4 电路设计后的分析（未用状态分析）  电路分析：包括未用状态分析和电路定时分析等 • 通常编码空间比状态机的状态集合大，因而存在未用状态 如前述例子中，编码(2位)空间为4，而实际状态数为3 • 若电路加电后进入未用状态，且在未用状态之间形成循环转换 而无法进入工作状态，则称其为“挂起”现象 • 若时序逻辑电路中的触发器具有预置功能，则可以通过预置处 理，使电路进入正常的初始工作状态，从而避免“挂起” • 可利用未用状态的无关项进行化简。但需对未用状态进行分析， 以判定电路进入未用状态时能否在有限个时钟周期后进入工作 状态。若能，且没有错误输出，则称电路为具有“自启动”能 力；若不能或有错误输出，则需调整电路设计 16 分析要点：使用未用状态化简后，能否“自启动”而不会发生“挂起” 如果初始是未用状态，经过几个时钟能够进入 工作状态，但进入的状态是错的（比如才输入 一个1，就进入了连续输入两个1才应该进入的 状态），那么就会导致后续输出错误。一般也 会归入不能自启动的情况。 3.4 电路分析（未用状态分析） 17 Y1*=𝐘𝐘𝐘𝐘•Y0•�𝐗𝐗 Y0*= 𝐘𝐘𝐘𝐘•Y0 + X Z=Y1•Y0•X 最终得到 的函数 3.4 电路分析（定时分析）  时序逻辑电路定时分析 • 电路的工作频率与组合逻辑电路传输延迟、触发器建立和保持时 间、触发器传输延迟等密切相关。 18 周期性时钟 信号tclk 组合电路传播 延迟tcomb 触发器传播 延迟tffpd 也就是Clk-Q 触发器激励输入建立时 间tsetup和保持时间tholdX1 Q0~ Q1 Q0 Z1 第二个时钟周期到来之前， 目前处在第一个时钟周期里， X1会最先有效稳定送达， 然后，触发器Q端经过clk-Q延迟之后，变成初始值Q0 （可以预置） ——过了次态运算逻辑延迟之后，基于Q0和X1，算出了Q1，并到达触发器D端 （第二个时钟周期到来之前，这个D端必须保持稳定超过setup时间） ——过了输出运算延迟之后，基于Q0和X1完成了Z1的计算，且该结果不影响 其它过程，所以这个延迟只要小于时钟周期就行了，与次态计算无关 3.4 电路分析（定时分析） CLOCK 第一个时钟周期 第二个时钟周期 Q0 Q0~ Q1 Q1~ Z1 只是到 达D端 X1 X2 Q1~ Q2 Q1 Z2 3.4 电路分析（定时分析） CLOCK 第一个时钟周期 第二个时钟周期 X1 Q0 Q0~ Q1 Q1~ Z1 X2 Q1 Q1~ Q2 Q2~ Z2只是到 达D端 只是到 达D端 第二个时钟周期到来之后， X2会最先有效稳定送达， 算出的Q1保持不变，稳定在触发器的D端（hold时间） 然后，触发器Q端经过clk-Q延迟之后，变成Q1 ——过了次态运算逻辑延迟之后，基于Q1和X2，算出了Q2，并到达触发器D端 （第3个时钟周期到来之前，这个D端必须保持稳定超过setup时间） ——过了输出运算延迟之后，基于Q1和X2完成了Z2的计算 3.4 电路分析（定时分析） 21 CLOCK 触发器输出 ffpdt combt 组合电路输出 触发器输入 建立时间容限 保持时间容限holdt holdtsetupt 时间容限指为保证电路正常工作某信号定时所允许的时间范围，都大于0 tclk 3.4 电路分析（定时分析）  建立时间容限=tclk-tffpd(max)-tcomb(max)-tsetup，>0  保持时间容限=tffpd(min)+tcomb(min)-thold，>0 22 因此，得到时序约束关系： (1)tclk > tffpd(max) + tcomb(max) + tsetup (2)thold < tffpd(min) + tcomb(min) 为使触发器正常工作，必须保证时钟周期tclk不能小于触发器 锁存延迟 tffpd 加 次态信号经过激励逻辑延迟tcomb 加 触发器的建立时间tsetup 。 为使触发器正常工作，必须保证外部激励信号在时钟有效边沿到来后 的保持时间thold内能保持稳定不变。这就要求次态信号不能反馈太快。 时钟周期不能小于这个值， 但也不需要大过很多 第四讲 典型时序逻辑部件设计 23 计数器 寄存器和寄存器堆 移位寄存器 4.1 计数器  计数器是一种对外部信号进行总数统计的时序逻辑元件  一般从0开始计数，在达到最大计数值时输出一次计数完成信号， 并重新开始计数  最大计数值为计数器的模  计数器的分类 • 按时钟定时的使用方式：同步、异步 • 按计数方式：加法、减法、可逆 • 按编码方式：二进制、十进制BCD码、循环码 • 按进位方式：行波（串行）进位、并行进位 24 4.1 计数器——异步行波加法计数器 • 用T 触发器实现（上升沿触发），激励输入串行传递， 每个时钟周期传递一次。 CLK Q Q T Q Q T Q Q T Q Q T Q0 Q1 Q2 Q3 Qi+1总是在Qi由1变0时开始改变 CLK Q0 Q1 Q2 Q3 0 0 0 1 0 0 1 0 0 0 1 1 0 1 0 0 0 1 0 1 0 1 1 0 0 1 1 1 1 0 0 0 0 0 0 0 1 0 0 1 最长的延时 25 4.1 计数器——异步行波加法计数器 • Q3Q2Q1Q0转换过程为（注意：最高位为Q3） 0000→0001→0010→0011→0100→ 0101→0110→ … … →1111 26 CLK Q Q T Q Q T Q Q T Q Q T Q0 Q1 Q2 Q3 Q0每个时钟转1次，Q1每2个转1次， Q2每4个转1次，Q3每8个转1次 当编码为1111时，下个时钟到达后，经过最长的延 时（4个锁存延迟），又回到编码0000 4.1 计数器——同步并行加法计数器 • 所有触发器共用同一个时钟信号， • 在时钟信号边沿到达后，所有触发器的输出同时发生变化。 • 带使能端EN的T触发器，上升沿触发 CntEN 最高位 最低位 27 ——不一定。也 不应该每次都变 化：用EN信号 （低位Q和CntEN 相与的结果）来 控制 每个Qi一定会变 化吗？ 当编码为1111时，只要经过一个与门+锁存延时，就可回到 编码0000，比行波（串行）加法计数器快 4.1 计数器——同步并行加法计数器 • 计数器的状态编码Q3Q2Q1Q0从0000开始，转换过程为 0000→0001→0010→……→1101→1110→1111 28 CntEN有效时，每个 时钟Q0都会发生状态 改变； 对于Q1、Q2和Q3， 只有在其所有低位状 态都是1的情况下， 下个时钟边沿到来后 才会发生状态反转。 4.1 计数器 29 Qi+1总是在Qi由0变1时 (上升沿) 发生改变 CLK Q0 Q1 Q2 Q3 1 1 1 1 1 1 1 0 1 1 0 1 1 1 0 0 1 0 1 1 1 0 1 0 1 0 0 1 1 0 0 0 0 0 0 0 0 1 1 1 Q0每个时钟转1次，Q1每2个转1次，Q2每4个转1次，Q3每8个转1次 Clear清0，初态为0000  二进制异步行波减法计数器 。。。 4.2 寄存器  寄存器是用来暂存信息的逻辑部件  寄存器可直接由若干个触发器组成 30 每个时钟到来，存放内容都会改变吗？ ——不一定。 ——可以加使能端，或者让D输入不变 4.2 寄存器 寄存器是一种时序逻辑电路，但只包含存储电路 在没有新的CLK脉冲来之前，寄存器一定能保存原有内容不变 附加一些控制电路就能够实现：置零、保持（ CLK信号到达时触发器不 随D端的输入信号而改变状态，保持原来的状态不变）等功能。 接收数据时所有各位信息都是同时输入的，而且触发器中的数据是并行 地出现在输出端的。  寄存器通过三态门和总线互连 任何时刻至多只能一个Rout有效 4.2 寄存器堆  寄存器堆(Register File)：CPU内部用于暂存指令执行过程中的中间 数据，也称通用寄存器组(General Purpose Register set，GPRs)  由许多寄存器组成，每个寄存器有一个编号，CPU可对指定编号的寄 存器进行读写 32 寄存器堆中共有2k个寄存 器，每个寄存器位数为n， RA和RB分别是读口1和读 口2的寄存器编号，RW是 写口的寄存器编号 读操作属于组合逻辑操作; 写操作属于时序逻辑操作， 需要时钟信号Clk和写使 能信号WE的控制 4.2 寄存器堆内部结构 33 4.3 移位寄存器  移位寄存器 • 能够实现暂存信息的左移或右移功能，通常由时钟信号控制 例如：4个D触发器可构成一个右移寄存器 34 假设初始状态编码Q3Q2Q1Q0=0000，X输入为序列10011011 则Q3Q2Q1Q0的输出编码依次为：0000、1000、0100、0010、 1001、1100、0110、1011、1101 4.3 移位寄存器 35 右移从QA移到QD向上移↑左移从QD移到QA向下移↓  4位通用移位寄存器，如74X194 • 具有数据左移、数据右移、数据保持和数据载入功能 • 用CLR，S1，S0这三个信号的排列组合来表示不同功能 4.3 移位寄存器  4位通用移位 寄存器结构图 36 QB S1S0=00：保持 S1S0=01：上(右)移 S1S0=10：下(左)移 S1S0=11：加载 4.3 桶形移位器（无寄存功能）  一次移动多位。组合逻辑电路，采用大量多路选择器实现 37 只有移位功能 没有寄存功能 非循环移位： 逻辑右（左）移：高（低）位补0 算术右（左）移：高（低）位补符（0） 第4章总结  时序逻辑电路不仅依赖当前输入，还依赖电路当前的状态  可用时序逻辑电路实现有限状态机。有Mealy型和Mooer型两类  可用状态图或状态表描述有限状态机，圈表示状态，有向边表示输入/输出  锁存器(电平触发): SR锁存器(设置标志)、D锁存器(锁存数据D)  触发器(时钟信号clk边沿触发): D触发器(寄存器)、T触发器(计数或分频)  时序电路设计：功能分析-状态图-状态化简和编码-逻辑表达式-画图-评价  电路分析：未用状态分析(挂起/无法自启动) 定时分析(clk-Q时间、时钟周期、setup时间、hold时间)  典型组合逻辑部件：计数器、寄存器/通用寄存器组、移位寄存器  计数器：同步/异步、加1/减1、行波（串行）进位/并行进位  寄存器：由n个D触发器构成，同时由时钟信号clk定时  通用寄存器组：两个读口(组合逻辑)；一个写口(时序逻辑，clk和写使能）  移位寄存器（时序逻辑）：每次固定左移或右移1位（或几位）  桶型移位器（组合逻辑）：移位位数可变，用大量多路选择器实现 38作业：习题4、5、6、9、11、12。提交截止日期：11月1日24:00","libVersion":"0.2.4","langs":""}