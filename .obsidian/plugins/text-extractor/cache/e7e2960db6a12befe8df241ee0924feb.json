{"path":"课程/金融大数据/课件/15 Hive简介.pdf","text":"Hi v e 简介 摘要 ¨ Hi v e 基本原理 ¨ Hi v e 基本操作 2 摘要 ¨ Hi v e 基本原理 ¨ Hi v e 基本操作 3 H a d oop 生态 4 本次讲义先介绍 H i ve 2. x 版本，后对比 3. x 版本的变化 h t t p : / / h i ve . a p a ch e . o r g Hi v e ¨ T h e A p a c h e H i v e ™ is a d i s t r i b u t ed , fau l t - t ol er a n t data w a r eh ou s e s ys t em t h a t en a b l es a n a l yt i c s a t a m a s s i v e s c a l e a n d f a c i l i t a t es r ea d i n g , w r i t i n g , a n d m a n a g i n g p et a b yt es of d a t a r es i d i n g i n d i s t r i b u t ed s t or a g e u s i n g SQ L . 使用 H a d oop 进行数据分析 ¨ 通过前面的课程知道，很多分析任务可以通过 H a d oop 集群进行，即可以通过 H a d oop 集群将任务分布到数百甚至上千个节点中进行分析，通过并行执行缩 短分析的时间 ¨ H a d oop 通过 M a p R ed u c e 的并行化方式进行并行处理，能够充分利用数目庞大的 服务器节点 ¨ 但是， M a p R ed u c e 是一个底层的编程接口，对于数据分析人员来说，这个编程 接口并不是十分友好，还需要进行大量的编程以及调试工作 6 在 H a d oop 上加入数据分析功能 ¨ 显然，为了能够支持一个类似于 SQ L 相关的数据查询语言， H a d oop 还需要加入一些额外的模块才能够方便数据分析人员的使用，这些 额外的模块包括： ¤ 数据查询语言本身的定义与构造，这是与终端用户进行交互的接口，最简 单的可以通过命令行接口的方式展开用户与系统的交互 ¤ 构造数据查询语言的执行引擎，即将上述的查询语言进行编译，并通过分 布式的执行引擎完成查询，在 Hi v e 中，执行引擎会将查询语言翻译为多个 M a p R ed u c e 的任务序列，交给 M a p R ed u c e 程序去执行 ¤ 数据查询语言本身需要定义一套数据组织的格式 7 Hi v e 简介 ¨ Hi v e 可以被认为是一种数据仓库，包括数据的存储以及查询 ¨ Hi v e 包括一个高层语言的执行引擎，类似于 SQ L 的执行引擎 ¨ Hi v e 建立在 H a d oop 的其它组成部分之上，包括 Hi v e 依赖于 HDF S 进行数据保存，依赖于 M a p R ed u c e 完成查询操作 ¨ Hi v e 最初的开发由 F a c e b ook 推动，在 F a c e b ook 内部每天会搜集大量的数据，并需要在 这些数据上进行大量分析 ¨ 最初的分析是通过手工的 p yt h on 脚本形式进行 ¨ 数据分析的数量十分巨大，在 2006 年每天需要分析数十个 GB 左右的数据，在 2007 年 增长到大约 TB 的量级，现在数据分析的数量可能是这个数量的 10 倍 8 Hi v e 是什么 ¨ Hi v e 是一个基于 Apac h e H a d oop 的 数据仓库 。对于数据存储与处 理， H a d oop 提供了主要的扩展和容错能力。 ¨ Hi v e 设计的初衷：对于大量的数据，使得数据汇总、查询和分析 更加简单。它提供了 SQ L ，允许用户简单地进行查询、汇总和数 据分析。 ¨ Hi v e 的 SQ L 给予了用户多种方式来集成自己的功能，然后做定制 化的查询，例如用户自定义函数。 9 Hi v e 优点 ¨ 可扩展性 ：横向扩展， H i v e 可以自由的扩展集群的规模，一般情 况下不需要重启服务。 ¨ 延展性 ： H i v e 支持自定义函数，用户可以根据自己的需求来实现 自己的函数。 ¨ 良好的容错性 ：可以保障即使有节点出现问题， SQ L 语句仍可完 成执行。 10 Hi v e 缺点 ¨ H i v e 不支持记录级别的增删改操作，但是用户可以通过查询生成 新表或者将查询结果导入到文件中（新版本支持记录级别的插入 操作） ¨ H i v e 的查询延时很严重，因为 M a p R ed u c e J ob 的启动过程消耗很 长时间，所以不能用在交互查询系统中。 ¨ Hi v e 不是为在线事务处理而设计，所以主要用来做 OL A P （联机 分析处理），而不是 OL T P （联机事务处理）。它最适合用于传 统的数据仓库任务。 11 RD BM S vs Hi v e ¨ Hi v e 和关系数据库存储文件的系统不同， Hi v e 使用的是 H a d oop 的 HDF S ，关系数 据库则是服务器本地的文件系统； ¨ Hi v e 使用的计算模型是 M a p R ed u c e ，而关系数据库则是自己设计的计算模型； ¨ 关系数据库都是为实时查询的业务进行设计的，而 Hi v e 则是为海量数据做数据 挖掘设计的，实时性很差；实时性的区别导致 Hi v e 的应用场景和关系数据库有 很大的不同； ¨ Hi v e 很容易扩展自己的存储能力和计算能力，这个是继承 H a d oop 的，而关系数 据库在这个方面要比数据库差很多。 12 RD BM S vs Hi v e 13 H i ve 具有 SQ L 数据库的外表，但应用场景完全不同， Hi v e 只适合 用来做海量离线数据统计分析，也就是数据仓库 。 H Ba s e vs Hi v e ¨ H Ba s e 和 Hi v e 在大数据架构中处在不同位置， H Ba s e 主要解决实时数 据查询问题， Hi v e 主要解决数据处理和计算问题，一般是配合使用。 ¤ H Ba s e 主要针对的是 OL T P 应用 ¤ Hiv e 主要针对的是 O LA P 应用 14 OL T P 数据库 OL A P 数据仓库 ETL H Ba s e vs Hi v e ¨ 区别 ¤ H Ba s e ： 基于 H a d oop 的 N oSQ L 数据库，主要适用于海量明细数据（十 亿、百亿）的随机实时查询，如日志明细、交易清单、轨迹行为等。 ¤ Hiv e ：基于 H a d oop 的数据仓库，严格来说，不是数据库，主要是让开 发人员能够通过 SQ L 来计算和处理 HDF S 上的结构化数据，适用于离线 的批量数据计算。 n 通过元数据来描述 Hd f s 上的结构化文本数据，通俗点来说，就是定义一张表 来描述 HDF S 上的结构化文本，包括各列数据名称，数据类型是什么等，方便 我们处理数据，当前很多 SQ L O N H a d oop 的计算引擎均用的是 hi v e 的元数据， 如 Sp a r k SQ L 、 Im p a la 等； n 通过 SQ L 来处理和计算 HDF S 的数据， Hi v e 将 SQ L 翻译为 M a p R ed u c e 来处理数据。 15 H Ba s e vs Hi v e ¨ 区别 ¤ Hiv e 中的表是纯逻辑表，就只是表的定义等，即表的元数据。 Hiv e 本 身不存储数据，它完全依赖 HDF S 和 M a p R ed u c e 。这样就可以将结构化 的数据文件映射为为一张数据库表，并提供完整的 SQ L 查询功能，并 将 SQ L 语句最终转换为 M a p R ed u c e 任务进行运行。而 H Ba s e 表是物理表， 适合存放非结构化的数据。 ¤ Hiv e 是基于 M a p R ed u c e 来处理数据 , 而 M a p R ed u c e 处理数据是基于行的模 式； H Ba s e 处理数据是基于列的而不是基于行的模式，适合海量数据 的随机访问。 16 H Ba s e vs Hi v e ¨ 区别 ¤ H Ba s e 的表是疏松的存储的，因此用户可以给行定义各种不同的列； 而 Hiv e 表是稠密型，即定义多少列，每一行有存储固定列数的数据。 ¤ Hiv e 使用 H a d oop 来分析处理数据，而 H a d oop 系统是批处理系统，因此 不能保证处理的低迟延问题；而 H Ba s e 是近实时系统，支持实时查询。 ¤ Hiv e 不提供 ro w - l ev el 的更新，它适用于大量 a p p en d - on l y 数据集（如日 志）的批任务处理。而基于 H Ba s e 的查询，支持和 ro w - l ev el 的更新。 ¤ Hiv e 提供完整的 SQ L 实现，通常被用来做一些基于历史数据的挖掘、分 析。而 H Ba s e 不适用与有 j oi n ，多级索引，表关系复杂的应用场景。 17 H Ba s e vs Hi v e ¨ 关系 ¤ 在大数据架构中，两者是协作关系，数据流一般如下图： n 通过 ETL 工具将数据源抽取到 HDF S 存储； n 通过 Hi v e 清洗、处理和计算原始数据； n Hi v e 清洗处理后的结果，如果是面向海量数据随机查询场景的可存入 H Ba s e ； n 数据应用从 H Ba s e 查询数据。 18 Hi v e 的应用范围举例 ¨ 日志分析 ：在互联网公司中，每天会产生大量的日志数据，分析这些日志数据是每天 都需要进行的重要工作；日志分析可以优化系统，可以获知用户行为，也可以获知数 据的统计信息 ¨ 数据挖掘 ：通过对结构化数据的挖掘，能够获得原先使用者没有意识到的信息 ¨ 文档索引 ：可以对一系列文档进行分析，并形成文档的索引结构，不一定是完整的倒 排表，可能是关联信息的索引 ¨ 商业智能信息处理 ：可以对商业信息进行查询分析，从中可以获得一些智能决策的信 息 ¨ 即时查询以及数据验证 ：数据分析人员可能临时需要验证数据的特性，需要查询引擎 迅速进行数据统计分析 19 Hi v e 的体系结构 20 Hi v e 的组成模块 (1) ¨ Dr iv er 组件 ：核心组件，整个 Hi v e 的核心。该组件包括 C om p l i er 、 O p t i m i z er 和 E x ec u t or ，它的作用是将我们写的 HQ L 语句进行解析、编 译优化，生成执行计划，然后调用底层的 M a p R ed u c e 计算框架。 ¤ C om p i l er ： Hi v e 需要一个编译器，将 H i v eQ L 语言编译成中间表示，包括对于 H i v eQ L 语言 的分析，执行计划的生成等工作 ¤ O p t i m i z er ：进行优化 ¤ E x ec u t or ：执行引擎，在 D r i v er 的驱动下，具体完成执行操作，包括 M a p R ed u c e 执行，或 者 HDF S 操作，或者元数据操作 21 Hi v e 的组成模块 (2) ¨ Me t a st o r e 组件 ：数据服务组件，用以存储 Hi v e 的元数据：存储操作的数据对象 的格式信息，在 HDF S 中的存储位置的信息以及其他的用于数据转换的信息 Ser D e 等。 Hi v e 的元数据存储在关系数据库里， Hi v e 支持的关系数据库有 d er b y 、 m ys q l 。 ¨ CLI 组件 ： C om m a n d L i n e I n t er f a c e ，命令行接口。 ¨ Thr if tS er v er s ：提供 J D BC 和 O D BC 接入的能力，它用来进行可扩展且跨语言的服 务的开发， Hi v e 集成了该服务，能让不同的编程语言调用 Hi v e 的接口。 ¨ Hiv e W EB Inter f a c e （ HW I ） ： Hi v e 客户端提供了一种通过网页的方式访问 hiv e 所 提供的服务。这个接口对应 Hi v e 的 H WI 组件（ h i v e w e b i n t er f a c e ） 22 Hi v e 的组成模块 (3) ¨ H i v eQ L ：这是 Hi v e 的数据查询语言，与 SQ L 非常类似。 Hi v e 提供了这个数据查 询语言与用户的接口，包括一个 s h el l 的接口，可以进行用户的交互以及网络接 口与 J D BC 接口。 J D BC 接口可以用于编程，与传统的数据库编程类似，使得程 序可以直接使用 Hi v e 功能而无需更改。 23 Hi v e 的执行流程简单示意图 24 H i v e 将通过 CLI 接入， J D BC /O D BC 接入，或者 H WI 接入的相关 查询，通过 D r i v er ( C om p l i er 、 O p t i m i z er 和 E x ec u t or ) ，进行编译， 分析优化，最后变成可执行的 M a p R ed u c e 。 Hi v e 的执行流程 25 h t t p s: / / cw i ki . a p a ch e . o r g / co n f l u e n ce / d i sp l a y/ H i ve / D e si g n # D e si g n - H i ve A r ch i t e ct u r e Hi v e 客户端 26 通过 将 H i ve 运行为服务器 h i ve -- se r vi ce h i ve se r vi ce 可以 启动一个服务， 而后可以通过不同的客户端连接到这个服务去访问 H i ve 提供的功能。 Hi v e 客户端 ¨ Thr i f t 客户端：被绑定在多种语言中，包括 C+ + ， Ja v a ， PH P ， Pyt h on 以及 Ru b y 等 ¨ J D BC 驱动：提供纯 Ja v a 的 J D BC 驱动，连接字符串类似于 jd b c :h iv e : // h os t : p or t / dbn am e ，除非使用了嵌入的模式，否则 J D BC 模式的驱动访问了 Thr i f t 服务器 ¨ O D BC 驱动：与 J D BC 类似，但尚未成熟 27 Hi v e 的数据模型 ¨ 每一个类似于数据库的系统都首先需要定义一个数据模型，然后才是在这个数 据模型之上的各种操作 ¨ T a b l es （表）： Hi v e 的数据模型由数据表组成。 数据表中的列是有类型的（ int , f l oa t , s t r i n g , d a t a , b ool ea n ）也可以是复合的类型，如 l i s t , m a p （类似于 J SO N 形 式的数据） ¨ P a r t i t i on s （分区）：数据表可以按照一定的规则进行划分 P a r t i t i on 。 例如，通过 日期的方式将数据表进行划分 ¨ Bu c k et s （桶）：数据存储的桶。 在一定范围内的数据按照 Hash 的方式进行划分 （这对于数据的抽样以及对于 j oi n 的优化很有意义） 28 表 ¨ H i v e 表跟关系数据库里面的表类似。逻辑上，数据是存储在 H i v e 表里面的，而表的元数据描述了数据的布局。我们可以对表执行 过滤，关联，合并等操作。在 H a d oop 里面，物理数据一般是存 储在 H D F S 的，而元数据是存储在关系型数据库的。 ¨ 当我们在 H i v e 创建表的时候， H i v e 将以默认的方式管理表数据， 也就是说， H i v e 会默认把数据存储到 / u s er /h i v e/w a r eh ou s e 目录 里面。除了内部表，我们可以创建外部表，外部表需要指定数据 的目录。 29 数据的物理分布情况 ¨ Hi v e 在 HDF S 中有固定的位置，通常被放置在 HDF S 的如下目录中： /u s er /h i v e/w a r eh ou s e ¨ 每个数据表被存放在 w a r eh ou s e 的子目录中。进一步来说，数据 划分 P a r t i t i on 、数据桶 Bu c k et s 形成了数据表的子目录 ¨ 数据可能以任意一种形式存储，例如： ¤ 使用分隔符的文本文件，或者是 Seq u en c eF i l e ¤ 使用用户自定义的 Ser D e ，则可以定义任意格式的文件 30 Hi v e 的数据模型 31 Hi v e 的数据模型 32 分区 ¨ 为了提高查询数据的效率， Hi v e 提供了表分区机制。分区表基于 分区键把具有相同分区键的数据存储在一个目录下，在查询某一 个分区的数据的时候，只需要查询相对应目录下的数据，而不会 执行全表扫描，也就是说， Hi v e 在查询的时候会进行分区剪裁。 每个表可以有一个或多个分区键。 33 桶 ¨ Hi v e 可以对每一个表或者是分区，进一步组织成桶，也就是说桶 是更为细粒度的数据范围划分。 Hi v e 是针对表的某一列进行分桶。 Hi v e 采用对表的列值进行哈希计算，然后除以桶的个数求余的方 式决定该条记录存放在哪个桶中。分桶的好处是可以获得更高的 查询处理效率，使取样更高效。 34 元数据存储： m et a s t or e ¨ 在 Hi v e 中由一系列的数据表格组成一个命名空间，关于这个命名空间的描述信 息会保存在 m et a s t or e 的空间中 ¨ 元数据使用 SQ L 的形式存储在传统的关系数据库中，因此可以使用任意一种关 系数据库，例如 D er b y （ Apac h e 的关系数据库实现）， M ySQ L 以及其他的多种 关系数据库存储方法 ¨ 在数据库中，保存最重要的信息是有关数据库中的数据表格描述，包括每一个 表的格式定义，列的类型，物理的分布情况，数据划分情况等 35 m et a s t or e ¨ m et a s t or e 包括两个部分：服务和后台的数据存储 ¤ E m b ed d ed m et a s t or e : 默认使用内嵌的 D er b y 数据库实例，每次只能打 开一个 Hiv e 会话 ¤ L oc a l m et a s t or e : 可以使用运行在一个进程中的 m et a s t or e 进程来访问独 立的数据库，可通过 J D BC 进行设置具体的数据库访问 ¤ R em ot e m et a s t or e : 一个或者多个 m et a s t or e 服务器和 Hiv e 服务运行在不同 的进程内 36 m et a s t or e 的配置情况 37 默认情况下， m e t a st o r e 服务和 H i ve 的服务运行在 同一个 JV M 中，包含了一个内嵌的以本地磁盘作为 存储的 Der by （ H i ve 自带的数据库）数据库实例。 任何 JD B C 兼容的数据库都可以通过 j a va x . j d o . o p t i o n .* 配置属性来供 m e t a st o r e 使用。 通过 h i ve . m e t a st o r e . u r i s 设置为 m e t a st o r e 服务器 UR I （ 如果有多个服务器，可以用逗号分割），把 h i ve 服务设为使用远程 m e t a st o r e 服务器的 UR I 的格 式为： th r i f t: / / h o st : p o r t 。 Hi v e 3. x 变化 ¨ 执行引擎更改 ¤ A p a c h e T ez 成为默认的 Hiv e 执行引擎。通过有向无环图（ DA G ）和数据 传输原语的表达式，在 T ez 下执行 Hiv e 查询可以提高性能。 1. Hi v e 编译查询。 2. T ez 执行查询。 3. Y A RN 为群集中的应用程序分配资源，并 为 Y A RN 队列中的 Hi v e 作业启用授权。 4. Hi v e 根据表类型更新 HDF S 或 Hi v e 仓库中 的数据。 5. Hi v e 通过 J D BC 连接返回查询结果。 Hi v e 3. x 变化 ¨ 设计影响安全性的更改 ¤ 默认情况下， H a d oop 3 . 0 A m b a r i 安装添加了 A p a c h e R a n g er 安全服务。 Hiv e 的主要授权模型是 R a n g er 。此模型仅允许 Hiv e 访问 HDF S 。 Hiv e 强制 执行 R a n g er 中指定的访问控制。此模型提供比其他安全方案更强的安 全性以及更灵活的策略管理。 ¨ HDF S 权限更改 ¤ HDF S 访问控制列表（ AC L ）是 HDF S 中权限系统的扩展。 H a d oop 3 . 0 默 认打开 HDF S 中的 AC L ，在为多个组和用户提供特定权限时，可以提高 灵活性方便地将权限应用于目录树而不是单个文件。 Hi v e 3. x 变化 ¨ 交易处理变更 AC I D v2 ，对很多事务的特性进行了优化升级，使 之更接近于关系型数据库。 ¤ 使用 AC I D 语义修改现有 Hiv e 表数据，包括 i n s er t , u p d a t e , d el et e , m er g e ¤ 支持数据库四大特性 AC I D ¤ 允许在使用长时间运行的分析查询同时进行并发更新 ¤ 使用 MV C C (Mu l ti - V er s i on c on c u r r en c y C on t r ol ) 架构 Hi v e 3. x 变化 ¨ 客户端 ¤ H i v e 3 仅支持瘦客户端 Beel i n e ，用于从命令行运行查询和 Hiv e 管理命令。 Beel i n e 使用与 H i v eSer v er 的 J D BC 连接来执行所有命令。 ¤ Hiv e 客户端的更改要求使用 gr u n t 命令行来使用 A p a c h e Pi g 。 ¤ H i v eSer v er 现在使用远程而不是嵌入式 M et a s t or e 。 ¨ Sp a r k 目录更改 ¤ Sp a r k 和 Hiv e 现在使用独立的目录来访问相同或不同平台上的 Sp a r k SQ L 或 Hiv e 表。 Sp a r k 创建的表驻留在 Sp a r k 目录中。 Hiv e 创建的表位于 Hiv e 目录中。虽然是独立的，但这些表互操作。 ¤ 可以使用 H i v eW a r eh ou s eC on n ec t or 从 Sp a r k 访问 AC I D 和外部表。 Hi v e 3. x 变化 ¨ 批处理和交互式工作负载的 H a d oop 3 . 0 查询执行体系结构 L o w L a t en c y A n a l yt i c a l Pr oc es s i n g 摘要 ¨ Hi v e 基本原理 ¨ Hi v e 基本操作 43 Hi v e 的安装和配置 ¨ 下载 h t t p s : //d l c d n . a p a c h e . or g /h i v e/ ¨ 版本 ¤ 2. 3. 9 June 9, 2021 ( s t abl e - 2) w or k s w i t h H a d oop 2 . x. y ¤ 3. 1. 3 A pr i l 08, 2022 w or k s w i t h H a d oop 3 . x. y ¤ 4. 0. 0 - b et a - 1 A u gu s t 14, 2023 w or k s w i t h H a d oop 3 . x. y 44 Hi v e 的安装和配置 ¨ 前提 ¤ m ys q l 及驱动（也可以用自带的 d er b y 数据库） ¨ 安装 ¤ 解压 ¤ 配置 hi v e - en v . s h n H A D O O P_H O M E ¤ 配置 hi v e - s i t e . xm l n 关系数据库的相关属性 45 Hi v e 的安装和配置 ¨ 要想 Hi v e 使用 HDF S 进行数据仓库的存储，使用 M a p R ed u c e 进行 HQL 语言的执行， 需要进行相应的配置。 ¤ hi v e - en v . s h n Set H A D O O P_H O M E ¤ hi v e - s i t e . xm l (hi v e - d ef a u l t . xm l . t em p l a t e ) n 元数据仓库 < p r op er t y> < n a m e> j a v a x. j d o . op t i on . C on n ec t i on U RL < /n a m e> < v a l u e> j d b c : d er b y :; d a t a b a s eN a m e = m et a s t or e_d b ; c r ea t e = t r u e< /v a l u e> < /p r op er t y> n 元数据文件目录 < p r op er t y> < n a m e> h i v e . m et a s t or e . w a r eh ou s e . d i r < /n a m e> < v a l u e> /u s er /h i v e/w a r eh ou s e< /v a l u e> < /p r op er t y> 46 如果选择的是 m ys q l 数据库，要先安 装 m ys q l ，并且将 m ys q l 的驱动包放入 hiv e 的 lib 文件夹 启动 Hi v e 的命令行界面 s h el l ¨ 完成 Hi v e 系统的合适配置之后，打开任意一个命令行界面，执行 下面的命令就可以启动 hi v e 的界面 ¨ $ c d /h i v e/i n s t a l l /d i r ec t or y 进入 hi v e 的安装目录 ¨ $ b i n /h i v e 如果已经将 hi v e 加入到执行路径，则可以直接执行 hi v e 即可 ¨ 执行成功的话，我们就可以看到 hi v e 的主界面 h i v e> ¨ 等待用户输入查询命令 47 注意：在运行 hiv e 前要先确保 H a d oop 已经启动（ st ar t - dfs , s t a r t - ya r n ）和配置的关系数据库 （ d er b y 或 m ys q l ）已经启动并完成初始化 ： $H IVE_H OM E/b in / sch emat o o l - dbT y pe de rby - init Schema H i v e Q L ¨ Hi v e 主要支持以下几类操作： ¤ DDL ：数据定义语句，包括 C RE A T E , A L T E R, SH O W , D E SC RI BE , D RO P 等 ¤ DM L ：数据操作语句，包括 LO A D D A T A , I N SE RT 。 Hiv e 的设计中没有考 虑 U PD A T E 操作。 ¤ QU E R Y ：数据查询语句，主要是 SE L E C T 语句。 48 创建数据表的命令 ¨ 显示所有的数据表 ¤ h i v e> s h o w t a b l es ; ¨ 创建一个表，这个表包括两列，分别是整数类型以及字符串类型， 使用文本文件表达 ¤ h i v e> C RE A T E T A BL E p ok es ( f oo I N T , b a r ST RI N G ) ; ¤ h i v e> C RE A T E T A BL E i n v i t es ( f oo I N T , b a r ST RI N G ) P A RT I T I O N E D BY ( d s ST RI N G ) ; ¤ h i v e> C RE A T E T A BL E Sh a k es p ea r e ( f r eq i n t , w or d s t r i n g ) r o w f or m a t d el i m i t ed f i el d s t er m i n a t ed b y ' \\ t' s t or ed a s t e xt f i l e ; // 定义这张表使用的数据文件格式，这里指定为 t xt 类型 49 描述数据表的命令 ¨ 显示所创建的数据表的描述，即创建时候对于数据表的定义 ¤ h i v e> D E SC RI BE i n v i t es ； ¨ 修改表的语句 ¤ h i v e> A L T E R T A BL E p ok es A D D C O L U M N S ( n e w _c ol INT); ¤ h i v e> A L T E R T A BL E i n v i t es A D D C O L U M N S ( n e w _c ol 2 I N T C O M M E N T ' a c om m en t ' ) ; ¤ h i v e> A L T E R T A BL E i n v i t es RE PL A C E C O L U M N S ( f oo I N T , b a r ST RI N G , baz INT C O M M E N T ' baz r ep l a c es n e w _c ol 2 ' ) ; 50 装入数据 ¨ 数据装入到 Hi v e 中 ¤ h i v e> L O A D D A T A L O C A L I N P A T H ' . /e xa m p l es /f i l es /k v 1 . t xt ' O V E R WRI T E I N T O T A BL E p ok es ; ¨ NO T E S ¤ I f t h e ' O V E R WRI T E ' k e yw or d i s om i t t ed , d a t a f i l es a r e a p p en d ed t o e xi s t i n g d a t a s et s . ¤ N O v er i f i c a t i on of d a t a a g a i n s t t h e s c h em a i s p er f or m ed b y t h e l oa d c om m a n d . ¤ I f t h e f i l e i s i n hd f s , i t i s m ov ed i n t o t h e H i v e - c on t r ol l ed f i l e s ys t em n a m es p a c e . 51 装入数据 ¨ 分区 ¤ h i v e> L O A D D A T A L O C A L I N P A T H ' . /e xa m p l es /f i l es /k v 2 . t xt ' O V E R WRI T E I N T O T A BL E i n v i t es P A RT I T I O N ( d s = ' 2 0 0 8 - 08 - 15’); ¤ h i v e> L O A D D A T A L O C A L I N P A T H ' . /e xa m p l es /f i l es /k v 3 . t xt ' O V E R WRI T E I N T O T A BL E i n v i t es P A RT I T I O N ( d s = ' 2 0 0 8 - 08 - 08’); ¨ 从 HDF S 装入数据 ¤ h i v e> L O A D D A T A I N P A T H ' /u s er / m yn a m e /k v 2 . t xt ' O V E R WRI T E I N T O T A BL E i n v i t es P A RT I T I O N ( d s = ' 2 0 0 8 - 08 - 15' ); 52 SE L E C T S a n d F I L T E RS ¨ h i v e> SE L E C T a . f oo F RO M i n v i t es a WH E RE a.ds =' 2008 - 08 - 15' ; ¨ h i v e> SE L E C T a . f oo F RO M i n v i t es a WH E RE a.ds =' 2008 - 08 - 1 5 ' s or t b y a . f oo asc l i m i t 1 0 ; ¨ h i v e> I N SE RT O V E R WRI T E D I RE C T O R Y ' / tmp / h d f s _ou t ' SE L E C T a . * F RO M i n v i t es a WH E RE a.ds =' 2008 - 08 - 15' ; ¨ h i v e> I N SE RT O V E R WRI T E L O C A L D I RE C T O R Y ' / tmp / l oc a l _ou t ' SE L E C T a . * F RO M p ok es a ; 53 G r ou p By ¨ G r ou p b y 通常和聚合函数一起使用，按照一个或者多个列进行分 组，然后对每个组进行聚合操作。 ¨ h i v e> I N SE RT O V E R WRI T E T A BL E ev en t s SE L E C T a. bar , c ou n t ( * ) F RO M i n v i t es a WH E RE a . f oo > 0 G RO U P BY a. bar ; 54 G r ou p By ¨ 聚合函数 55 J oi n ¨ J oi n 主要对两个表通过两个相同的字段进行连接，并查询相关的 结果。 ¨ h i v e> SE L E C T t 1 . b a r , t 1 . f oo , t 2 . f oo F RO M p ok es t 1 J O I N i n v i t es t 2 O N t1 .b a r = t2 .b a r ; 56 排序 ¨ or d er by ¤ 全局排序，只有一个 r ed u cer ¤ A SC ：升序（默认）； D E SC ：降序 ¤ h i v e> s el ec t * f r om em p or d er b y sal d es c ; // 查询员工信息按工资降序排列 ¤ 在严格模式下（ s et h i v e . m a p r ed . m od e = s t r i c t ）， or d er b y 必须要和 lim it 一起用，否则是会 报错的。 H i v e 一般默认使用的是非严格模式（ s et h i v e . m a p r ed . m od e = n on s t r i c t ） ¨ s or t by ¤ s or t by 为每个 r ed u c er 产生一个排序文件，首先要设置 r ed u c er 个数 (>1) 。 s or t by 只会保证每个 r ed u c er 的输出有序，并不保证全局有序。 ¤ hiv e > s et m a p r ed u c e . j ob . r ed u c er s =3 ; ¤ hiv e > s el ec t * f r om em p s or t b y d ep t n o d es c ; // 根据部门编号降序查看员工信息 排序 ¨ di s t r i bu t e by ¤ 在有些情况下，我们需要控制某个特定行应该到哪个 r ed u c er ， 通常是为了 进行后续的聚集操作。 d i s t r i b u t e b y 子句可以做这件事。 d i s t r i b u t e b y 类似 MR 中 p a r t i t i on （ 自定义分区），进行分区，结合 s or t b y 使用。 d i s t r i b u t e b y 的分 区规则是根据分区字段的 ha s h 码与 r ed u c e 的个数进行模除后， 余数相同的 分到一个区。 ¤ D I ST RI B U T E BY 语句要写在 SO RT BY 语句之前。 ¤ hiv e > s et m a p r ed u c e . j ob . r ed u c er s =3 ; ¤ h i v e> i n s er t ov er w r i t e l oc a l d i r ec t or y ' /op t /m od u l e/d a t a /d i s t r i b u t e - r es u l t ' s el ec t * f r om em p d i s t r i b u t e b y d ep t n o s or t b y em p n o d es c ; // 先按照部门编号分区，再按照员工编号降序排序。 排序 ¨ c l u s t er b y ¤ 当 d i s t r i b u t e b y 和 s or t b y 字段相同时，可以使用 c l u s t er b y 方式。 ¤ c l u s t er b y 除了具有 d i s t r i b u t e b y 的功能外还兼具 s or t b y 的功能。但是排序只能 是升序排序，不能指定排序规则为 A SC 或者 D E SC 。 ¤ h i v e> s el ec t * f r om em p c l u s t er b y d ep t n o ; // 先按照部门编号分区并按升序排序 ¤ 等同于 ¤ h i v e> s el ec t * f r om em p d i s t r i b u t e b y d ep t n o s or t b y d ep t n o ; H i v e: E xa m p l e ¨ H i v e l ook s s i m i l a r t o a n SQ L d a t a b a s e ¨ R el a t i on a l j oi n on t w o t a b l es : ¤ T a b l e of w or d c ou n t s f r om Sh a k es p ea r e c ol l ec t i on ¤ T a b l e of w or d c ou n t s f r om t h e b i b l e S o u r ce : M a t e r i a l d r a w n f r o m Clo u d e r a tr a i n i n g V M SEL EC T s. w o r d , s. f r e q , k. f r e q FR O M sh a ke sp e a r e s JO I N b i b l e k O N ( s. w o r d = k. w o r d ) W H E R E s. f r e q >= 1 A N D k. f r e q >= 1 OR D E R B Y s. f r e q DE S C L I M I T 1 0 ; th e 25848 62394 I 23031 8854 and 19671 38985 to 18038 13526 of 16700 34654 a 14170 8057 yo u 12702 2720 my 11297 4135 in 10797 12445 is 8882 6884 H i v e: E xa m p l e ¨ H i v e l ook s s i m i l a r t o a n SQ L d a t a b a s e ¨ R el a t i on a l j oi n on t w o t a b l es : ¤ T a b l e of w or d c ou n t s f r om Sh a k es p ea r e c ol l ec t i on ¤ T a b l e of w or d c ou n t s f r om t h e b i b l e S o u r ce : M a t e r i a l d r a w n f r o m Clo u d e r a tr a i n i n g V M SEL EC T s. w o r d , s. f r e q , k. f r e q FR O M sh a ke sp e a r e s JO I N b i b l e k O N ( s. w o r d = k. w o r d ) W H E R E s. f r e q >= 1 A N D k. f r e q >= 1 OR D E R B Y s. f r e q DE S C L I M I T 1 0 ; th e 25848 62394 I 23031 8854 and 19671 38985 to 18038 13526 of 16700 34654 a 14170 8057 yo u 12702 2720 my 11297 4135 in 10797 12445 is 8882 6884 H i v e: Beh i n d t h e Sc en es SEL ECT s. w o r d , s. f r e q , k. f r e q FR O M sh a ke sp e a r e s JO I N b i b l e k O N ( s. w o r d = k. w o r d ) W H E R E s. f r e q >= 1 A N D k. f r e q >= 1 OR D E R B Y s. f r e q DESC L I M I T 1 0 ; ( T O K _ Q U E R Y ( T O K _ F R O M ( T O K _ JO I N ( T O K _ T A B R E F sh a ke sp e a r e s) ( T O K _ T A B R E F b i b l e k) ( = ( . ( T O K _ T A B L E _ O R _ C O L s) w o r d ) ( . ( T O K _ T A B L E _ O R _ C O L k) w o r d ) ) ) ) ( T O K _ I N S E R T ( T O K _ D E S T I N A T I O N ( T O K _ D I R T O K _ T M P _ F I L E ) ) ( T O K _ S E L E C T ( T O K _ S E L E X P R ( . ( T O K _ T A B L E _ O R _ C O L s) w o r d ) ) ( T O K _ S E L E X P R ( . ( T O K _ T A B L E _ O R _ C O L s) f r e q ) ) ( T O K _ S E L E X P R ( . ( T O K _ T A B L E _ O R _ C O L k) f r e q ) ) ) ( T O K _ W H E R E ( A N D ( > = ( . ( T O K _ T A B L E _ O R _ C O L s) f r e q ) 1 ) ( > = ( . ( T O K _ T A B L E _ O R _ C O L k) f r e q ) 1 ) ) ) ( T O K _ O R D E R B Y ( T O K _ T A B S O R T C O L N A M E D E S C ( . ( T O K _ T A B L E _ O R _ C O L s) f r e q ) ) ) ( T O K _ L I M I T 1 0 ) ) ) ( o n e o r m o r e o f M a p R e d u ce j o b s) ( A b st r a ct S yn t a x T r e e ) H i v e: Beh i n d t h e Sc en es ST AG E D EPEN D EN C I ES: St a g e - 1 i s a r oot s t age St a g e - 2 depends on s t ages : S t age - 1 St a g e - 0 i s a r oot s t age ST AG E PL AN S: St a g e : St a g e - 1 Ma p R e d u c e Al i a s - > M a p O p e r a t o r T r e e : s Ta b l e S c a n al i as : s Fi l t e r O p e r a t o r pr edi c at e: ex pr : ( fr e q > = 1 ) ty p e : bool ean Re d u c e O u t p u t O p e r a t o r ke y e xp r e ssi o n s: ex pr : w o r d ty p e : s tr i n g so r t o r d e r : + Ma p - re d u c e p a rt i t i o n co l u m n s: ex pr : w o r d ty p e : s tr i n g ta g : 0 va l u e e xp r e ssi o n s: ex pr : fr e q ty p e : in t ex pr : w o r d ty p e : s tr i n g R e d u ce O p e r a t o r T r e e : Jo i n O p e r a t o r co n d i t i o n m a p : I n n e r Jo i n 0 t o 1 co n d i t i o n e xp r e ssi o n s: 0 { V A L U E . _ co l 0 } { V A L U E . _ co l 1 } 1 { V A L U E . _ co l 0 } outputC ol um nN am es : _ co l 0 , _ co l 1 , _ co l 2 Filte r Op e ra to r p r e d i ca t e : e xp r : ( ( _ co l 0 > = 1 ) a n d ( _ co l 2 > = 1 ) ) t yp e : bool ean S e l e ct O p e r a t o r e xp r e ssi o n s: e xp r : _ co l 1 t yp e : st r i n g e xp r : _ co l 0 t yp e : in t e xp r : _ co l 2 t yp e : in t outputC ol um nN am es : _ co l 0 , _ co l 1 , _ co l 2 File Ou tp u t Op e ra to r co m p r e sse d : f a l se GlobalTableId : 0 table: in p u t fo rma t: o r g . a p a ch e . h a d o o p . m a p r e d . S e q u e n ce F i l e I n p u t F o r m a t output for m at: o r g . a p a ch e . h a d o o p . h i ve . q l . i o . H i ve S e q u e n ce F i l e O u t p u t Fo rma t St a g e : St a g e - 2 M a p R e d u ce A l i a s - > M a p O p e r a t o r T r e e : h d f s: / / l o ca l h o st : 8 0 2 2 / t m p / h i ve - tr a i n i n g /3 6 4 2 1 4 3 7 0 /1 0 0 0 2 R e d u ce O u t p u t O p e r a t o r ke y e xp r e ssi o n s: e xp r : _ co l 1 t yp e : in t so r t o r d e r : - ta g : - 1 va l u e e xp r e ssi o n s: e xp r : _ co l 0 t yp e : st r i n g e xp r : _ co l 1 t yp e : in t e xp r : _ co l 2 t yp e : in t R e d u ce O p e r a t o r T r e e : E xt r a ct Li m i t Fi l e O u t p u t O p e r a t o r co m p r e sse d : f a l se Gl o b a l T a b l e Id : 0 ta b l e : in p u t f o r m a t : o r g . a p a ch e . h a d o o p . m a p r e d . T e xt I n p u t F o r m a t out put f or m at : o r g . a p a ch e . h a d o o p . h i ve . q l . i o . H i ve I g n o r e K e yT e xt O u t p u t F o r m a t St a g e : St a g e - 0 F e t ch O p e r a t o r lim it : 1 0 k T a b l e S ca n a l i a s: k Fi l t e r O p e r a t o r p r e d i ca t e : e xp r : ( fr e q >= 1 ) t yp e : bool ean R e d u ce O u t p u t O p e r a t o r ke y e xp r e ssi o n s: e xp r : w o r d t yp e : st r i n g so r t o r d e r : + Ma p - r e d u ce p a r t i t i o n co l u m n s: e xp r : w o r d t yp e : st r i n g ta g : 1 va l u e e xp r e ssi o n s: e xp r : fr e q t yp e : in t H i v e: E xa m p l e ¨ 数据文件 1 R od 1 8 st u d y - ga m e - d r i v er s t d _a d d r : Bei j i n g - w or k _a d d r : s h a n g h a i 2 T om 2 1 s t u d y - ga m e - d r i v er s t d _a d d r : Bei j i n g - w or k _a d d r : Bei j i n g 3 J er r y 3 3 s t u d y - ga m e - f oot b a l l s t d _a d d r : Bei j i n g - w or k _a d d r : Sh en z h en 4 Bob 2 3 s t u d y - ga m e - mu s i c s t d _a d d r : Bei j i n g - w or k _a d d r : N a n j i n g ¨ 创建 Hi v e 表 ¤ h i v e> C RE A T E T A BL E p er s on ( i d I N T , n a m e ST RI N G , a g e I N T , f a v A RRA Y < ST RI N G > , addr M A P< ST RI N G , ST RI N G > ) C O M M E N T ' T h i s i s t h e p er s on t a b l e' RO W F O RM A T D E L I M I T E D F I E L D S T E RM I N A T E D BY ' \\ t’ C O L L E C T I O N I T E M S T E RM I N A T E D BY ' - ’ M A P K E Y S T E RM I N A T E D BY ' : ' ST O RE D A S T E X T F I L E ; ¨ 导入数据 ¤ h i v e> L O A D DA T A LO C A L IN P A TH p er s on . t xt O V E R WRI T E I N T O T A BL E p er s on ; 64 表的分区 ¨ 可以把数据依照单个或多个列进行分区，通常按照时间、地域进行分区。为了 达到性能表现的一致性，对不同列的划分应该让数据尽可能均匀分布。 分区应 当在建表时设置。 ¤ h i v e> C RE A T E T A BL E p er s on ( i d I N T , n a m e ST RI N G , a g e I N T , f a v A RRA Y < ST RI N G > , addr M A P< ST RI N G , ST RI N G > ) C O M M E N T ' T h i s i s t h e p er s on t a b l e' P A RT I T I O N E D BY ( d t ST RI N G ) RO W F O RM A T D E L I M I T E D F I E L D S T E RM I N A T E D BY ' \\ t' C O L L E C T I O N I T E M S T E RM I N A T E D BY ' - ' M A P K E Y S T E RM I N A T E D BY ‘ : ' ST O RE D A S T E X T F I L E ; ¤ h i v e> L O A D DA T A LO C A L IN P A TH p er s on . t xt O V E R WRI T E I N T O T A BL E p er s on p a r t i t i on ( d t = ' 2 0 1 8 0 3 1 5 ' ) ; ¤ h i v e> SE L E C T addr [' w or k _a d d r ' ] f r om p er s on WH E RE d t = ' 2 0 1 8 0 3 1 5 ' ; 65 表的分区 ¨ 分区表实际上就是对应一个 H D F S 文件系统上的独立的文件夹，该文件夹下是 该分区所 有的数据文件。 Hi v e 中的分区就是分目录，把一个大的数据集根据 业务需要分割成小的数据 集。在查询时通过 WH E RE 子句中的表达式选择查询 所需要的指定的分区，这样的查询效率会提高很多。 ¤ h i v e> A L T E R T A BL E p er s on a d d p a r t i t i on ( d t = ' 2 0 1 8 0 3 1 6 ' ) ; // 增加分区 ¤ h i v e> A L T E R T A BL E p er s on d r op p a r t i t i on ( d t = ' 2 0 1 8 0 3 1 6 ' ) ; // 删除分区 ¤ h i v e> d es c r i b e f or m a t t ed p er s on ; // 查看分区表结构 ¤ h i v e> s h o w p a r t i t i on s p er s on ; // 查看多少个分区 p 二级分区 p h i v e> c r ea t e t a b l e d ep t _p a r t i t i on 2 ( d ep t n o int , dn am e s t r i n g , l oc s t r i n g ) p a r t i t i on ed b y ( d a y s t r i n g , h ou r s t r i n g ) r o w f or m a t d el i m i t ed f i el d s t er m i n a t ed b y ' \\ t' ; H i v e> s el ec t * f r om d ep t _p a r t i t i on 2 w h er e d a y= ' 2 0 2 2 0 2 2 5 ' a n d h ou r = ' 1 2 ' ; 66 表的分区 ¨ 关系型数据库中，对分区表 I n s er t 数据时候，数据库自动会根据分区字段的值， 将数据 插入到相应的分区中， H i v e 中也提供了类似的机制，即动态分区 ( D yn a m i c P a r t i t i on ) ， 只不过， 使用 H i v e 的动态分区，需要进行相应的配置。 ¤ 设置为非严格模式（动态分区的模式，默认 st ri c t ， 表示必须指定至少一个分区为 静态分区， n on s t r i c t 模式表示允许所有的分区字段都可以使用动态分区。） ¤ s et h i v e . e x ec . d yn a m i c . p a r t i t i on = t r u e; ¤ s et h i v e . e x ec . d yn a m i c . p a r t i t i on . m od e = n on s t r i c t ; ¤ 例如：：将 d ep t 表中的数据按照地区（ l oc 字段），插入到目标表 d ep t _p a r t i t i on 的相应 分区中。 ¤ h i v e> c r ea t e t a b l e d ep t _p a r 4 ( i d i n t , n a m e s t r i n g ) p a r t i t i on ed b y ( l oc i n t ) r o w f or m a t d el i m i t ed f i el d s t er m i n a t ed b y ' \\ t' ; p 设置动态分区 p h i v e> i n s er t i n t o t a b l e d ep t _p a r 4 p a r t i t i on ( l oc ) s el ec t d ep t n o , dn am e , l oc f r om d ep t ; p 注：查询语句的最后字段默认为分区字段。 67 表的分桶 ¨ 分桶是相对于分区进行更细粒度的划分。在分区数量过于庞大以至于可能导致 文件系统崩溃时，就需要使用分桶来解决问题。 ¨ 分桶将整个数据内容按照某列属性值的 ha s h 值进行区分。 分桶同样应当在建表 时就建立。 ¤ h i v e> s et h i v e . s t r i c t . c h ec k s . b u c k et i n g = f a l s e; ¤ h i v e> C RE A T E T A BL E p er s on ( i d I N T , n a m e ST RI N G , a g e I N T , f a v A RRA Y < ST RI N G > , addr M A P< ST RI N G , ST RI N G > ) P A RT I T I O N E D BY ( d s ST RI N G ) C L U ST E RE D BY ( i d ) i n t o 3 b u c k et s RO W F O RM A T D E L I M I T E D F I E L D S T E RM I N A T E D BY ' \\ t' C O L L E C T I O N I T E M S T E RM I N A T E D BY ' - ' M A P K E Y S T E RM I N A T E D BY ' : ' ST O RE D A S T E X T F I L E ; 68 表的分桶 ¨ 导入数据 ¤ h i v e> L O A D DA T A LO C A L IN P A TH p er s on . t xt O V E R WRI T E I N T O T A BL E p er s on p a r t i t i on ( d t = ' 2 0 1 8 0 3 1 5 ' ) ; ¨ 查询某个桶里的数据 ¤ h i v e> SE L E C T * f r om p er s on T A BL E SA M PL E ( B U C K E T 1 O U T OF 3); 69 内部表和外部表 ¨ 内部表：在创建的时候会把数据移动到数据仓库所指向的位置；在 删除的时候会将元数据和数据一起删除。如果仅仅是 Hi v e 内部使用， 可以使用内部表。 ¤ h i v e > C RE A T E T A BL E m a n a g ed _t a b l e ( d u m m y ST RI N G ) ; ¤ h i v e > L O A D D A T A I N P A T H ' /u s er /t om / d a t a . t xt ' I N T O t a b l e m a n a g ed _t a b l e ; ¨ 根据上面的代码 ， Hi v e 会把文件 data . t xt 文件存储在 m a n a g ed _t a b l e 表的 w a r eh ou s e 目录下 ， 即 hd f s : //u s er /h i v e/w a r eh ou s e/ m a n a g ed _t a b l e 目录 。 如果我们用 d r op 命令把表删除 ， 将会把表以及表里面的数据和表的 元数据都一起删除 。 ¤ h i v e > D RO P T A BL E m a n a g ed _t a b l e ; 70 内部表和外部表 ¨ 外部表：仅仅记录数据所在的位置；在删除的时候仅仅删除元数据， 真正的数据不会删除。 ¤ 创建空表（通过 e xt er n a l 关键词表明创建的表是外部表），然后导入数据； ¤ 创建表的时候指定数据文件的位置，用 e xt er n a l 关键词创建外部表，使用 l oc a t i on 关键词指定数据文件的位置；利用 E X T E RN A L 关键字创建外部表， Hi v e 不会去管理表数据，所以它不会把数据移到 / u s er /h i v e/w a r eh ou s e 目录 下。甚至在执行创建语句的时候，它不会去检查建表语句中指定的外部数 据路径是否存在。可以在表创建之后，再创建数据。 ¤ 删除外部表的时候， H i v e 只有删除表的元数据，而不会删除表数据。 71 外部表 ¤ h i v e> C RE A T E e xt er n a l T A BL E p er s on ( i d I N T , n a m e ST RI N G , a g e I N T , f a v A RRA Y < ST RI N G > , addr M A P< ST RI N G , ST RI N G > ) C O M M E N T ' T h i s i s t h e p er s on t a b l e' RO W F O RM A T D E L I M I T E D F I E L D S T E RM I N A T E D BY ' \\ t' C O L L E C T I O N I T E M S T E RM I N A T E D BY ' - ' M A P K E Y S T E RM I N A T E D BY ' : ' LO C A T I O N ' hd f s : //l oc a l h os t : 9 0 0 0 /r oot / ' ST O RE D A S T E X T F I L E ; ¤ h i v e> df s - l s /u s er /h i v e/w a r eh ou s e/ ¤ h i v e> df s - l s /u s er /h i v e/w a r eh ou s e/p er s on 72 自定义函数 ¨ U s er D ef i n ed F u n c t i on (U D F ) ¤ UDF ：作用于单条数据，并且输出一个数据行，如字符串函数、日期 函数。 ¤ UD AF ：可接受多个数据输入，同时输出一个数据行，如 CO UN T 、 MI N 、 MA X 等聚集函数。 ¤ UDT F ：作用于单个数据行，同时产生多个输出数据行。 73 自定义函数 ¨ 编写 Ja v a 代码 ¤ p u b l i c c l a s s M a xi m u m e xt en d s U D A F { } ¨ 导出 Ja r 包，并将 Ja r 包添加到 Hi v e 中 ¤ h i v e> a d d j a r M a xi m u m . j a r ; ¨ 用 Ja r 包生成函数 ¤ h i v e> c r ea t e f u n c t i on m a xi m u m t es t as ‘ c om . f i r s t h i g h . u d a f . M a xi m u m ’; ¨ 运行函数并检查结果 ¤ h i v e> s el ec t m a xi m u m t es t ( p r i c e) f r om r ec or d _d i m en s i on ; 74 SQ L 和 H i v eQ L 比较 75 特性 SQ L Hiv eQ L 更新 U PD A T E , I N SE RT , D E L E T E i n s er t O V E R WRI T E \\ I N T O T A BL E 事务 支持 有限支持 模式 写模式 读模式 索引 支持 支持 延迟 亚秒级 分钟级 数据类型 整数、浮点数、定点数、 文本和二机制串、时间 布尔型、整数、浮点数、文本和二进制 串、时间戳、数组、映射、结构 函数 数百个内置函数 数百个内置函数 多表插入 不支持 支持 子查询 完全支持 只能在 F RO M 、 WH E RE 或 HA VI N G 子句中 视图 可更新 只读 可扩展性 低 高 Hi v e 优化 ¨ 数据倾斜问题 ¤ Ke y 分布不均匀 n 随机值，打散 ke y ¤ 业务数据本身的原因 ¤ 建表考虑不周 ¤ SQ L 本身就有数据倾斜 n 选用 j oi n k e y 分布最均匀的表作为驱动表 n 大小表 j oi n 的时候，让维度较小的表先进内存 n 大表 j oi n 的时候，把空值的 ke y 变成一个字符串加上一个随机数，把倾斜的数 据分到不同的 r ed u c e 上 n c ou n t d i s t i n c t 大量相同特殊值。 76 Hi v e 优化 ¨ M a p R ed u c e 优化 ¤ 尽量避免大量的 j ob ¨ 配置优化 ¤ 列裁剪：忽略不需要的列 ¤ 分区裁剪：减少不必要的分区 ¤ Hi v e 参数调节 ：（ 1 ） hiv e .m a p .a g g r = t r u e ；（ 2 ） h i v e . g r ou p b y . s k e w i n d a t a = t r u e 。 ¨ 程序优化 ¤ J oi n 操作：将数目少的表或者子查询放在 j oi n 操作符的左边（小表放前原则）。 ¤ G RO U P BY 操作 ：（ 1 ） Map 端部分聚合；（ 2 ）在有数据倾斜时进行负载均衡。 77 Hi v e 总结 ¨ Hi v e 提供了一种类似于 SQ L 的查询语言，使得其能够用于用户的 交互查询 ¨ 与传统的数据库类似， Hi v e 提供了多个数据表之间的联合查询， 能够完成高效的多个数据表之间的查询 ¨ 通过底层执行引擎的工作， Hi v e 将 SQ L 语言扩展到很大的查询规 模 78 TH A NK YO U","libVersion":"0.2.4","langs":""}