{"path":"课程/大数据/课件/07 MapReduce Basic Programming (II).pdf","text":"M a p R ed u c e 基础算法 程序设计 ( II) 摘要 p M a p R ed u c e 排序算法 p M a p R ed u c e 二级排序 p M a p R ed u c e 单词同现分析算法 p M a p R ed u c e 文档倒排索引算法 p M a p R ed u c e 专利文献数据分析 2 M a p R ed u c e 排序算法 ¨ D a t a Si z e ¤ 10MB ? 10GB ? 1000GB ? ¨ Sor t A l g or i t h m i n M a p R ed u c e ¤ ma p ( k 1 , * ) - > ( k 1 , * ) // I d en t i t y f u n c t i on ¤ s h u f f l e a n d s or t n ( 1 ) t ot a l - or d er p a r t i t i on i n g n ( 2 ) l oc a l s or t i n g ¤ r ed u c e( k 1 , * ) - > ( k 1 , * ) // I d en t i t y f u n c t i on ¨ A c u s t om i z ed t ot a l - or d er P ar t i t i on e r ¤ r ec a l l t h a t s h u f f l e p h a s e n eed s a P ar t i t i on e r t o p a r t i t i on t h e k e y s p a c e ¨ I n p u t F or m a t , O u t p u t F or m a t ¤ t h a t d ep en d s on y ou r d a t a f or m a t 3 M a p R ed u c e 排序算法 4 I s t h e r e a n y probl em here? M a p R ed u c e 排序算法 ¨ P a r t i t i on er ¤ 两个问题 n (1 ) 如何避免在某些 R ed u c er 上聚集过多的数据而拖慢了整个程序 n (2 ) 当有大量的 ke y 要分配到多个 p a r t i t i on （也就是 R ed u c er ）时，如何高效地找到每个 Ke y 所属的 p a r t i t i on ¤ 对 P a r t i t i on er 的要求 n 划分均匀 n 查找快速 ¤ T h a n k G od J n T h er e e xi s t s a c l a s s , To t a l O r d e r P a r t i t i o n e r in h a d oop l i b s , w h i c h w a s or i g i n a l l y u s ed i n T er a Sor t . 5 M a p R ed u c e 排序算法 ¨ T er a Sor t ¤ I n M a y 2 0 0 8 , r u n n i n g on a 9 1 0 - n od e c l u s t er , H a d oop s or t ed t h e 1 0 b i l l i on r ec or d s ( 1 T B i n s i z e) i n 2 0 9 s ec on d s ( 3 . 4 8 m i n u t es ) t o w i n t h e a n n u a l g en er a l p u r p os e t er a b yt e s or t b en c h m a r k . ¤ T h e c l u s t er s t a t i s t i c s w er e: n 9 1 0 n od es n 4 d u a l c or e X eon s @ 2 . 0 g h z p er a n od e n 4 SA T A d i s k s p er a n od e n 8 G RA M p er a n od e n 1 gi g abi t E t h er n et on ea c h n od e n R ed H a t E n t er p r i s e L i n u x Ser v er R el ea s e 5 . 1 ( k er n el 2 . 6 . 1 8 ) n Su n J a v a J D K 1 . 6 . 0 _0 5 - b13 ¤ I n M a y 2 0 0 9 , i t w a s a n n ou n c ed t h a t a t ea m a t Y a h oo! u s ed H a d oop t o s or t on e t er a b yt e i n 6 2 s ec on d s . ¤ Pa c k a g e or g . a p a c h e . h a d oop . e xa m p l es . t er a s or t 6 M a p R ed u c e 排序算法 ¨ T ot a l O r d er P a r t i t i on er f or T er a Sor t ¤ T ot a l O r d er P a r t i t i on er n 一个提供全序划分的 P ar t i t i on e r n 从 H a d oop v 0 . 1 9 . 0 开始正式发布在库类中 n or g . a p a c h e . h a d oop . m a p r ed u c e . l i b . p a r t i t i on . T ot a l O r d er P a r t i t i on er <K , V > ¤ 为满足两个要求所采用的策略 n 通过采样获取数据的分布 n 构建高效的划分模型 7 M a p R ed u c e 排序算法 ¨ T ot a l O r d er P a r t i t i on er ¤ 获取数据分布作均匀划分 n K e y 的分布未知 n 预读一小部分数据采样 ( s a m p l e) n 对采样数据排序后均分，假设有 N 个 r ed u c er ，则取得 N - 1 个分割点 n u s es a s or t ed l i s t of N - 1 s a m p l ed k e ys t h a t d ef i n e t h e k e y r a n g e f or ea c h r ed u c e . n I n p a r t i c u l a r , a l l k e ys s u c h t h a t sa mp l e [i - 1] < = k e y < s a m p l e [ i ] a r e s en t t o r ed u c e i . T h i s g u a r a n t ees t h a t t h e ou t p u t of r ed u c e i a r e a l l l es s t h a n t h e ou t p u t of r ed u c e i+ 1 . ¤ E xa m p l e n 设 r ed u c e 数目为 3 ，采到 9 条记录： 1, 22, 55, 60, 62, 66, 68, 70, 90 n 取两个分割点 60, 68 ；划分区间为： [*, 6 0 ), [6 0 , 6 8 ), [6 8 , *) 8 M a p R ed u c e 排序算法 ¨ T ot a l O r d er P a r t i t i on er ¤ 高效的划分模型 n 若 K e y 的数据类型是 Bi n a r yC om p a r a b l e 的，即两个对象的可以直 接按字节比较大小（如 T e xt ），则以 ke y 构造 Tr i e T r ee ；否则以二 分查找来确定 ke y 的所属区间 n Tr i e T r ee ，一种高效的适于查找的数据结构 n T h e p a r t i t i on er bu i l ds a t w o l e v el tr ie t h a t q u i c k l y i n d e x es i n t o t h e l i s t of s a m p l e k e ys b a s ed on t h e f i r s t t w o b yt es of t h e k e y . ( r ef : h a d oop d oc s ) n 两级的 Tr i e 可以最多对应大约 256* 256 个 r ed u c er ，通常是足够的 9 A tri e fo r ke ys \" A \", \"t o \", \" te a \" , \" te d \" , \" te n \" , \" i \", \" in \", and \" in n \". M a p R ed u c e 二级排序 ¨ Sec on d a r ySor t ¤ H a d oop 在将 M a p p er 产生的数据输送给 R ed u c er 之前，会自动对它们进 行排序 ¤ 那么，如果我们还希望按值排序，应该怎么做呢？ n 二级排序。通过对 ke y 对象的格式进行小小的修改，二级排序可以在排序阶段 将值的作用也施加进去。 10 M a p R ed u c e 二级排序 ¨ Sec on d a r ySor t ¤ 方法 1 ： R ed u c er 将给定 ke y 的所有值都缓存起来，然后对它们再做一个 R ed u c er 内排序。但是，由于 R ed u c er 需要保存给定 ke y 的所有值，可能 会导致出现内存耗尽的错误。 ¤ 方法 2 ：将值的一部分或整个值加入原始 ke y ，生成一个合成 ke y 。 n 生成组合 ke y 的过程很简单。我们需要先分析一下，在排序时需要把值的哪些 部分考虑在内，然后，把它们加进 ke y 里去。随后，再修改 ke y 类的 c om p a r eT o 方法或是 C om p a r a t or 类，确保排序的时候使用这个组合而成的 ke y 。 11 M a p R ed u c e 二级排序 ¨ 例如对如下 in t pai r 进行排序： ¤ 1 20 ¤ 9 8 ¤ 9 32 ¤ 33 2 ¤ 4 99 ¤ 4 18 ¤ 8 6 ¤ 100 1 ¤ 23 5 ¨ 设计的 ( k e y v a l u e) 对为 ( ( l ef t , ri g h t ) , ri g h t ) 12 M a p R ed u c e 二级排序 ¨ 主要工作： ¤ 1. 自定义 ke y n D ef i n e a p a i r of i n t eg er s t h a t a r e w r i t a b l e . T h e y a r e s er i a l i z ed i n a b yt e c om p a r a b l e f or m a t . n cl a s s In t P a ir i m p l em en t s W r i t a b l eC om p a r a b l e < In t P a ir > ¤ 2. 自定义 P a r t i t i on er 类 n P a r t i t i on b a s ed on t h e f i r s t p a r t of t h e p a i r . n cl a s s F i r s t P a r t i t i on er e xt en d s P a r t i t i on er < In t P a ir , In t W rit a b le > ¤ 3. 自定义 Ke y 的比较类 n A C om p a r a t or t h a t c om p a r es s er i a l i z ed Int P a ir . n c l a s s C om p a r a t or e xt en d s W r i t a b l eC om p a r a t or 13 M a p R ed u c e 二级排序 ¨ 主要工作： ¤ 4. 自定义分组比较类 n C om p a r e on l y t h e f i r s t p a r t of t h e p a i r , s o t h a t r ed u c e i s c a l l ed on c e f or ea c h v a l u e of t h e f i r s t par t. n cl a s s F i r s t G r ou p i n g C om p a r a t or e xt en d s W r i t a b l eC om p a r a t or ¤ 5. 定义 M a p p er 类 n R ea d t w o i n t eg er s f r om ea c h l i n e a n d g en er a t e a k e y , v a l u e p a i r a s ( ( l ef t , r i g h t ) , r i g h t ) . ¤ 6. 定义 R ed u c er 类 n A r ed u c er c l a s s t h a t j u s t em i t s t h e s u m of t h e i n p u t v a l u es . ¨ 实现 ： or g . a p a c h e . h a d oop . e xa m p l es . Sec on d a r ySor t 14 构建单词同现矩阵算法 ¨ W or d C o - oc c u r r en c e M a t r i x ¤ 语料库的单词同现矩阵是一个二维 N × N 矩阵 ¤ N 是语料库的词汇量（即，不同单词的数目） ¤ 矩阵元素 M[ i , j ] 代表单词 W[ i ] 与单词 W [ j ] 在一定范围内同现的次数 （一个语句中，一个段落中，一篇文档中，或文本串中一个宽度为 M 个单词的窗口中，这些都依具体问题而定）  Bu i l d i n g w or d c o - oc c u r r en c e m a t r i c es f r om l a r g e c or p or a ¤ a c om m on t a s k i n t e xt p r oc es s i n g , a n d p r ov i d es t h e s t a r t i n g p oi n t t o m a n y ot h er a l g or i t h m s . 15 构建单词同现矩阵算法 ¨ A W or d C o - oc c u r r en c e M a t r i x E xa m p l e 16 F i g u r e t a k en f r om : Y u t a k a M a t s u o , …, PO L Y PH O N E T : A n A d v a n c ed Soc i a l N et w or k E xt r a c t i on Sys t em f r om t h e W e b , 2 0 0 6 F i g u r e: E xa m p l e of p er s on - to - w or d c o - oc c u r r en c e m a t r i x 构建单词同现矩阵算法 ¨ Bu i l d i n g t h e w or d s c o - oc c u r r en c e m a t r i x ¤ 如果内存足够大，把整个矩阵放在内存中，矩阵元素的计算会非常简 单 ¤ 实际上， we b - sc a l e 的文档的词汇量可能有数十万，甚至数亿 ¤ 同现矩阵的空间开销为 ¤ 简单地在单机上的实现，内存与磁盘之间的换页会使任务的执行十分 缓慢 17 )( 2 nO 构建单词同现矩阵算法 M . R. A l g or i t h m ( “ p a i r s ” a p p r oa c h ) p s eu d o - c od e: 1: cl a s s M a p p er 2: me t h o d Ma p ( d oc i d a , d oc d ) 3: fo r a l l t er m w ∈ d oc d do 4: fo r a l l t er m u ∈ N ei g h b or s ( w ) do 5 : //E m i t c ou n t f or ea c h c o - oc c u r r en c e E m i t ( p a i r ( w , u ) , c ou n t 1 ) 1: cl a s s R ed u c er 2: me t h o d R ed u c e( p a i r p ; c ou n t s [ c 1 , c 2 , …] ) 3: s ← 0 4: fo r a l l c ou n t c 2 c ou n t s [ c 1 , c 2 , …] do 5: s ← s + c //Su m c o - oc c u r r en c e c ou n t s 6 : E m i t ( p a i r p , c ou n t s ) 18 构建单词同现矩阵算法 ¨ A s i m p l e “ p a i r s ” a p p r oa c h e xa m p l e ¤ 语料 w e ar e n ot w h a t w e w an t t o be b u t a t l e as t w e ar e n ot w h a t w e u s e d t o be ¤ 同现定义 N ei g h b or s ( w ) n w or d s t h a t c o - oc c u r w i t h w w i t h i n a 2 - w or d w i n d o w 19 构建单词同现矩阵算法 ¨ A s i m p l e “ P a i r s ” a p p r oa c h e xa m p l e ( c on t . ) ¤ a f t er m a p n ( < w e , a r e> , 1 ) n ( < a r e , n ot > , 1 ) n ( < n ot , w h a t > , 1 ) n (< w e , w a n t> , 1 ) n ( < w a n t , t o> , 1 ) n ( < t o , b e> , 1 ) n (< b u t, a t> , 1 ) n ( < a t , l ea s t > , 1 ) n ( < w e , a r e> , 1 ) n ( < a r e , n ot > , 1 ) n ( < n ot , w h a t > , 1 ) n ( < w e , u s ed > , 1 ) n ( < u s ed , t o> , 1 ) n ( < t o , b e> , 1 ) 20 构建单词同现矩阵算法 ¨ A s i m p l e “ P a i r s ” a p p r oa c h e xa m p l e ( c on t . ) ¤ a f t er s h u f f l e a n d s or t n ( < w e , a r e> , [ 1 , 1 ] ) n ( < a r e , n ot > , [ 1 , 1 ] ) n ( < n ot , w h a t > , [ 1 , 1 ] ) n (< w e , w an t> , [1]) n ( < w a n t , t o> , [ 1 ] ) n ( < t o , b e> , [ 1 , 1 ] ) n (< bu t, at> , [1]) n ( < a t , l ea s t > , [ 1 ] ) n ( < w e , u s ed > , [ 1 ] ) n ( < u s ed , t o> , [ 1 ] ) 21 构建单词同现矩阵算法 ¨ A s i m p l e “ P a i r s ” a p p r oa c h e xa m p l e ( c on t . ) ¤ a f t er r ed u c e n ( < w e , a r e> , 2 ) n ( < a r e , n ot > , 2 ) n ( < n ot , w h a t > , 2 ) n (< w e , w an t> , 1) n ( < w a n t , t o> , 1 ) n ( < t o , b e> , 2 ) n (< bu t, at> , 1) n ( < a t , l ea s t > , 1 ) n ( < w e , u s ed > , 1 ) n ( < u s ed , t o> , 1 ) 22 构建单词同现矩阵算法 ¨ A s i m p l e “ P a i r s ” a p p r oa c h e xa m p l e ( c on t . ) 23 F i g u r e: t h e c o - oc c u r r en c e m a t r i x 构建单词同现矩阵算法 ¨ 算法的扩展 ¤ 同现定义 N ei g h b or s ( w ) 为其他形式时该怎么实现 n 根据同现关系的不同，可能需要实现和定制不同的 F i l eI n p u t F or m a t 和 R ec or d R ea d er ， n 如同现关系为一个英文句子，则需要实现以一个英文句子为单位的 F i l eI n p u t F or m a t 和 R ec or d R ea d er n 如同现关系为一个段落，则需要实现以一个段落为单位的 F i l eI n p u t F or m a t 和 R ec or d R ea d er ¤ 同现关系可扩展为从大量观察数据中进行任意离散关联事件的分析和数据挖掘 ¤ 类似应用问题 n 零售商通过分析大量的交易记录，识别出关联的商品购买行为（如：“啤酒和纸尿裤”的故事） n 从生物医学文献中自动挖掘基因交互作用关系 24 文档倒排索引算法 ¨ 文档倒排算法简介 ¤ I n v er t ed I n d e x( 倒排索引 ) 是目前几乎所有支持全文检索的搜索引擎都要依赖 的一个数据结构。基于索引结构，给出一个词 ( ter m ) ，能取得含有这个 t er m 的文档列表 ( t h e l i s t of doc um ents ) ¤ W e b Sea r c h 中的问题主要分为三部分： n c r a w l i n g ( g a t h er i n g w e b c on t en t ) n i n d e xi n g ( c on s t r u c t i on of t h e i n v er t ed i n d e x) n r et r i ev a l ( r a n k i n g d oc u m en t s g i v en a q u er y) ¤ cr aw l i n g 和 i n d e xi n g 都是离线的， r et r i ev a l 是在线、实时的 25 文档倒排索引算法 ¨ 简单的文档倒排算法 26 基于以上索引的搜索结果： fi sh à d oc 1 , d oc 2 r ed à d oc 2 , d oc 3 r ed f i s h à d oc 2 d oc 1 ： on e f i s h t w o f i s h d oc 2 ： r ed f i s h b l u e f i s h d oc 3 ： on e r ed b i r d 倒排索引： on e: d oc 1 , d oc 3 fi sh : d oc 1 , d oc 2 t w o: d oc 1 r ed : d oc 2 , d oc 3 b l u e: d oc 2 bird: d oc 3 文档倒排索引算法 ¨ 简单的文档倒排算法 27 im p o r t j a va . i o . I O E xce p t i o n ; im p o r t j a va . u t i l . S t r i n g T o ke n i ze r ; im p o r t o r g . a p a ch e . h a d o o p . i o . T e xt ; im p o r t o r g . a p a ch e . h a d o o p . m a p r e d u ce . M a p p e r ; p u b l i c cl a ss In v e r t e d In d e x M a p p e r e xt e n d s Mapper < T e xt , T e xt , T e xt , T e xt > { @ O ve r r i d e pr ot e c t e d v oi d m a p( T e x t k e y , T e x t v a l ue , C ont e x t co n text ) t h r o w s I O E xce p t i o n , I n t e r r u p t e d E xce p t i o n // d e fa u l t R e co r d R e a d e r : L i n e R e co r d R e a d e r ; ke y: l i n e o f f se t ; va l u e : l i n e st r i n g { Fi l e S p l i t fi l e S p l i t = ( Fi l e S p l i t ) co n t e xt . g e t I n p u t S p l i t (); St r i n g fi l e N a m e = fi l e S p l i t.g e tP a th (). get N ame (); T e xt w o r d = n e w T e xt ( ) ; T e xt f i l e N a m e _ l i n e O f f se t = n e w T e xt ( fi l e N a m e +” # ” + ke y . t o S t r i n g ()); S t r i n g T o ke n i ze r it r = n e w S t r i n g T o ke n i ze r ( va l u e . t o S t r i n g ()); fo r ( ; i t r . h a sM o r e T o ke n s (); ) { w o r d . se t ( i t r . n e xt T o ke n ()); co n t e xt . w r i t e (w ord, f i l e N a m e _ l i n e O f f se t ); } } } 改进 ： ma p 输出的 ke y 除了文件名 , 还 给出了该词所在行的偏移值 : 格式： f i l en a m e# of f s et 文档倒排索引算法 ¨ 简单的文档倒排算法 28 im p o r t j a va . i o . I O E xce p t i o n ; im p o r t j a va . u t i l . C o l l e ct i o n s ; im p o r t j a va . u t i l . I t e r a t o r ; im p o r t o r g . a p a ch e . h a d o o p . i o . T e xt ; im p o r t o r g . a p a ch e . h a d o o p . m a p r e d u ce . R e d u ce r ; p u b l i c cl a ss In v e r t e d In d e x R e d u c e r e xt e n d s R e d u ce r < T e xt , T e xt , T e xt , T e xt > { @ O ve r r i d e pr ot e c t e d v oi d r e duc e ( T e x t k e y , It e r a b le <T e x t > v a l ue s , C ont e x t co n text ) t h r o w s I O E xce p t i o n , I n t e r r u p t e d E xce p t i o n { Ite r a to r < T e xt > i t = va l u e s. i t e r a t o r (); St r i n g Bu i l d e r al l = new St r i n g Bu i l d e r (); if ( i t . h a sN e xt ()) al l . append ( i t . n e xt (). to S tr i n g ()); fo r ( ; i t . h a sN e xt (); ) { al l . append (“; \" ); al l . append ( i t . n e xt (). to S tr i n g ()); } co n t e xt . w r i t e ( ke y , n e w T e xt ( al l . t oS t ri ng ())); } // 最终输出键值对示例： ( “f i s h \" , “d o c 1 # 0 ; d o c 1 # 8 ; d o c 2 # 0 ; d o c 2 # 8 \" ) } 文档倒排索引算法 ¨ 简单的文档倒排算法 29 p u b l i c cl a ss I n ve r t e d I n d e xe r { p u b l i c st a t i c vo i d m a i n ( S t r i n g [ ] ar gs ) { t r y { C o n f i g u r a t i o n co n f = n e w C o n f i g u r a t i o n ( ) ; j o b = n e w Jo b ( co n f , \" i n ve r t i n d e x\" ) ; j o b . se t Ja r B yC l a ss ( I n ve r t e d I n d e xe r . cl a ss ); j o b . se t I n p u t F o r m a t C l a ss ( T e xt I n p u t F o r m a t . cl a ss ); j o b . se t M a p p e r C l a ss ( I n ve r t e d I n d e xM a p p e r . cl a ss ); j o b . se t R e d u ce r C l a ss ( I n ve r t e d I n d e xR e d u ce r . cl a ss ); j o b . se t O u t p u t K e yC l a ss ( T e xt . cl a ss ); j o b . se t O u t p u t V a l u e C l a ss ( T e xt . cl a ss ); Fi l eI nput For m at . addI nput P at h (j o b , n e w P a th ( ar gs [0 ])); F i l e O u t p u t F o r m a t . se t O u t p u t P a t h (j o b , n e w P a th ( ar gs [1 ])); S yst e m . e xi t ( jo b . wa it F o r Co m p le t io n (tru e ) ? 0 : 1 ); } ca t ch ( E xce p t i o n e ) { e . p r i n t S t a ckT r a ce (); } } } 文档倒排索引算法 ¨ 输出 30 文档倒排索引算法 ¨ 带词频等属性的文档倒排算法 ¤ 如果考虑单词在每个文档中出现的词频、位置、对应 We b 文档的 U RL 等诸多 属性，则前述简单的倒排算法就不足以有效工作。我们把这些词频、位置 等诸多属性称为有效负载（ P a yl oa d ） 31 注：以下的算法内容引自 Ji mm y L i n ， Dat a - In te n s i v e T e x t P r o c e s s i n g w i th Ma p R e d u c e ， 2010 ， Co l l e g e P a r k , 以及其课件 文档倒排索引算法 ¨ 带词频等属性的文档倒排算法 ¤ 基本的倒排索引结构 n 一个倒排索引由大量的 p os t i n g s l i s t 构成 n 一个 p os t i n g s l i s t 由多个 p os t i n g 构成 ( 按 d oc i d 排序 ) n 一个 p os t i n g s l i s t 与一个 t er m 关联 n 一个 p os t i n g 包含一个 d oc u m en t i d 和一个 p a yl oa d n p a yl oa d 上载有 t er m 在 d oc u m en t 中出现情况相关的信息 ( e . g . t er m f r eq u en c y , p os i t i on s , t er m p r op er t i es ) n 同时还有对应 We b 文档到其 U RL 的映射 d oc _i d à U RL 32 文档倒排索引算法 ¨ 带词频等属性的文档倒排算法 ¤ Ma p 和 R ed u ce 实现伪代码 1: cl a s s M a p p e r 2: pr oc e dur e Ma p ( d oc i d n, d oc d) 3: H ← ne w A s s oc i a t i v eA r r a y 4: fo r a l l t er m t ∈ d oc d do 5: H {t } ← H{ t } + 1 6: fo r a l l t er m t ∈ H do 7 : E m i t ( t er m t , p os t i n g < n , H {t }> ) 1: cl a s s R e d u ce r 2: pr oc e dur e R ed u c e( t er m t , p os t i n g s [ < n 1 , f 1 >, <n 2 , f 2 > …] ) 3: P ← ne w L i s t 4: fo r a l l p os t i n g < a , f > ∈ p os t i n g s [ < n 1 , f 1 >, <n 2 , f 2 > …] do 5 : A p p en d ( P , < a , f > ) 6 : Sor t ( P ) 7 : E m i t ( t er m t ; p os t i n g s P ) 33 文档倒排索引算法 ¨ 带词频等属性的文档倒排算法 34 A s i m p l e e xa m p l e p os t i n g ( d oc i d , tf ) 文档倒排索引算法 ¨ 带词频等属性的文档倒排算法 ¤ Sc a l a b i l i t y b ot t l en ec k n T h e a l g or i t h m a s s u m es t h a t t h er e i s s u f f i c i en t m em or y t o h ol d a l l p os t i n g s a s s oc i a t ed w i t h t h e s a m e t er m . n T h e r ed u c er f i r s t b u f f er s a l l p os t i n g s a n d t h en p er f or m s a n i n - m em or y s or t . n A s c ol l ec t i on s g r o w l a r g er , r ed u c er s w i l l r u n ou t of m em or y . ¤ Sol u t i on n l et t h e M a p R ed u c e r u n t i m e d o t h e s or t i n g n E m i t t h e i n t er m ed i a t e k e y - v a l u e p a i r s l i k e t h i s : ( t u p l e < t er m , d oc i d >, tf f) ( d es i g n t r i c k : v a l u e - to - k e y c on v er s i on ) 35 文档倒排索引算法 ¨ 带词频属性的文档倒排算法 36 d oc 1 ： on e f i s h t w o f i s h d oc 2 ： r ed f i s h b l u e f i s h d oc 3 ： on e r ed b i r d ( fi sh , d oc 1 ) 2 ( on e , d oc 1 ) 1 ( tw o , d oc 1 ) 1 ( fi sh , d oc 2 ) 2 ( blu e , d oc 2 ) 1 ( r ed , d oc 2 ) 1 ( bird , d oc 3 ) 1 ( on e , d oc 3 ) 1 ( r ed , d oc 3 ) 1 on e : ( d oc 1 , 1 ) ( d oc 3 , 1 ) fi sh : ( d oc 1 , 2 ) ( d oc 2 , 2 ) t w o: ( d oc 1 , 1 ) r ed : ( d oc 2 , 1 ) ( d oc 3 , 1 ) b l u e: ( d oc 2 , 1 ) bird: ( d oc 3 , 1 ) Ma p p e r R e d u ce r <( te r m , d o ci d ), P > A r ev i s ed e xa m p l e 文档倒排索引算法 ¨ 可扩展的带词频属性的文档倒排算法 ¤ Ma p p e r 1: cl a s s M a p p er 2 : me t h o d Map( d oc i d n; d oc d) 3 : H ← ne w A s s oc i a t i v eA r r a y 4 : fo r a l l t er m t ∈ d oc d do 5 : H { t } ← H { t } + 1 6 : fo r a l l t er m t ∈ H do 7 : E m i t ( t u p l e< t , n > , tf H{ t} ) 38 文档倒排索引算法 ¨ 可扩展的带词频属性的文档倒排算法 n A c u s t om i z ed p a r t i t i on er n Wh y? n T o en s u r e t h a t a l l t u p l es w i t h t h e s a m e t er m a r e s h u f f l ed t o t h e s a m e r ed u c er ( n ot i c e t h a t t h e n e w k e y i s a < t er m , d oc i d > t u p l e) 39 文档倒排索引算法 ¨ 可扩展的带词频属性的文档倒排算法 n Ho w ? n Cl a s s Ne w P a r t i t i o n e r e xt en d s H a s h P a r t i t i on er <K , V> // or g . a p a c h e . h a d oop . m a p r ed u c e . l i b . p a r t i t i on . H a s h P a r t i t i on er { // ov er r i d e t h e m et h od getP a r titio n ( K ke y , V va l u e , int n u m R ed u c eT a s k s ) { t er m = k e y . t oSt r i n g ( ) . s p l i t ( “ , ” ) [ 0 ] ; //< t er m , d oc i d > = > t er m s u p er . g et P a r t i t i on ( t er m , v a l u e , n u m R ed u c eT a s k s ); } } n Set t h e c u s t om i z ed p a r t i t i on er i n j ob c on f i g u r a t i on Jo b . s e t P a r t i t i o n e r C l a s s ( N e w P a r t i t i on er ) 40 A r ev i s ed e xa m p l e( c on t . ) Cu st o m i z e d Pa r t i t i o n e r 进入 re d u c e 的键值对按照 (t e r m, doc id ) 排序 文档倒排索引算法 ¨ 可扩展的带词频属性的文档倒排算法 ¤ Re d u c e r 1: cl a s s R ed u c er 2: me t h o d Set u p // 初始化 3: t p r ev ← Ø ; 4: P ← ne w P os t i n g s L i s t 5: me t h o d R ed u c e( t u p l e < t , n > , tf [f ]) 6: if t ≠ t p r ev ^ t p r ev ≠ Ø the n 7: E m i t ( t p r ev , P ) 8: P. R es et () 9: P. Ad d (<n, f >) 10: t p r ev ← t 11: me t h o d C l ea n u p 12: E m i t ( t , P ) 42 用于输出最后一次未得 到输出的 < t , P > 文档倒排索引算法 ¨ 可扩展的带词频属性的文档倒排算法 ¤ E xt en s i on s n 单词形态还原 ( e . g . ‘ b ook s ’ - > ‘ b ook ’ , …) n r em ov i n g s t op - w or d s ( c om m on w or d s s u c h a s ‘ t h e’ , ‘ a ’ , ‘ of ’ , et c . ) 43 专利文献数据分析 数据源：美国专利文献数据 ¨ A v a i l a b l e f r om t h e N a t i on a l Bu r ea u of E c on om i c R es ea r c h a t h t t p : //w w w . n b er . or g /p a t en t s / ¨ T h e d a t a s et s w er e or i g i n a l l y c om p i l ed f or t h e p a p er “ T h e N BE R P a t en t C i t a t i on D a t a F i l e: L es s on s , I n s i g h t s a n d M et h od ol og i c a l T ool s . ” ¨ T w o d a t a s et s ： ¤ C i t a t i on d a t a s et “ c i t e7 5 _9 9 . t xt ” ¤ P a t en t d es c r i p t i on d a t a s et “ a p a t 6 3 _9 9 . t xt ” 44 专利文献数据分析 数据源：美国专利文献数据 C i t a t i on d a t a s et “ c i t e7 5 _9 9 . t xt ” “CI T I N G ”, ”CI T E D” 3858241, 956203 3858241, 1324234 3858241, 3398406 3858241, 3557384 3858241, 3634889 3858242, 1515701 3858242, 3319261 3858242, 3668705 3858242, 3707004 ... 45 3858241 引用了 956203, 1324234, 3398406, 3557384, 3634889 46 A p a r t i a l v i e w of t h e p a t en t c i t a t i on d a t a s et a s a g r a p h . E a c h p a t en t i s s h o w n a s a v er t e x ( n od e) , a n d ea c h c i t a t i on i s a d i r ec t ed ed g e (ar r o w ). 专利文献数据分析 数据源：美国专利文献数据 P a t en t d es c r i p t i on d a t a s et “ a p a t 6 3 _9 9 . t xt ” “ P A T E N T ” , ” G Y E A R” , ” G D A T E ” , ” A PPY E A R” , ” C O U N T R Y ” , ” PO ST A T E ” , ” A SSI G N E E ” , ” A SSC O D E ” , ” C L A I M S” , ” N C L A SS” , ” C A T ” , ” SU BC A T ” , ” C M A D E ” , ” C RE C E I V E ” , ” RA T I O C I T ” , ” G E N E RA L ” , ” O RI G I N A L ” , ” F WD A PL A G ” , ” BC K G T L A G ” , ” S E L F C T U B” , ” SE L F C T L B” , ” SE C D U PBD ” , ” SE C D L WBD ” 3 0 7 0 8 0 1 , 1 9 6 3 , 1 0 9 6 , , ” BE ” , ” ” , , 1 , , 2 6 9 , 6 , 6 9 , , 1 , , 0 , , , , , , , 3 0 7 0 8 0 2 , 1 9 6 3 , 1 0 9 6 , , ” U S” , ” T X ” , , 1 , , 2 , 6 , 6 3 , , 0 , , , , , , , , , 3 0 7 0 8 0 3 , 1 9 6 3 , 1 0 9 6 , , ” U S” , ” I L ” , , 1 , , 2 , 6 , 6 3 , , 9 , , 0 . 3 7 0 4 , , , , , , , 3 0 7 0 8 0 4 , 1 9 6 3 , 1 0 9 6 , , ” U S” , ” O H ” , , 1 , , 2 , 6 , 6 3 , , 3 , , 0 . 6 6 6 7 , , , , , , , 3 0 7 0 8 0 5 , 1 9 6 3 , 1 0 9 6 , , ” U S” , ” C A ” , , 1 , , 2 , 6 , 6 3 , , 1 , , 0 , , , , , , , 47 专利文献数据分析 数据源：美国专利文献数据 P a t en t d es c r i p t i on d a t a s et “ a p a t 6 3 _9 9 . t xt ” 48 专利文献数据分析 ¨ 专利被引列表 ( c i t a t i on d a t a s et 倒排 ) ¤ Map pu bl i c s t at i c cl as s Ma p Cl a s s e xt en d s M a p p er < L on g W r i t a b l e , T e xt , T e xt , T e xt > { p u b l i c v oi d m a p ( L on g W r i t a b l e k e y , T e xt v a l u e , C on t e xt c on t e xt ) thr o ws I O E x c ep t i on , I n t er r u p t ed E x c ep t i on // 输入 k e y: 行偏移值； v a l u e: “ c i t i n g 专利号 , c i t ed 专利号 ” 数据对 { St r i n g [ ] c i t a t i on = v a l u e . t oSt r i n g (). s p l i t(“ , ” ); c on t e xt . w r i t e ( n e w T e xt ( c i t a t i on [ 1 ] ) , n e w T e xt ( c i t a t i on [ 0 ] ) ) ; } // 输出 k e y: c i t ed 专利号； v a l u e: c i t i n g 专利号 } 49 专利文献数据分析 ¨ 专利被引列表 ( c i t a t i on d a t a s et 倒排 ) ¤ R ed u c e pu bl i c stati c c l ass R ed u c eC l a s s e xt en d s R ed u c er < T e xt , T e xt , T e xt , T e xt > { p u b l i c v oi d r ed u c e( T e xt k e y , I t er a b l e < T e xt > v a l u es , C on t e xt c on t e xt ) th r o w s I O E x c ep t i on , I n t er r u p t ed E x c ep t i on { St r i n g c s v = “ ” ; f or ( T e xt v a l : v a l u es ) { i f ( c s v . l en g t h () > 0) c s v + = “ , ” ; cs v + = v a l . t oSt r i n g (); } c on t e xt . w r i t e ( k e y , n e w T e xt ( c s v ) ) ; } // 输出 k e y: c i t ed 专利号； v a l u e: “ c i t i n g 专利号 1 , c i t ed 专利号 2 , …” } 50 专利文献数据分析 ¨ 专利被引列表 ( c i t a t i on d a t a s et 倒排 ) ¤ 1 3964859, 4647229 10000 4539112 100000 5031388 1000006 4714284 1000007 4766693 1000011 5033339 1000017 3908629 1000026 4043055 1000033 4190903, 4975983 1000043 4091523 1000044 4082383, 4055371 1000045 4290571 1000046 5918892, 5525001, 5609991 …… 51 专利文献数据分析 ¨ 专利被引次数统计 ¨ Map C l as s pu bl i c stati c c l ass MapC l ass e xt en d s M a p p er < L on g W r i t a b l e , T e xt , T e xt , T e xt > { p r i v a t e Int W r it a b le on e = n e w Int W r it a b le (1); p u b l i c v oi d m a p ( L on g W r i t a b l e k e y , T e xt v a l u e , C on t e xt c on t e xt ) th r o w s I O E x c ep t i on , I n t er r u p t ed E x c ep t i on // 输入 k e y: 行偏移值； v a l u e: “ c i t i n g 专利号 , c i t ed 专利号 ” 数据对 { St r i n g [ ] c i t a t i on = v a l u e . t oSt r i n g (). spl i t(“ , ” ); c on t e xt . w r i t e ( n e w T e xt ( c i t a t i on [ 1 ] ) , on e) ; } // 输出 k e y: c i t ed 专利号； v a l u e: c i t i n g 专利号 } 52 专利文献数据分析 ¨ 专利被引次数统计 ¨ R ed u c e C l a s s pu bl i c s t at i c cl as s R ed u c eC l a s s e xt en d s R ed u c er < T e xt , T e xt , T e xt , T e xt > { p u b l i c v oi d r ed u c e( T e xt k e y , I t er a b l e < T e xt > v a l u es , C on t e xt c on t e xt ) thr o ws I O E x c ep t i on , I n t er r u p t ed E x c ep t i on { in t c ou n t = 0 ; w h i l e ( v a l u es . h a s N e xt ()) { c ou n t + = v a l u es . n e xt ( ) . g et ( ) ; } c on t e xt . w r i t e (k e y , ne w In t W r it a b le ( c ou n t ) ) ; } // 输出 k e y: 被引专利号； v a l u e: 被引次数 } 53 专利文献数据分析 ¨ 专利被引次数统计 ¤ 1 2 10000 1 100000 1 1000006 1 1000007 1 1000011 1 1000017 1 1000026 1 1000033 2 1000043 1 1000044 2 1000045 1 1000046 3 …… 54 专利文献数据分析 ¨ 专利被引次数统计 ¤ 目的：有的专利被引用一次，有的可能上百次，可以进行引用次数分布统计，最后可 画出统计图。 ¤ 基本思想是：扫描刚才产生的被引次数统计数据，忽略每一行中的专利号，仅考虑右 侧的被引次数，看每种被引次数分别有多少次出现 55 专利文献数据分析 ¨ 专利被引次数统计 ¨ Map Cl a s s pu bl i c s t at i c cl as s Ma p Cl a s s e xt en d s M a p p er < T e xt , T e xt , L on g W r i t a b l e , L on g W r i t a b l e > { p r i v a t e f i n a l s t a t i c In t W r it a b le on e = n e w In t W r it a b le (1 ); p r i v a t e In t W r it a b le c i t a t i on C ou n t = ne w In t W r it a b le (); p u b l i c v oi d m a p ( T e xt k e y , T e xt v a l u e , C on t e xt c on t e xt ) thr o ws I O E x c ep t i on , I n t er r u p t ed E x c ep t i on { c i t a t i on C ou n t . s et ( I n t eg er . p a r s eI n t ( v a l u e . t oSt r i n g ())); c on t e xt . w r i t e ( c i t a t i on C ou n t , on e) ; } } 56 被引次数 出现 1 次 专利文献数据分析 ¨ 专利被引次数统计 ¨ R ed u c e C l a s s pu bl i c stati c c l ass R ed u c eC l a s s e xt en d s R ed u c er < Int W r it a b le ,Int W r it a b le ,Int W r it a b le ,Int W r it a b le > { p u b l i c v oi d r ed u c e( Int W r it a b le ke y , I t er a b l e < Int W r it a b le > v a l u es , C on t e xt c on t e xt ) th r o w s I O E x c ep t i on , I n t er r u p t ed E x c ep t i on { int c ou n t = 0 ; w h i l e ( v a l u es . h a s N e xt ( ) ) { c ou n t + = v a l u es . n e xt ( ) . g et ( ) ; } c on t e xt . w r i t e (k e y , n e w Int W r it a b le ( c ou n t ) ) ; } // 输出 k e y: 被引次数； v a l u e: 总出现次数 } 57 专利文献数据分析 ¨ 主类 -- C i t a t i on H i s t og r a m pu bl i c c l ass C i t a t i on H i s t og r a m { p u b l i c s t a t i c v oi d m a i n ( St r i n g [ ] args ) { C on f i g u r a t i on c on f = n e w C on f i g u r a t i on ( ) ; J ob C on f j ob = n e w J ob C on f ( c on f , C i t a t i on H i s t og r a m . c l a s s ); Pa t h i n = n e w Pa t h ( args [0]); P a t h ou t = n e w P a t h ( args [1]); F i l eI n p u t F or m a t . s et I n p u t P a t h s ( j ob , i n ) ; F i l eO u t p u t F or m a t . s et O u t p u t P a t h ( j ob , ou t ) ; j ob . s et J ob N a m e (“ C i t a t i on H i s t og r a m ”) ; j ob . s et M a p p er C l a s s ( MapC l as s . c l as s ); j ob . s et R ed u c er C l a s s ( R ed u c eC l a s s . c l a s s ); j ob . s et I n p u t F or m a t ( K e yV a l u eT e xt I n p u t F or m a t . c l a s s ); j ob . s et O u t p u t F or m a t ( T e xt O u t p u t F or m a t . c l a s s ); j ob . s et O u t p u t K e yC l a s s ( Int W r it a b le .c la s s ); j ob . s et O u t p u t V a l u eC l a s s ( Int W r it a b le .c la s s ); Sys t em . e xi t ( j ob . w a i t F or C om p l et i on ( t r u e) ? 0 : 1 ) ; } } 58 专利文献数据分析 ¨ 专利被引次数统计结果 59 1 921128 2 552246 3 380319 4 278438 5 210814 6 163149 7 127941 8 102155 9 82126 10 66634 ... 411 1 605 1 613 1 631 1 633 1 654 1 658 1 678 1 716 1 779 1 专利文献数据分析 ¨ 年份 / 国家专利数统计 P a t en t d es c r i p t i on d a t a s et “ a p a t 6 3 _9 9 . t xt ” “P A T E N T ”, ” GY E AR ” , ” G D A T E ” , ” A PPY E A R” , ” CO UN T R Y ” , ” PO ST A T E ” , ” A SSI G N E E ” , ” A SSC O D E ” , ” C L A I M S” , ” N C L A SS” , ” C A T ” , ” SU BC A T ” , ” C M A D E ” , ” C RE C E I V E ” , ” RA T I O C I T ” , ” G E N E RA L ” , ” O RI G I N A L ” , ” F WD A PL A G ” , ” BC K G T L A G ” , ” SE L F C T U B” , ” SE L F C T L B” , ” SE C D U PBD ” , ” SE C D L WBD ” 3070801, 1963 ,1 0 9 6 ,, ” BE ”, ””, , 1 , , 2 6 9 , 6 , 6 9 , , 1 , , 0 , , , , , , , 3070802, 1963 ,1 0 9 6 ,, ” US ”, ”T X ”, , 1 , , 2 , 6 , 6 3 , , 0 , , , , , , , , , 3070803, 1963 ,1 0 9 6 ,, ” US ”, ”I L ”, , 1 , , 2 , 6 , 6 3 , , 9 , , 0 . 3 7 0 4 , , , , , , , 3070804, 1963 ,1 0 9 6 ,, ” US ”, ”O H”, , 1 , , 2 , 6 , 6 3 , , 3 , , 0 . 6 6 6 7 , , , , , , , 3070805, 1963 ,1 0 9 6 ,, ” US ”, ”CA ”, , 1 , , 2 , 6 , 6 3 , , 1 , , 0 , , , , , , , …… 主要设计思想是：分析以上的专利描述数据集，根据要统计的列名 ( 年份或国家等 ) ，取出对应列上的年 份 ( c ol _i d x =1 ) 或国家 ( c ol _i d x =4 ) ，然后由 Ma p 发出 ( y ea r ， 1) 或 ( c ou n t r y ， 1) ，再由 R ed u c e 累加。 60 专利文献数据分析 ¨ 年份 / 国家专利数统计 ¨ Map C l as s pu bl i c stati c c l ass MapC l ass e xt en d s M a p p er < T e xt , T e xt , T e xt , L on g W r i t a b l e > { p r i v a t e f i n a l s t a t i c Int W r it a b le on e = n e w Int W r it a b le (1); p r i v a t e int c ol _i d x = 1 ; // 1 : 年份； 4: 国家 p u b l i c v oi d m a p ( T e xt k e y , T e xt v a l u e , C on t e xt c on t e xt ) th r o w s I O E x c ep t i on , I n t er r u p t ed E x c ep t i on { St r i n g [ ] c ol s = v a l u e . Sp l i t (‘ , ’ ); // v a l u e ：读入的一行专利描述数据记录 St r i n g c ol _d a t a = c ol s [ c ol _i d x ] ； c on t e xt . w r i t e ( n e w T e xt ( c ol _d a t a ) , on e) ; } } 61 年份或国家 出现 1 次 专利文献数据分析 ¨ 年份 / 国家专利数统计 ¨ R ed u c e C l a s s pu bl i c stati c c l ass R ed u c eC l a s s e xt en d s R ed u c er < T e xt , Int W r it a b le , T e xt , Int W r it a b le > { p u b l i c v oi d r ed u c e( T e xt k e y , I t er a b l e < Int W r it a b le > v a l u es , C on t e xt c on t e xt ) th r o w s I O E x c ep t i on , I n t er r u p t ed E x c ep t i on { int c ou n t = 0 ; w h i l e ( v a l u es . h a s N e xt ( ) ) { c ou n t + = v a l u es . n e xt ( ) . g et ( ) ; } c on t e xt . w r i t e (k e y , n e w Int W r it a b le ( c ou n t ) ) ; } // 输出 k e y: 年份或国家； v a l u e: 总的专利数 } 62 专利文献数据分析 ¨ 年份专利统计输出 63 “ G Y E A R” 1 1963 45679 1964 47375 1965 62857 ... 1996 109645 1997 111983 1998 147519 1999 153486 专利文献数据分析 ¨ 每年申请美国专利的国家数统计 ¨ 假如我们需要从专利描述数据集中统计每年有多少个国家申请了美国专利，并得出如下的 统计图，该如何实现 Map 和 R ed u c e ？ 64 专利文献数据分析 ¨ 每年申请美国专利的国家数统计 ¨ Sol u t i on 1 1. M ap 中用 < y ea r , c ou n t r y> 作为 ke y 输出， E m i t ( < y ea r , c ou n t r y> , 1 ) ( < 1 9 6 3 , BE > , 1 ) , ( < 1 9 6 3 , U S> , 1 ) , ( < 1 9 6 3 , U S> , 1 ) , … 2. 实现一个定制的 P a r t i t i on er ，保证同一年份的数据划分到同一个 R ed u c e 节点 3 . R ed u c e 中对每一个 ( < y ea r , c ou n t r y> , [ 1 , 1 , 1 , …] ) 输入，忽略后部的出现次数，仅考虑 ke y 部分： < y ea r , c ou n t r y> 问题 1 ：如每碰到一个 < y ea r , c ou n t r y > , 即 em i t ( y ea r , 1 ) 有问题吗？ 答案：有问题。因为可能会有从不同 Ma p 节点发来的同样的 < y ea r , c ou n t r y> , 因此会出现对同一国家的重复 计数 解决办法：在 R ed u c e 中仅计数同一年份下不同的国家个数 问题 2 ： Ma p 结果 ( < y ea r , c ou n t r y> , [ 1 , 1 , 1 , …] ) 数据通信量较大 解决办法：实现一个 C om b i n er 将 [ 1 , 1 , 1 , …] 合并为 1 65 专利文献数据分析 ¨ 每年申请美国专利的国家数统计 ¨ Sol u t i on 2 1. Map 中用一个数据结构保存 < y ea r , c ou n t r y> ，并检查一个新的 < y ea r , c ou n t r y> 是否已经出现，若 未出现则 em i t ( y ea r , c ou n t r y) 并将 < y ea r , c ou n t r y> 加入数据结构；否则跳过。如此在每个 Map 节 点上可保证一个年份下一个国家仅出现一次 2 . R ed u c e 中对每一个 ( y ea r , [ c ou n t r y , c ou n t r y , c ou n t r y…] ) 输入直接计数其中的 c ou n t r y 个数有问题吗？ 答案：有问题。因为可能会有从不同 Map 节点发来的同样的 < y ea r , c ou n t r y> , 因此会出现对同一国 家的重复计数 解决办法：在 R ed u c e 中仅计数同一年份下不同的国家个数 66 专利文献数据分析 ¨ 更多的专利文献数据分析问题 ¤ 如何统计一个国家占全球的专利申请比例？ ¤ 如何统计一个国家的专利引用率？ ¤ …… 67 M a p R ed u c e 算法设计小结 ¨ A f e w d es i g n t r i c k s ( “ D es i g n P a t t er n s ” ) ¤ L oc a l a g g r eg a t i on n u s e c om b i n er ¤ C om p l e x s t r u c t u r es n s u c h a s “ p a i r s ” a n d “ s t r i p es ” ¤ va l u e - to - k e y c on v er s i on 68 TH A NK YO U","libVersion":"0.2.4","langs":""}