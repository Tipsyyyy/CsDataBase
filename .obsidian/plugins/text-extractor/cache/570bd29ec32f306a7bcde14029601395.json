{"path":"课程/大数据/课件/18 Spark Basic Programming (II).pdf","text":"Sp a r k 基础编程 (I I ) 摘要 ¨ 基本 RD D 操作 ¨ 键值对操作 ¨ 数据读取与保存 ¨ 共享变量 摘要 ¨ 基本 RD D 操作 ¨ 键值对操作 ¨ 数据读取与保存 ¨ 共享变量 基本 RD D 操作（ T r a n s f or m a t i on 操作） 函数名 目的 示例 结果 ma p () 将函数应用于 RD D 中的每个元素，将返回值 构成新的 RD D rd d . m a p ( x = > x+ 1 ) {2 , 3 , 4 , 4 } fl a t M a p () 将函数应用于 RD D 中的每个元素，将返回的 迭代器的所有内容构成新的 RD D ，通常用来 切分单词 rd d . fl a t M a p ( x = > x. t o (3 )) {1 , 2 , 3 , 2 , 3 , 3 , 3} f i l t er ( ) 返回一个由通过传给 f i l t er ( ) 的函数的元素组 成的 RD D r d d . f i l t er ( x = > x! = 1 ) {2 , 3 , 3 } di s t i n ct ( ) 去重 rd d . d i st i n c t () {1 , 2 , 3 } s a m p l e( w i t h R ep l a c em en t , f r a c t i on , [ s eed ] ) 对 RD D 采样，以及是否替换 rd d . sa m p l e (f a l s e , 0 . 5 ) 非确定的 4 rd d : {1,2,3,3} 基本 RD D 操作（ T r a n s f or m a t i on 操作） 函数名 目的 示例 结果 u n i on ( ) 生成一个包含两个 RD D 中所有元素的 RD D r d d . u n i on ( ot h er ) {1 , 2 , 3 , 3 , 4 , 5 } i n t er s ec t i on ( ) 求两个 RD D 共同的元素的 RD D r d d . i n t er s ec t i on ( ot h er ) {3 } su b t r a c t ( ) 移除一个 RD D 中的内容（例如移除训练数据） rd d . su b t r a c t ( ot h er ) {1 , 2 } c a r t es i a n ( ) 与另一个 RD D 的笛卡尔积 r d d . c a r t es i a n ( ot h er ) { { 1 , 3 } , { 1 , 4 } , { 1 , 5 } , …{ 3 ,5 } } 5 rd d : {1,2,3} 和 other : {3,4,5} 基本 RD D 操作（ A c t i on 操作） 函数名 目的 示例 结果 c ol l ec t ( ) 返回 RD D 中的所有元素 r d d . c ol l ec t () {1 , 2 , 3 , 3 } c ou n t ( ) RD D 中的元素个数 r d d . c ou n t () 4 c ou n t ByV a l u e () 各元素在 RD D 中出现的次数 r d d . c ou n t ByV a l u e () {(1 , 1 ), (2 , 1 ), (3 ,2 ) } t a k e( num ) 从 RD D 中返回前 num 个元素 rd d . t a k e (2 ) {1 , 2 } t op ( num ) 从 RD D 中返回最 ” 前面 ” 的 num 个元素（默认 降序） r d d . t op (2 ) {3 , 3 } t a k eO r d er ( num ) ( or d er i n g ) 从 RD D 中按照提供的顺序返回最前面的 num 个元素 r d d . t a k eO r d er ed (2 )( m yO r d er i n g ) {3 , 3 } 6 rd d : {1,2,3,3} 基本 RD D 操作（ A c t i on 操作） 函数名 目的 示例 结果 r ed u c e( fu n c ) 并行整合 RD D 中的所有数据（例如 su m ） r d d . r ed u c e (( x, y ) => x+ y ) 9 f ol d ( z er o) ( fu n c ) 和 r ed u c e 一样，但是需要提供初始值 r d d . f ol d (0 )(( x, y ) => x+ y ) 9 a g g r eg a t e( z er oV a l u e )( s eq O p , c om b O p ) 和 r ed u c e 一样，但是通常返回不同类 型的函数 r d d . a g g r eg a t e ((0 , 0 ))(( x, y ) = > ( x. _1 + y , x. _2 + 1 ) , ( x, y ) = > ( x. _1 + y . _1 , x. _ 2 + y . _2 ) ) (9 , 4 ) f or ea c h ( fu n c ) 对 RD D 中的每个元素使用给定的函数 r d d . f or ea c h ( fu n c ) 无 7 rd d : {1,2,3,3} 摘要 ¨ 基本 RD D 操作 ¨ 键值对操作 ¨ 数据读取与保存 ¨ 共享变量 键值对操作 ¨ 键值对 RD D （ P a i r RD D ）通常用来进行聚合计算 ¨ 键值对 RD D 的操作接口 ¨ 键值对 RD D 分区 9 创建 Pa i r RD D ¨ 调用 ma p ( ) 函数实现 ¤ Sc a l a va l pai r s = l i n es . m a p ( x= > ( x. s p l i t ( “ “ ) ( 0 ) , x) ) ¤ Ja v a P a i r F u n c t i on < St r i n g , St r i n g , St r i n g > k e yD a t a = ne w P a i r F u n c t i on < St r i n g , St r i n g , St r i n g > ( ) { p u b l i c T u p l e2 < St r i n g , St r i n g > c a l l ( St r i n g x) { r et u r n n e w T u p l e2 ( x. s p l i t ( “ “ ) [ 0 ] , x) ; } } J a v a P a i r RD D < St r i n g , St r i n g > p a i r s = l i n es . m a p T oP a i r ( k e yD a t a ) 10 P a i r RD D 的 T r a n s f or m a t i on 操作 函数名 目的 示例 结果 r ed u c eByK e y ( fu n c ) 合并具有相同键的值 r d d . r ed u c eByK e y (( x, y ) => x + y) {( 1 , 2 ) , ( 3 , 1 0 ) } g r ou p ByK e y () 对具有相同键的值进行分组 r d d . g r ou p ByK e y () {( 1 , [ 2 ] ) , ( 3 , [ 4 , 6 ] ) } c om b i n eByK e y ( c r ea t eC om b i n er , m er g eV a l u e , m er g eC om b i n er s , p a r t i t i on er ) 使用不同的返回类型合并具有相同键的值 m a p V a l u es ( fu n c ) 对 pai r RD D 中的每个值应用一个函数而不改变键 r d d . m a p V a l u es ( x= > x+ 1 ) {( 1 , 3 ) , ( 3 , 5 ) , ( 3 , 7 ) } f l a t M a p V a l u es ( fu n c ) 对 pai r RD D 中的每个值应用一个返回迭代器的函数，然 后对返回的每个元素都生成一个对应原键的键值对记 录 r d d . f l a t M a p V a l u es ( x= > ( x t o 5 ) ) {( 1 , 2 ) , ( 1 , 3 ) , ( 1 , 4 ) , ( 1 , 5 ) ,( 3 ,4 ) ,( 3 ,5 ) } k e ys ( ) 返回一个仅包含键的 RD D r d d . k e ys () {1 , 3 , 3 } v a l u es ( ) 返回一个仅包含值的 RD D r d d . v a l u es () {2 , 4 , 6 } s or t ByK e y () 返回一个根据键排序的 RD D r d d . s or t ByK e y () {( 1 , 2 ) , ( 3 , 4 ) , ( 3 , 6 ) } 11 Pai r R D D : {( 1,2) ,( 3,4) ,( 3,6) } P a i r RD D 的 T r a n s f or m a t i on 操作 函数名 目的 示例 结果 s u b t r a c t ByK e y ( fu n c ) 删掉 rdd 中键与 ot h er 中的键相同的元 素 r d d . s u b t r a c t ByK e y ( ot h er ) {( 1 , 2 ) } j oi n 对两个 rdd 进行内连接 r d d . j oi n ( ot h er ) {( 3 , ( 4 , 9 ) ) , ( 3 , ( 6 , 9 ) } r i g h t O u t er J oi n 对两个 rdd 进行连接操作，确保右边 rdd 的键必须存在（右外连接） r d d . r i g h t O u t er J oi n ( ot h er ) { ( 3 , ( Som e( 4 ) , 9 ) ) , ( 3 , ( Som e( 6 ) , 9))} l ef t O u t er J oi n 对两个 rdd 进行连接操作，确保左边 rdd 的键必须存在（左外连接） r d d . l ef t O u t er J oi n ( ot h er ) { ( 1 , ( 2 , n on e) ) , ( 3 , ( 4 , Som e( 9 ) ) ) , ( 3 , ( 6 , Som e( 9 ) ) ) } c og r ou p 将两个 rdd 中拥有相同键的数据分组 到一起 r d d . c og r ou p ( ot h er ) {( 1 , ( [ 2 ] , [ ] ) ) , ( 3 , ( [ 4 , 6 ] , [ 9 ] ) ) } 12 rd d = {( 1,2) ,( 3,4) ,( 3,6) } other = {( 3,9) } Pa i r RD D ¨ Pa i r RD D 也还是 RD D （元素为 Ja v a 或 Sc a l a 中的 T u p l e2 对象或者 Pyt h on 中的元组）。 Pa i r RD D 支持 RD D 所支持的函数。例如： ¤ Sc a l a r es u l t = p a r i s . f i l t er { c a s e ( k e y , v a l u e) = > v a l u e . l en g t h <2 0 } ¤ Ja v a F u n c t i on < T u p l e2 < St r i n g , St r i n g > , Bool ea n > l on g W or d F i l t er = n e w F u n c t i on < T u p l e2 < St r i n g , St r i n g > , Bool ea n > ( ) { p u b l i c Bool ea n c a l l ( T u p l e2 < St r i n g , St r i n g > k e yV a l u e ){ r et u r n ( k e yV a l u e . _2 ( ) . l en g t h ( ) < 2 0 ) ; } } J a v a P a i r RD D < St r i n g , St r i n g > r es u l t = p a i r s . f i l t er ( l on g W or d F i l t er ); 13 ke y va l u e h ol d en L i k es c of f ee pan da L i k es l on g st ri n g s a n d c of f ee ke y va l u e h ol d en L i k es c of f ee fi l te r 聚合操作 ¤ r ed u c eByK e y ( ) v s . r ed u c e( ) n 两者都能接收一个函数，并使用该函 数对值进行合并 n r ed u c eByK e y () 会为数据集中的每个键进 行并行的归约操作，每个归约操作会 将键相同的值合并起来。因为数据集 中可能有大量的键，所以 r ed u c eByK e y () 没有被实现为向用户程序返回一个值 的行动操作 ，实际上，它会返回一个 由各键和对应键归约出来的结果值组 成的新的 RD D 14 ¨ r ed u c eByK e y () rd d .ma p V a l u e s ( x = > ( x, 1 ) ) . r e d u ce B yK e y ( ( x, y) = > x. _ 1 + y . _ 1 , x. _ 2 + y . _ 2 ) ) 求每个键平均值的数据流 聚合操作 ¨ 单词计数 ¨ 或者 va r r es u l t = input.f latMap ( x= > x. s p l i t ( “ “ ) ) . c ou n t ByV a l u e () 15 聚合操作 16 ¨ c om b i n eByK e y () ：基于键进行聚合的函数 如果是新元素，创建对应累加器的初始值 如果之前遇到过，将该键的累加器对应的 当前值与这个新的值进行合并 如果多个分区都有对应于同一个键的累加 器，则需要将各个分区的结果进行合并 ¨ 求每个键对应的平均值 分组 ¨ g r ou p ByK e y () ：对数据进行分组 ¤ RD D : [ K , V ] à [K , I t er a b l e [V ]] n r d d . r ed u c eByK e y ( fu n c ) 与 r d d . g r ou p ByK e y (). m a p V a l u es ( v a l u e = > v a l u e . r ed u c e ( fu n c )) 等价， 但前者更为高效。 ¨ c og r ou p ( ) ：对多个共享同一个键的 RD D 进行分组 ¤ RD D : [ K , V ] & [ K , W] à [(K , ( I t er a b l e [V ], I t er a b l e [ W] ) ) ] ¤ 不仅可以用于实现连接操作，还可以用来求键的交集。除此之外，还 能同时应用于三个及以上的 RD D 。 17 连接 ¨ 将有键的数据与另一组有键的数据一起使用。 ¨ 连接方式：右外连接，左外连接，交叉连接，内连接。 ¤ 内连接 ( j oi n ) ：只有两个 p a i r RD D 都存在的键才输出。 ¤ 左外连接 ( l ef t O u t er J oi n ) ：源 RD D 的每个键都有对应的记录。每个键相应 的值是由一个源 RD D 中的值与一个包含第二个 RD D 的值的 O p t i on 对象组 成的二元组。 ¤ 右外连接 ( r i g h t O u t er J oi n ) ：预期结果中的键必须出现在第二个 RD D 中， 二元组中可缺失的部分则来自于源 RD D 而非第二个 RD D 。 18 排序 ¨ s or t ByK e y () ：默认升序 ¨ 自定义排序 ¤ Sc a l a va l i n p u t : RD D [ ( In t , V en u e) ] = … im p lic it va l s or t I n t eg er s BySt r i n g = n e w O r d er i n g [ In t ]{ ov er r i d e d ef c om p a r e( a : I n t , b : I n t ) = a . t oSt r i n g . c om p a r e ( b . t oSt r i n g )} ¤ Ja v a cl as s I n t eg er C om p a r a t or i m p l em en t s C om p a r a t or < I n t eg er > { pu bl i c in t c om p a r e( I n t eg er a , I n t eg er b ) { r et u r n St r i n g . v a l u eO f (a ). c om p a r eT o ( St r i n g . v a l u eO f (b )); } } 19 Pa i r RD D 的 A c t i on 操作 RD D = {(1 ,2 ),(3 ,4 ),(3 ,6 )} 20 函数名 目的 示例 结果 c ou n t ByK e y () 对每个键对应的元素进行 计数 r d d . c ou n t ByK e y () {(1 , 1 ), (3 , 2 )} c ol l ec t A s M a p () 将结果以映射表的形式返 回，以便查询 r d d . c ol l ec t A s M a p () Ma p {(1 , 2 ), (3 , 6 )} l ook u p ( k e y) 返回给定键对应的所有值 r d d . l ook u p (3 ) [4 , 6 ] c ol l ec t A s M a p () 作用于 K - V 类型的 RD D 上，作用与 c ol l ec t 不同的是 c ol l ec t A s M a p 函数 不包含重复的 ke y ， 对于重复的 ke y ，后面的元素覆盖前面的元素。 数据分区 ¨ 合理分布数据能减少网络通信，从而大大提高性能。 ¨ Sp a r k 可以选择自己的 RD D 分区分布来降低通信，但只有当一个数 据集重复多次使用键值操作才起作用。 ¨ Sp a r k 的分区操作作用于 k e y/v a l u e 型 RD D 上，它会让系统根据键值 函数来分组元素。 ¤ 比如限定一组键值出现在指定节点上 21 数据分区 ¨ 用户信息的大表 ( U s er I D , U s er I n f o ) ¨ 过去五分钟的网站链接点击信息 ( U s er I D , Li n k I n f o ) ¨ 计算多少用户访问了不在订阅列表的链接：用 Sp a r k 的 j oi n ( ) 来分组 U s er I n f o 和 Li n k I n f o ，基于每个 U s er I D 。 22 数据分区 ¨ 每次调用 p r oc es s N e w L og s () 就会调用 j oi n ( ) ，在不知道该键值数据分区的情 况下。默认情况下，会先哈希两个数 据集的所有键，然后通过网络发送相 同哈希值的元素到同一台机器，然后 再用 j oi n 连接相同机器上相同键值的 元素 ¨ u s er D a t a 表比五分钟日志事件文件大 得多，这会浪费大量的计算：在每次 调用时， u s er D a t a 表都会被散列并通 过网络传输，即使它并没有改变 。 23 数据分区 ¨ 调用 p a r t i t i on By () 建立用户数据的时候， Sp a r k 知道这是哈希分区，调用 j oi n ( ) 方法时候利用这个优势。特别是，当 我们调用 u s er D a t a . j oi n ( ev en t s ) ， Sp a r k 将重排事件 RD D ，把每个特定 U s er I D 发 送到包含 u s er D a t a 的散列分区，其结 果是，减少了许多网络通信，让程序 更快地运行。 24 对 u s er D a t a 表使用 p a r t i t i on By () ，将其转为哈希分区 数据分区 ¨ p a r t i t i on By () 是一个变换，所以它总是返回一个新的 RD D 。它不改变原来的 RD D 。 RD D 创 建后无法修改。因此保存 p a r t i t i on By () 的结果 u s er D a t a 非常重要的，而不是原来 s eq u en c eF i l e () 。 ¨ 在 RD D 传递给 p a r t i t i on By () 之后如果没有保存 RD D ，将导致 RD D 的后续使用重做数据分区 操作。 如果没有持久保存数据，分区的 RD D 会导致 RD D 完整谱系（ l i n ea g e ）的重新计 算。那会与 p a r t i t i on By () 的优点矛盾，导致重复分区，并且通过网络重混数据 （ sh u fflin g ），相当于没有指定分区的情况。 ¨ Sp a r k 的其它操作也常常自动生成已知划分信息的 RD D ，除了 j oi n ( ) 其他许多操作都会利 用这一信息。例如， s or t ByK e y () 和 g r ou p ByK e y () 会生成范围分区和哈希散列分区的 RD D 。 而另一方面，像 ma p ( ) 的操作会生成新的 RD D 并丢失父分区的信息，因为这个操作理论 上可以修改每个记录。 25 数据分区 26 如果想在 进一步的操作中使用分区，应该在输入第三行加上 p er s i s t ( ) ，并在其 中定义分区。如果没有 p er s i s t ( ) ，随后 RD D 将重新评估分区的整个属性，这将导 致数据对一遍又一遍地作哈希分区操作。 数据分区 ¨ 以下操作会使输出 RD D 设置 好 分区器： c og r ou p (), g r ou p Wi t h (), j oi n (), l ef t O u t er J oi n (), r i g h t O u t er J oi n (), g r ou p ByK e y (), r ed u c eByK e y (), c om b i n eByK e y (), p a r t i t i on By (), s or t (), m a p V a l u es () （如果父 RD D 具有分区器）， f l a t M a p V a l u es () （如果父 RD D 具有分区器），和 f i l t er () （如果父 RD D 具有分区器）。其他所有操 作将产生的结果都没有分区器。 ¨ 对于多 RD D 操作，其分区器被设置的规则取决于父 RD D s 的分区器。 默认情况下 是散列分区器，分区数目与并发级别保持一致。 然而，如果其中一个父 RD D 含 有分区器，结果便会采用这个分区方式；如果多个父 RD D 都含有分区器，结果 将取第一个父分区的分区器。 27 E xa m p l e ： P a g eR a n k ¨ 数据集： ( p a g eI D , lin k L is t ) ¨ 输出： ( p a g eI D , r a n k ) ¨ 算法： ¤ 将每个页面的排序值初始化为 1. 0 ； ¤ 在每次迭代中，对页面 p ，向其每个相邻页面（有直接链接的页面） 发送一个值为 ra n k ( p ) / n u m N ei g h b ou r s (p ) 的贡献值； ¤ 将每个页面的排序值设为 0. 15+0. 85* c on t r i b u t i on s R ec ei v ed ¤ 重复后两步，算法逐渐收敛。通常需要 10 轮迭代。 28 E xa m p l e ： P a g eR a n k 29 为了最大化分区相关优化的潜在作用，应该在无需改变元素的键时尽量使用 m a p V a l u es () 或 f l a t M a p V a l u es () 自定义分区 ¨ H a s h P a r t i t i on er 和 R a n g eP a r t i t i on er ¨ 继承 or g . a p a c h e . s p a r k . P a r t i t i on er ¤ n u m P a r t i t i on s : Int 返回创建出来的分区数 ¤ g et P a r t i t i on ( k e y: A n y) : Int 返回给定键的分区编号 ¤ eq u a l s ( ) : Bool ea n 检查分区器对象是否和其它分区器实例相同。 30 自定义分区 cl as s D om a i n N a m eP a r t i t i on er ( numP a r ts : In t ) e xt en d s P a r t i t i on er { ov er r i d e d ef n u m P a r t i t i on s : In t = numP a r ts ov er r i d e d ef g et P a r t i t i on ( k e y: A n y) : In t = { va l d om a i n = n e w J a v a . n et . U RL ( k e y . t oSt r i n g ). g et H os t () va l c od e = ( d om a i n . h a s h C od e % n u m P a r t i t i on s ) i f ( c od e< 0 ) { c od e + n u m P a r t i t i on s } el s e { c od e } } ov er r i d e d ef eq u a l s ( ot h er : A n y ) : Bool ea n = ot h er m a t c h { c a s e dn p : D om a i n N a m eP a r t i t i on er => d n p . n u m P a r t i t i on s == n u m P a r t i t i on s c a s e _ = > f a l s e } } 31 摘要 ¨ 基本 RD D 操作 ¨ 键值对操作 ¨ 数据读取与保存 ¨ 共享变量 数据源 ¨ 文件格式与文件系统 ¨ Sp a r k SQ L 中的结构化数据源 ¨ 数据库与键值存储 33 文件格式 格式名称 结构化 备注 文本文件 否 普通的文本文件，每行一条记录 J SO N 半结构化 常见的基于文本的格式，半结构化；大多数库都要求每行一条 记录 C SV 是 非常常见的基于文本的格式，通常在电子表格应用中使用 Seq u en c eF i l es 是 一种用于键值对数据的常见 H a d oop 文件格式 Pr ot oc ol b u f f er s 是 一种快速、节约空间的跨语言格式 对象文件 是 用来将 Sp a r k 作业中的数据存储下来以让共享的代码读取。改 变类的时候它会失效，因为它依赖于 Ja v a 序列化。 34 文件格式 ¨ 文本文件：输入的每一行都会成为 RD D 的一个元素；也可以将多个完整的文本 文件一次性读取为一个 Pa i r RD D ，键是文件名，值是文件内容。 va l inp ut = s c . t e xt F i l e ( “ f i l e: ///h om e/s p a r k /RE A D M E . M D ” ) i n p u t . s a v eA s T e xt F i l e ( ou t p u t F i l e ) va l inp ut = s c . w h ol eT e xt F i l es ( “ f i l e: ///h om e/s p a r k / s a l ef i l es ”) ¨ J SO N ：将数据作为文本文件读取，然后使用 J SO N 解析器来对 RD D 的值进行映 射操作。 i m p or t j s on data = inp ut .m a p ( l a m b d a x: j s on . l oa d s ( x) ) ( d a t a . f i l t er ( l a m b d a x: x[ “ l ov es P a n d a s ” ] ) . m a p ( l a m b d a x: j s on . d u m p s ( x) ) . s a v eA s T e xt F i l e ( ou t p u t F i l e )) 35 p yt h on sc al a 文件格式 ¨ C SV ：当作普通文本文件读取，再对数据进行处理。每条记录都没有相关联的 字段名，只能得到对应的序号。常规做法是使用第一行中每列的值作为字段名。 i m p or t J a v a . i o . St r i n g R ea d er I m p or t a u . c om . b yt ec od e . op en c s v . C SV R ea d er … va l inp ut = s c . t e xt F i l e ( inp ut File ) va l r es u l t = inp ut .m a p { l i n e = > va l r ea d er = n e w C SV R ea d er (n e w St r i n g R ea d er ( l i n e) ) ; r ea d er . r ea d N e xt (); } 36 文件格式 ¨ Seq u en c eF i l e ：由没有相对关系结构的键值对文件组成的常用 H a d oop 格式。有 同步标记， Sp a r k 可以用它来定位到文件中的某个点，然后再与记录的边界对 齐。由实现 H a d oop 的 Wr i t a b l e 接口的元素组成。 va l data = s c . s eq u en c eF i l e ( inFile , cl a s s O f [ T e xt ] , cl a s s O f [ Int W r it a b le ] ) . m a p { c a s e( x, y ) = > ( x. t oSt r i n g , y . g et ()} va l data = s c . p a r a l l el i z e ( l i s t ( ( “ P a n d a ” , 3 ) , ( “ K a y” , 6 ) , ( “ Sn a i l ” , 2 ) ) ) d a t a . s a v eA s Seq u en c eF i l e ( ou t p u t F i l e ) 37 文件系统 ¨ 本地“常规”文件系统 ¤ f i l e: ///h om e/ h ol d en / h a p p yp a n d a s . g z ¨ A m a z on S3 ¤ s 3 n : //b u c k et /p a t h - wi t h i n - b u c k et ¨ HDF S ¤ hd f s : // m a s t er : p or t /p a t h 38 Sp a r k SQ L 中的结构化数据 ¨ Hi v e ： Sp a r k SQ L 可以读取 Hi v e 支持的任何表 i m p or t or g . a p a c h e . s p a r k . s q l . h i v e . H i v eC on t e xt va l h i v eC t x = n e w or g . a p a c h e . s p a r k . s q l . h i v e . H i v eC on t e xt ( sc ) va l ro w s = h i v eC t x. s q l ( “ SE L E C T n a m e , a g e F RO M u s er s ” ) va l fi rst R o w = ro w s . f i r s t () pri n tl n ( f i r s t R o w . g et St r i n g (0)) 39 Sp a r k SQ L 中的结构化数据 ¨ J SO N ： Sp a r k SQ L 可以自动推断出 J SO N 数据的结构信息 i m p or t or g . a p a c h e . s p a r k . s q l . h i v e . H i v eC on t e xt va l h i v eC t x = n e w or g . a p a c h e . s p a r k . s q l . h i v e . H i v eC on t e xt ( sc ) va l t w eet s = h i v eC t x. j s on F i l e (“ t w eet s . j s on ”) t w eet s . r eg i s t er T em p T a b l e ( “ t w eet s ” ) va l r es u l t s = h i v eC t x. s q l ( “ SE L E C T u s er . n a m e , t e xt F RO M t w eet s ” ) 40 数据库 ¨ Ja v a 数据库连接： or g . a p a c h e . s p a r k . r d d . J d b c RD D d ef c r ea t eC on n ec t i on () = { C l a s s . f or N a m e (“ c om . m ys q l . j d b c . D r i v er ”) . ne w Ins t a nc e (); D r i v er M a n a g er . g et C on n ec t i on (“ j d b c : m ys q l : //l oc a l h os t / t es t ? u s er = h ol d en ”) ; } d ef e xt r a c t V a l u es (r : R es u l t Set ) = { ( r . g et I n t (1), r . g et St r i n g (2)) } va l data = n e w J d b c RD D ( sc , c r ea t eC on n ec t i on , ” SE L E C T * F RO M p a n d a WH E RE ? <= i d a n d i d <= ? ”, l o w er Bou n d = 1 , u p p er Bou n d = 3 , n u m P a r t i t i on s = 2 , ma p R o w = e xt r a c t V a l u es ) pri n tl n ( d a t a . c ol l ec t (). t oL i s t ) 41 数据库 ¨ Sp a r k 可以通过 H a d oop 输入格式访问 H Ba s e ，这个输入格式会返回 键值对数据，其中键的类型为 or g . a p a c h e . h a d oop . h b a s e . i o . I m m u t a b l eByt es W r i t a b l e ，值的类型为 or g . a p a c h e . h a d oop . h b a s e . c l i en t . R es u l t . 42 摘要 ¨ 基本 RD D 操作 ¨ 键值对操作 ¨ 数据读取与保存 ¨ 共享变量 共享变量 ¨ 在默认情况下，当 Sp a r k 在集群的多个不同节点的多个任务上并 行运行一个函数时，它会把函数中涉及到的每个变量，在每个任 务上都生成一个副本。但是，有时候，需要在多个任务之间共享 变量，或者在任务（ Ta s k ）和任务控制节点（ D r i v er Pr og r a m ）之 间共享变量。为了满足这种需求， Sp a r k 提供了两种类型的变量： 广播变量（ b r oa d c a s t v a r i a b l es ） 和 累加器（ a c c u m u l a t or s ） 。广播 变量用来把变量在所有节点的内存之间进行共享。累加器则支持 在所有不同节点之间进行累加计算（比如计数或者求和）。 44 共享变量 ¨ 广播变量 ¤ 让程序高效地向所有工作节点发送一个较大的只读值，以供一个或多 个 Sp a r k 操作使用。 ¨ 累加器 ¤ 支持在所有不同节点之间进行累加计算（比如计数或者求和） 45 广播变量 ¨ 可以通过调用 Sp a r k C on t e xt . b r oa d c a s t (v ) 来从一个普通变量 v 中创建 一个广播变量。这个广播变量就是对普通变量 v 的一个包装器， 通过调用 va l u e 方法就可以获得这个广播变量的值，例如： sc al a > va l b r oa d c a s t V a r = s c . b r oa d c a s t ( A r r a y( 1 , 2 , 3 ) ) b r oa d c a s t V a r : or g . a p a c h e . s p a r k . b r oa d c a s t . Br oa d c a s t [ A r r a y[ Int ] ] = Br oa d c a s t ( 0 ) sc al a > b r oa d c a s t V a r . v a l u e r es 0 : A r r a y[ Int ] = A r r a y( 1 , 2 , 3 ) 这个广播变量被创建以后，那么在集群中的任何函数中，都应该使用广播变量 b r oa d c a s t V a r 的值，而不 是使用 v 的值，这样就不会把 v 重复分发到这些节点上。此外，一旦广播变量创建后，普通变量 v 的值就不 能再发生修改，从而确保所有节点都获得这个广播变量的相同的值。 46 累加器 ¨ 累加器是仅仅被相关操作累加的变量，通常可以被用来实现计数器 （ c ou n t er ）和求和（ su m ）。 Sp a r k 原生地支持数值型（ n u m er i c ）的 累加器，程序开发人员可以编写对新类型的支持。 ¨ 一个数值型的累加器，可以通过调用 Sp a r k C on t e xt . l on g A c c u m u l a t or () 或者 Sp a r k C on t e xt . d ou b l eA c c u m u l a t or () 来创建。运行在集群中的任务，就可以 使用 add 方法来把数值累加到累加器上，但是，这些任务只能做累 加操作，不能读取累加器的值，只有任务控制节点（ D r i v er Pr og r a m ） 可以使用 va l u e 来读取累加器的值。 47 累加器 ¨ 例如： sc a l a > va l accu m = s c . l on g A c c u m u l a t or ( \" M y A c c u m u l a t or \" ) accu m : or g . a p a c h e . s p a r k . u t i l . L on g A c c u m u l a t or = L on g A c c u m u l a t or ( i d : 0 , n a m e: Som e( M y A c c u m u l a t or ) , v a l u e: 0 ) sc a l a > s c . p a r a l l el i z e ( A r r a y( 1 , 2 , 3 , 4 ) ) . f or ea c h ( x = > accu m .add ( x) ) sc a l a > accu m .v alu e r es 1 : L on g = 1 0 48 TH A NK YO U","libVersion":"0.2.4","langs":""}