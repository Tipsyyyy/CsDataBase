{"path":"课程/金融大数据/课件/09 基于MapReduce的搜索引擎算法.pdf","text":"基于 M a p R ed u c e 的搜索引擎算法 图 ¨ 搜索引擎 ¨ 社交网络 ¨ 路径规划 ¨ …… 2 图问题与 M a p R ed u c e ¨ 一些图问题： ¤ 最短路径 ¤ 最小生成树 ¤ 广度优先搜索 ¤ P a g eR a n k ¨ 关键问题： ¤ 怎么在 M a p R ed u c e 中表示图数据 ¤ 怎么用 M a p R ed u c e 遍历图 3 图表示方法 ¨ G = (V , E ) ¨ 两种常见的表示方法 ¤ 邻接矩阵 ¤ 邻接表 4 邻接矩阵 用一个 n x n 的矩阵 M 来表示图： ¤ n = | V | ¤ M ij = 1 表示一条 i 到 j 的边 5 邻接矩阵 ¨ 优点 : ¤ 便于数学操作 ¤ 遍历一行可得到出度信息，遍历一列可以得到入度信息 ¨ 缺点 : ¤ 对于稀疏矩阵浪费内存 6 邻接表 ¨ 只保存邻接矩阵中不为零的节点 7 1: 2, 4 2: 1, 3, 4 3: 1 4: 1, 3 1 2 3 4 1 0 1 0 1 2 1 0 1 1 3 1 0 0 0 4 1 0 1 0 邻接表 ¨ 优点 : ¤ 表示更加紧凑 ¤ 容易得到出度信息 ¨ 缺点 : ¤ 不方便得到入度信息 8 P a g eR a n k 内容概述 ¨ 什么是 P a g eR a n k ¨ P a g eR a n k 的简化模型 ¨ P a g eR a n k 的随机浏览模型 ¨ P a g eR a n k 的 M a p R ed u c e 实现 9 什么是 P a g eR a n k ¨ Pa g e R a n k ¤ P a g eR a n k 是一种由搜索引擎根据网页之间相互的超链接计算的网 页排名技术。 ¤ L a r r y P a g e a n d Ser g e y Br i n , G oog l e , 1 9 9 7 ¤ P a g eR a n k 是 G oog l e 用于用来标识网页的等级或重要性的一种方法。 其级别从 1 到 10 级， PR 值越高说明该网页越受欢迎（越重要）。 10 P a g eR a n k 的基本设计思想和设计原则 l 从许多优质的网页链接 过来的网页，必定还是 优质网页。一个网页要 想拥有较高的 PR 值的条 件： l 有很多网页链接到它； （数量假设） l 有高质量的网页链接 到它。 （质量假设） 11 w w w . c n n . c o m e n . w i k i p e d i a . o r g w w w . n y t i m e s . c o m P a g eR a n k 的基本设计思想和设计原则 ¨ 如果网页 T 存在一个指向网页 A 的连接，则表明 T 的所有者认为 A 比较重要，从而 把 T 的一部分重要性得分赋予 A 。 这个重要性得分值为： PR ( T ) /L ( T ) ¤ 其中 PR ( T ) 为 T 的 P a g eR a n k 值， L( T ) 为 T 的出链数 ¤ 则 A 的 P a g eR a n k 值为一系列类似于 T 的页面重要性得分值的累加。 ¨ 即一个页面的得票数由所有链向它的页面的重要性来决定，到一个页面的超链 接相当于对该页投一票。一个页面的 P a g eR a n k 是由所有链向它的页面（链入页 面）的重要性经过递归算法得到的。一个有较多链入的页面会有较高的等级， 相反如果一个页面没有任何链入页面，那么它没有等级。 12 P a g eR a n k 的简化模型 ¨ 可以把互联网上的各个网页之间的链接关系看成一个有向 图。 ¨ 对于任意网页 Pi ，它的 P a g eR a n k 值可表示为： 13 其中 Bi 为所有链接到网页 i 的网页集合， Lj 为网页 j 的对外链接数（出度）。 简化模型的矩阵表示 14 R 为特征向量， H 为初始转移矩阵，比如第一 列表示从网页 P1 跳转到其他页面的概率 简化模型面临的问题 ¨ 实际的网络超链接环境没有这么理想化， P a g eR a n k 会面临两个问题： • 排名泄露（ R a n k l ea k ） • 排名下沉（ Ra n k s i n k ） 15 Ra n k L ea k 16 PR ( A ) PR ( B ) PR ( C ) PR ( D) 初始 0. 25 0. 25 0. 25 0. 25 一次迭代 0. 125 0. 125 0. 25 0. 25 二次迭代 0. 125 0. 125 0. 125 0. 25 三次迭代 0. 125 0. 125 0. 125 0. 125 … … … … … n 次迭代 0 0 0 0 R a n k l ea k ：一个独立的网页如果没有外出的链接就产生排名泄漏（多次 迭代后，所有网页的 PR 值都趋向于 0 ）。 解决办法： 1. 将无出度的节点递归地从图中去掉，待其他节点计算完毕后再添加。 2. 对无出度的节点添加一条边，指向那些指向它的顶点。 R a n k Si n k 17 PR ( A ) PR ( B ) PR ( C ) PR ( D) 初始 0. 25 0. 25 0. 25 0. 25 一次迭代 0 0. 375 0. 25 0. 375 二次迭代 0 0. 375 0. 375 0. 25 三次迭代 0 0. 25 0. 375 0. 375 四次迭代 0 0. 375 0. 25 0. 375 五次迭代 0 … … … R a n k s i n k ：若网页没有入度链接（如节点 A ），其所产生的贡献会被整个网 页图中的一组紧密链接成环的网页（如 B 、 C 、 D ）“吞噬”掉，节点 A 的 PR 值在迭代后会趋于 0 。 解决方法：引入随机浏览模型。 P a g eR a n k 的随机浏览模型 ¨ 假定一个上网者从一个随机的网页开始浏览 ¨ 上网者不断点击当前网页的链接开始下一次浏览。 ¨ 但是，上网者最终厌倦了，开始了一个随机的网页。 ¨ 随机上网者访问一个新网页的概率就等于这个网页的 P a g eR a n k 值。 因此这个模型更加接近于用户的行为。 18 随机浏览模型的图表示 19 设定任意两个顶点之间都有直接通路，在每个顶点处以 概率 d 按原来蓝色方向转移，以概率 1 - d 按红色方向转移。 随机浏览模型的矩阵表示 ¨ 回顾简单模型的矩阵表示： • R = H R ¨ 随机浏览模型的矩阵表示： • 令： H’ = d * H + ( 1 - d ) * [ 1 /N ] N × N • 则： R= H ’ R • 其中 R 为列向量，代表 Pa g e R a n k 值； H’ 代表转移矩阵； d 代表阻尼因子，通常设为 0. 85 。 ¨ 由于等式 R= H ’ R 满足马尔可夫链的性质，如果马尔可夫链收敛，则 R 存在唯一解 20 随机浏览模型的邻接表表示 ¨ 由于网页数目巨大，网页之间的连接关系的邻接矩阵是一个很大的 稀疏矩阵。 ¨ 采用邻接表来表示网页之间的连接关系。 ¨ 随机浏览模型的 P a g eR a n k 公式： ¤ 通过迭代计算得到所有节点的 P a g eR a n k 值。 21 随机浏览模型 ¨ 随机浏览模型的优点： ¤ 更加符合用户的行为 ¤ 一定程度上解决了 ra n k s i n k 问题 ¤ 保证 P a g eR a n k 存在唯一值。 22 用 M a p R ed u c e 实现 P a g eR a n k ¨ Ph a s e1 : G r a p h Bu i l d er ¤ 建立网页之间的超链接图 ¨ Ph a s e2 : P a g eR a n k I t er ¤ 迭代计算各个网页的 P a g eR a n k 值 ¨ Ph a s e3 : R a n k V i e w er ¤ 按 P a g eR a n k 值从大到小输出 23 Ph a s e1 ： G r a p h Bu i l d er ¨ 原始数据集：维基百科各网页间的链接信息。文本文件，共 11. 2G 。 每行包含一个网页名，及其所链接的全部网页名。 ¨ G r a p h Bu i l d er 目标：分析原始数据，建立各个网页之间的链接关系。 • Map ：逐行分析原始数据 , 输出 < U RL , ( PR_i n i t , l i n k _l i s t )> • 其中网页的 U RL 作为 ke y ， P a g eR a n k 初始值 ( PR_i n i t ) 和网页的出度列表一起作为 va l u e ，以字符 串表示 va l u e ， 用特定的符号将二者分开 。 • R ed u c e: 输出 < U RL , ( PR_i n i t , l i n k _l i s t )> • 该阶段的 R ed u c e 不需要做任何处理 24 Ph a s e2 ： P a g eR a n k I t er ¨ P a g eR a n k I t er ：迭代计算 PR 值，直到 PR 值收敛或迭代预定次数。 ¨ Map 对上阶段的 < U RL , ( c u r _r a n k , link _l i s t ) > 产生 两种 < k e y , v a l u e> 对 ： 1. F or ea c h u in l i n k _l i s t , 输出 < u , c u r _r a n k /| l i n k _l i s t |> • 其中 u 代表当前 U RL 所链接到网页 ID ，并作为 ke y ； • c u r _r a n k 为当前 U RL 的 P a g eR a n k 值， | l i n k _l i s t | 为当前 U RL 的出度数量， c u r _r a n k /| l i n k _l i s t | 作为 va l u e 。 2. 同时在迭代过程中，传递每个网页的链接信息 < U RL , l i n k _l i s t > • 在迭代过程中，必须保留网页的局部链出信息，以维护图的结构。 25 Ph a s e2 ： P a g eR a n k I t er ¨ R ed u c e 对 Map 输出的 < U RL , l i n k _l i s t > 和多个 < u , c u r _r a n k /| l i n k _l i s t |> 做如下处理： ¤ 其中 < U RL , l i n k _l i s t > 为当前 U RL 的链出信息； ¤ < u , c u r _r a n k /| l i n k _l i s t |> 为每个链入网页对当前网页 u 所贡献的 P a g eR a n k 值， 把这些贡献值按公式相加即可得到当前网页 u 的新的 P a g eR a n k 值。 • 计算所有 va l 的和，并乘上 d ，再加上常数 (1 - d ) /N 得到 n e w _r a n k 。 • 输出 ( u , ( n e w _r a n k , l i n k _l i s t )) 。 • 迭代计算公式： n PR( A ) = ( 1 - d ) /N + d ( PR( T 1 ) /C ( T 1 ) + . . . + PR( T n ) /C ( T n )) 26 Ph a s e2 ： P a g eR a n k I t er 27 P a g eR a n k I t er 伪代码 Ph a s e3 ： P a g eR a n k V i e w er ¨ P a g eR a n k V i e w er ：将最终结果排序输出。 • P a g eR a n k V i e w er 从最后一次迭代的结果读出文件，并将文件名和其 PR 值读出， 并以 PR 值为 ke y ，网页名为 va l u e ，并且以 PR 值从大到小的顺序输出。 • 排序过程中可以采用框架自身的排序处理，重载 ke y 的比较函数，使其经过 sh u ffl e 和 s or t 后反序（从大到小）输出。 pu bl i c s t at i c cl as s D ec F l oa t W r i t a b l e e xt en d s F l oa t W r i t a b l e { … @ O v er r i d e pu bl i c in t c om p a r eT o ( O b j ec t o) { r et u r n - s u p er . c om p a r eT o ( o) ; } } 28 P a g eR a n k 迭代终止条件 ¨ 可选的终止条件： ¤ 各网页的 P a g eR a n k 值不再改变； ¤ 各网页的 P a g eR a n k 值排序不再变化； ¤ 迭代至固定次数。 29 多趟 M a p R ed u c e 的处理 publ i c c l a s s Pa g e R a n k D r i v e r { p r i v a t e s t a t i c int ti m e s = 10 ; publ i c s t a t i c v oi d m a i n( S t r i ng ar g s []) t h ro w s E x c e p t i o n { St r i n g [ ] f or G B = { \" \" , args [ 1 ] + \" /D a t a 0 \" } ; f or G B [0] = args [0]; G r a p h Bu i l d er . m ai n ( f or G B ) ; St r i n g [ ] f or I t r = { \" Da t a \" , \" Da t a \"} ; fo r ( in t i= 0 ; i< ti m e s ; i + + ) { f or I t r [0] = args [ 1 ] + \" /D a t a \" + ( i ); f or I t r [1] = args [ 1 ] + \" /D a t a \" + ( i + 1 ) ; P a g eR a n k I t er . m ai n ( f or I t r ); } St r i n g [ ] f or R V = { args [1]+ \" / Da t a \" + ti m e s , ar g s [1]+ \" / F i n al R an k \"} ; P a g eR a n k V i e w er . m ai n ( f or R V ); } } 30 基于 M a p R ed u c e 的图算法小结 ¨ 通常采用邻接表来表示图。 ¨ 通常将一个完整的图结构，分解成若干个局部的子结构，对每个子 结构进行并行处理。 ¨ 在 ma p 阶段对邻接点产生 < k e y , v a l u e> 对，经过 sh u ffl e 和 s or t 后，在 r ed u c e 阶段更新节点信息。 ¨ 图算法通常是一个迭代过程，上一步的输出作为下一步的输入，由 额外的 ” d r i v er ” 控制。 31 TH A NK YO U","libVersion":"0.2.4","langs":""}