{"path":"课程/金融大数据/课件/08 MapReduce Advanced Programming.pdf","text":"M a p R ed u c e 高级程序设计 摘要 p 复合键值对的使用 p 用户自定义数据类型 p 用户自定义输入输出格式 p 用户自定义 P a r t i t i on er 和 C om b i n er p 迭代完成 M a p R ed u c e 计算 p 链式 M a p R ed u c e 任务 p 全局参数 / 数据文件的传递 p 其它处理技术 2 复合键值对的使用 ¨ 思路： 用复合键让系统完成排序 ¤ 问题 ： map 计算过程结束后进行 P a r t i t i on i n g 处理时，系统自动按照 map 的输 出键进行排序，因此，进入 R ed u c e 节点的 ( k e y , [ v a l u e] ) 对将保证是按照 ke y 进 行排序的，而 [ v a l u e] 则不保证是排好序的。为了解决这个问题，可以在 R ed u c e 过程中对 [ v a l u e] 列表中的各个 va l u e 进行本地排序。但当 [ v a l u e] 列表数 据量巨大、无法在本地内存中进行排序时，将出现问题。 ¤ 改进方法 ：将 va l u e 中需要排序的部分加入到 ke y 中形成复合键，这样将能利 用 M a p R ed u c e 系统的排序功能完成排序。 ¤ 代价 ：但需要实现一个新的 P a r t i t i on er ，保证原来同一 ke y 值的键值对最后分 区到同一个 R ed u c e 节点上。 3 复合键值对的使用 ¨ 带频率的倒排索引示例 1: cl a s s M a p p e r 2: pr oc e dur e Ma p ( d oc i d n, d oc d) 3: H ← ne w A s s oc i a t i v eA r r a y 4: fo r a l l t er m t ∈ d oc d do 5: H {t } ← H{ t } + 1 6: fo r a l l t er m t ∈ H do 7 : E m i t ( t er m t , p os t i n g < n , H {t }> ) 1: cl a s s R e d u ce r 2: pr oc e dur e R ed u c e( t er m t , p os t i n g s [ < n 1 , f 1 >, <n 2 , f 2 > …] ) 3: P ← ne w L i s t 4: fo r a l l p os t i n g < a , f > ∈ p os t i n g s [ < n 1 , f 1 >, <n 2 , f 2 > …] do 5 : A p p en d ( P , < a , f > ) 6 : Sor t ( P ) ； // 进入 R ed u c e 节点的 p os t i n g s 不保证按照文档序 号排序 , 因而需要对 p os t i n g s 进行一个本地排序 7 : E m i t ( t er m t ; p os t i n g s P ) 4 复合键值对的使用 ¨ 带频率的倒排索引示例 ¤ 为了能利用系统自动对 d oci d 进行排序，解决方法是：代之以生成（ t er m ， < d oci d , tf > ）键值对， map 时将 t er m 和 d oci d 组合起来形成复合键 < t er m , d oci d > 。 ¤ 但会引起新的问题，同一个 t er m 下的所有 p os t i n g 信息无法被分区 到同一个 R ed u c e 节点，为此，需要实现一个新的 P a r t i t i on er ：从 < t er m , d oc i d > 中取出 t er m ，以 t er m 作为 ke y 进行分区。 5 Cu st o m i z e d Pa r t i t i o n e r 进入 re d u c e 的键值对按照 (t e r m, doc id ) 排序 复合键值对的使用 ¨ 思路： 把小的键值对合并成大的键值对 ¤ 通常一个计算问题会产生大量的键值对，为了减少键值对传输和 排序的开销，一些问题中的大量小的键值对可以被合并成一些大 的键值对 (pai r s - > s t r i p es ) 。 8 复合键值对的使用 ¨ 例如： 单词同现矩阵算法 ¤ 一个 Map 可能会产生单词 a 与其它单词间的多个键值对，这些键值对可以在 Map 过程中合并成右侧的一个大的键值对 ( 条 ): ¤ 然后，在 R ed u c e 阶段，把每个单词 a 的键值对 ( 条 ) 进行累加： 9 ( a , b ) → 1 ( a , c) → 2 ( a , d ) → 5 ( a , e ) → 3 ( a , f ) → 2 a → { b : 1 , c: 2 , d : 5 , e : 3 , f : 2 } a → { b : 1 , d : 5 , e : 3 } a → { b : 1 , c: 2 , d : 2 , f : 2 } a → { b : 2 , c: 2 , d : 7 , e : 3 , f : 2 } + 复合键值对的使用 ¨ 单词同现矩阵算法 10 C l u s t e r s i ze : 3 8 co r e s Da t a S o u r c e : A sso ci a t e d P r e ss W o r l d st r e a m ( A P W ) o f t h e E n g l i sh Gi g a w o r d C o r p u s ( v3 ) , w h i ch co n t a i n s 2 . 2 7 m i l l i o n d o cu m e n t s ( 1 . 8 G B co m p r e sse d , 5 . 7 G B u n co m p r e sse d ) 用户自定义数据类型 ¨ H a d oop 内置的数据类型，这些数据类型都实现了 W r i t a b l eC om p a r a b l e 接口，以 便进行网络传输和文件存储，以及进行大小比较。 11 Cl a s s De sc r iption Bool ea n W r i t a b l e W r a p p er f or a s t a n d a r d Bool ea n v a r i a b l e Byt eW r i t a b l e W r a p p er f or a s i n g l e b yt e D ou b l eW r i t a b l e W r a p p er f or a D ou b l e F l oa t W r i t a b l e W r a p p er f or a F l oa t In t W r it a b le W r a p p er f or a I n t eg er L on g W r i t a b l e W r a p p er f or a L on g Nul l W r i ta b l e Pl a c eh ol d er w h en t h e k e y or v a l u e i s n ot n eed ed T e xt W r a p p er t o s t or e t e xt u s i n g t h e U T F - 8 f or m a t 用户自定义数据类型 ¨ 需要实现 Wr i t a b l e 接口，作为 ke y 或者需要比较大小时则需要实现 W r i t a b l eC om p a r a b l e 接口。 12 p u b l i c cl a ss Po i n t 3 D i m p l e m e n t s Wr i t a b l e C o m p a r a b l e <P o i n t 3 D >{ p r i va t e in t x, y , z; p u b l i c in t get X ( ) { r e t u r n x; } p u b l i c in t get Y ( ) { r e t u r n y; } p u b l i c in t get Z ( ) { r e t u r n z; } p u b l i c vo i d wr it e ( Da t a O u t p u t o u t ) t h r o w s I O E xce p t i o n { out . w ri t eF l oat ( x) ; out . w ri t eF l oat ( y) ; out . w ri t eF l oat ( z) ; } p u b l i c vo i d re a d F i e l d s ( Da t a I n p u t i n ) t h r o w s I O E xce p t i o n { x = in . r e a d F lo a t (); y = in . r e a d F lo a t (); z = in . r e a d F lo a t (); } p u b l i c in t co m p ar eT o (P oi nt 3D p){ / / co m p a r e s t h i s( x, y , z) w i t h p ( x, y , z) a n d / / o u t p u t s - 1( 小于 ), 0( 等于 ), 1( 大于 ) } } 用户自定义数据类型 p u b l i c cl a ss Ed g e i m p l e m e n t s Wr i t a b l e C o m p a r a b l e <E d g e > { p r i va t e S t r i n g depart ureN ode ; p r i va t e S t r i n g a r r i va l N o d e ; p u b l i c S t r i n g get D epart ureN ode () { ret urn depart ureN ode ;} @ O ve r r i d e p u b l i c vo i d re a d F i e l d s ( Da t a I n p u t i n ) t h r o w s I O E xce p t i o n { depart ureN ode = in . r e a d UT F (); a r r i va l N o d e = in . r e a d UT F (); } @ O ve r r i d e p u b l i c vo i d wr it e ( Da t a O u t p u t o u t ) t h r o w s I O E xce p t i o n { out . w ri t eU T F ( depart ureN ode ); out . w ri t eU T F ( a r r i va l N o d e ); } @ O ve r r i d e p u b l i c in t co m p ar eT o (E dge o) { r e t u r n ( d e p a r t u r e N o d e . co m p a r e T o ( o. depart ureN ode )! = 0) ? d e p a r t u r e N o d e . co m p a r e T o ( o. depart ureN ode ): a r r i va l N o d e . co m p a r e T o ( o . a r r i va l N o d e ); } } 13 用户自定义输入输出格式 ¨ 数据输入格式（ I n p u t F or m a t ）用于描述 M a p R ed u c e 作业的数据输 入规范。 ¨ M a p R ed u c e 框架依靠数据输入格式完成输入规范检查（比如输入 文件目录的检查）、对数据文件进行输入分片（ I n p u t Sp l i t ），以 及提供从输入分块中将数据记录逐一读出，并转换为 Ma p 过程的 输入键值对等功能。 ¨ T e xt I n p u t F or m a t 是系统缺省的数据输入格式。 14 用户自定义输入输出格式 ¨ H a d oop 内置的文件输入格式 15 InputF or m a t : De sc r iption: Ke y : Va l u e : T e xt I n p u t F or m a t D ef a u l t f or m a t ; r ea d s l i n es of t e xt f i l es T h e b yt e of f s et of t h e l i n e T h e l i n e c on t en t s K e yV a l u e T e xt In p u t F or m a t P a r s es l i n es i n t o k e y - va l pai r s E v er yt h i n g u p t o t h e f i r s t t a b c h a r a c t er T h e r em a i n d er of t h e lin e Seq u en c eF i l eI n p u t F or m a t A H a d oop - s p ec i f i c hi g h - p er f or m a n c e b i n a r y f or m a t u s er - d ef i n ed u s er - d ef i n ed 用户自定义输入输出格式 ¨ H a d oop 内置的文件输入格式 ¨ A u t oI n p u t F or m a t , C om b i n eF i l eI n u t F or m a t , C om p os i t eI n p u t F or m a t , D BI n p u t F or m a t , F i l eI n p u t F or m a t , K e yV a l u eT e xt I n p u t F or m a t , L i n eD oc I n p u t F or m a t , M u l t i F i l eI n p u t F or m a t , N L i n eI n p u t F or m a t , Seq u en c eF i l eA s Bi n a r yI n p u t F or m a t , Seq u en c eF i l eA s T e xt I n p u t F or m a t , Seq u en c eF i l eI n p u t F i l t er , Seq u en c eF i l eI n p u t F or m a t , St r ea m I n p u t F or m a t , T e xt I n p u t F or m a t 16 用户自定义输入输出格式 ¨ H a d oop 内置的 R ec or d R ea d er 17 Re c o r d Re a d e r : InputF or m a t De sc r iption: L i n eR ec or d R ea d er d ef a u l t r ea d er f or T e xt I n p u t F or m a t r ea d s l i n es of t e xt f i l es K e yV a l u eL i n eR ec or d R ea d er d ef a u l t r ea d er f or K e yV a l u e T e xt I n p u t F or m a t p a r s es l i n es i n t o k e y - va l pai r s Seq u en c eF i l eR ec or d R ea d er d ef a u l t r ea d er f or Seq u en c eF i l eI n p u t F or m a t U s er - d ef i n ed m et h od s t o c r ea t e k e ys a n d v a l u es 用户自定义输入输出格式 ¨ H a d oop 内置的 R ec or d R ea d er ¨ C om b i n eF i l eR ec or d R ea d er , D BI n p u t F or m a t . D BR ec or d R ea d er , I n n er J oi n R ec or d R ea d er , J oi n R ec or d R ea d er , K e yV a l u eL i n eR ec or d R ea d er , L i n eD oc R ec or d R ea d er , M u l t i F i l t er R ec or d R ea d er , O u t er J oi n R ec or d R ea d er , O v er r i d eR ec or d R ea d er , Seq u en c eF i l eA s Bi n a r yI n p u t F or m a t . Seq u en c eF i l eA s Bi n a r yR ec or d R ea d er , Seq u en c eF i l eA s T e xt R ec or d R ea d er , Seq u en c eF i l eR ec or d R ea d er , St r ea m Ba s eR ec or d R ea d er , St r ea m X m l R ec or d R ea d er , W r a p p ed R ec or d R ea d er 18 用户自定义输入输出格式 ¨ 用户自定义 I n p u t F or m a t 和 R ec or d R ea d er 19 im p o r t j a va . i o . I O E xce p t i o n ; im p o r t j a va . u t i l . S t r i n g T o ke n i ze r ; im p o r t o r g . a p a ch e . h a d o o p . i o . T e xt ; im p o r t o r g . a p a ch e . h a d o o p . m a p r e d u ce . M a p p e r ; p u b l i c cl a ss In v e r te d In d e x Ma p p e r e xt e n d s Ma p p e r < T e xt , T e xt , T e xt , T e xt > { @ O ve r r i d e pr ot ect ed voi d m ap( T ext key , T ext val ue, C ont ext cont ext ) t h r o w s I O E xce p t i o n , I n t e r r u p t e d E xce p t i o n // d e fa u l t R e co r d R e a d e r : L i n e R e co r d R e a d e r ; / / ke y: l i n e o f f se t ; va l u e : l i n e st r i n g { T e xt w o r d = n e w T e xt ( ) ; Fi l eS pl i t fi l e S p l i t = ( Fi l eS pl i t ) co n t e xt . g e t I n p u t S p l i t (); St r in g fi l e N a me = fi l e S p l i t.g e tP a th (). get N am e (); T e xt f i l e N a m e _ l i n e O f f se t = n e w T e xt ( fi l e N a me +” @ ” + ke y . t o S t r i n g ()); S t r i n g T o ke n i ze r it r = n e w S t r i n g T o ke n i ze r ( va l u e . t o S t r i n g ()); fo r(; i t r . h a sM o r e T o ke n s (); ) { w o r d . se t ( i t r . n e xt T o ke n ()); co n t e xt . w r i t e (w o rd , f i l e N a m e _ l i n e O f f se t ); } } } 简单的文档倒排索引 由于采用了缺省的 Te x t I n p u t F o r m a t 和 Li n e R e c o r d R e a d e r ， 需要增加此段代码 完成特殊处理 用户自定义输入输出格式 ¨ 用户自定义 I n p u t F or m a t 和 R ec or d R ea d er 20 p u b l i c cl a ss File Na me Loc InputForma t e xt e n d s File In p u tFo rma t < T e xt , T e xt > { @ O ve r r i d e p u b l i c R e co r d R e a d e r < T e xt , T e xt > cr e a t e R e co r d R e a d e r ( InputSplit sp l i t , T a skA t t e m p t C o n t e xt co n t e xt ) { F i l e N a m e L o cR e co r d R e a d e r fnr r = new F i l e N a m e R e co r d R e a d e r (); t r y { f n r r . i n i t i a l i ze ( sp l i t , co n t e xt ) ; } ca t ch ( I O E xce p t i o n e) { e . p r i n t S t a ckT r a ce (); } ca t ch ( I n t e r r u p t e d E xce p t i o n e) { e . p r i n t S t a ckT r a ce (); } re t u rn fnr r ; } } 简单的文档倒排索引 可以自定义一个 I n p u t F or m a t 和 R ec or d R ea d er 实现同样的效果 用户自定义输入输出格式 21 p u b l i c cl a ss File Na me Loc Re c ordRe a de r e xt e n d s R e co r d R e a d e r < T e xt , T e xt > { Str i ng fileNam e ; L i n e R e co r d R e a d e r lrr = new L i n e R e co r d R e a d e r (); …… @ o ve r r i d e p u b l i c T e xt ge tCurre ntKe y ( ) t h r o w s I O E xce p t i o n , I n t e r r u p t e d E xce p t i o n { r e t u r n n e w T e xt ( \" ( \" + fi l e Na me + “@ \" + lrr .get Current Key () + \") \") ; } @ o ve r r i d e p u b l i c T e xt ge tCurre ntV a lue ( ) t h r o w s I O E xce p t i o n , I n t e r r u p t e d E xce p t i o n { r etur n lrr .g e tCu rre n tV a lu e (); } @ o ve r r i d e p u b l i c vo i d i n i t i a l i ze ( InputSplit ar g0, T a skA t t e m p t C o n t e xt ar g1) t h r o w s I O E xce p t i o n , I n t e r r u p t e d E xce p t i o n { l r r . i n i t i a l i ze (a rg 0 , a rg 1 ); fileNam e = ( ( File Sp lit )a rg 0 ). getPath (). getN am e (); } } 用户自定义输入输出格式 22 p u b l i c cl a ss Invert edIndexer { p u b l i c st a t i c vo i d m a i n ( S t r i n g [ ] ar gs ) { t r y { C o n f i g u r a t i o n co n f = n e w C o n f i g u r a t i o n ( ) ; j o b = n e w Jo b ( co n f , \" i n ve r t i n d e x\" ) ; j o b . se t Ja r B yC l a ss ( I n ve r t e d I n d e xe r . cl a ss ); j o b . se t I n p u t F o r m a t C l a ss ( File Na me Loc InputForma t . cl a ss ); j o b . se t M a p p e r C l a ss ( I n ve r t e d I n d e xM a p p e r . cl a ss ); j o b . se t R e d u ce r C l a ss ( I n ve r t e d I n d e xR e d u ce r . cl a ss ); j o b . se t O u t p u t K e yC l a ss ( T e xt . cl a ss ); j o b . se t O u t p u t V a l u e C l a ss ( T e xt . cl a ss ); File In p u tFo rma t.a d d In p u tPa th (jo b , n e w P a t h ( ar gs [0]) ) ; F i l e O u t p u t F o r m a t . se t O u t p u t P a t h (jo b , n e w P a t h ( ar gs [1]) ) ; S yst e m . e xi t ( jo b .wa itFo rCo mp le tio n (t ru e ) ? 0 : 1 ); } ca t ch ( E xce p t i o n e ) { e . p r i n t S t a ckT r a ce (); } } } 用户自定义输入输出格式 23 imp o rt j a va . i o . I O E xce p t i o n ; imp o rt j a va . u t i l . S t r i n g T o ke n i ze r ; imp o rt o r g . a p a ch e . h a d o o p . i o . T e xt ; imp o rt o r g . a p a ch e . h a d o o p . m a p r e d u ce . M a p p e r ; p u b l i c cl a ss Invert edIndexM apper e xt e n d s Ma p p e r < T e xt , T e xt , T e xt , T e xt > { @ O ve r r i d e prote c te d v oid ma p(T e x t k e y , T e x t v a lue , Conte x t co n t ext ) t h r o w s I O E xce p t i o n , I n t e r r u p t e d E xce p t i o n // In p u tF o rma t : Fi l eN am eLocI nput For m at // R e co r d R e a d e r : Fi l eN am eLocR ecor dR eader // ke y: f i l e n a m e @ l i n e o f f se t ; va l u e : l i n e st r i n g { T e xt w o r d = n e w T e xt ( ) ; S t r i n g T o ke n i ze r itr = new S t r i n g T o ke n i ze r ( va l u e . t o S t r i n g ()); for ( ; i t r . h a sM o r e T o ke n s (); ) { w o r d . se t ( i t r . n e xt T o ke n ()); co n t e xt . w r i t e ( w o r d , ke y) ; } } } 用户自定义输入输出格式 ¨ 数据输出格式（ O u t p u t F or m a t ）用于描述 M a p R ed u c e 作业的数据 输出规范。 ¨ M a p R ed u c e 框架依据数据输出格式完成输出规范检查（如检查输 出目录是否存在）以及提供作业结果数据输出等功能。 ¨ T e xt O u t p u t F or m a t 是系统缺省的 数据输出格式。 24 用户自定义输入输出格式 ¨ H a d oop 内置的 O u t p u t F or m a t 和 R ec or d W r i t er 25 Ou t p u t F o r m a t : Des cr ip tio n T e xt O u t p u t F or m a t D ef a u l t ; w r i t es l i n es i n \" k e y \\ t v a l u e\" f or m Seq u en c eF i l eO u t p u t F or m a t W r i t es b i n a r y f i l es s u i t a b l e f or r ea d i n g i n t o s u b s eq u en t M a p R ed u c e j ob s N u l l O u t p u t F or m a t D i s r eg a r d s i t s ou t p u t s D BO u t p u t F or m a t , F i l eO u t p u t F or m a t , F i l t er O u t p u t F or m a t , I n d e xU p d a t eO u t p u t F or m a t , L a z yO u t p u t F or m a t , M a p F i l eO u t p u t F or m a t , M u l t i p l eO u t p u t F or m a t , M u l t i p l eSeq u en c eF i l eO u t p u t F or m a t , M u l t i p l eT e xt O u t p u t F or m a t , N u l l O u t p u t F or m a t , Seq u en c eF i l eA s Bi n a r yO u t p u t F or m a t , Seq u en c eF i l eO u t p u t F or m a t , T e xt O u t p u t F or m a t 用户自定义输入输出格式 ¨ H a d oop 内置的 O u t p u t F or m a t 和 R ec or d W r i t er 26 Re c o r d W r i t e r : Des cr ip tio n L i n eR ec or d W r i t er D ef a u l t R ec or d W r i t er f or T e xt O u t p u t F or m a t w r i t es l i n es i n \" k e y \\ t v a l u e\" f or m D BO u t p u t F or m a t . D BR ec or d W r i t er , F i l t er O u t p u t F or m a t . F i l t er R ec or d W r i t er , T e xt O u t p u t F or m a t . L i n eR ec or d W r i t er 与 I n p u t F or m a t 和 R ec or d R ea d er 类似，用户可以根据需要定制 O u t p u t F or m a t 和 R ec or d W r i t er 用户自定义输入输出格式 ¨ 划分多个输出文件集合 ¤ 缺省情况下， M a p R ed u c e 将产生包含一至多个文件的单个输出数据文件集合。但有时候作 业可能需要输出多个文件结合。 n 比如：在处理巨大的访问日志文件时，由于文件太大我们可能希望按每天的日期将访问 日志记录输出为每天日期下的文件。在处理专利数据集时，我们希望根据不同国家，将 每个国家的专利数据记录输出到不同国家的文件目录中。 n H a d oop 提供了 M u l t i p l eO u t p u t F or m a t 类 ( or g . a p a c h e . h a d oop . m a p r ed . l i b . M u l t i p l eO u t p u t F or m a t ) 来快速完成这一处理功能。在 R ed u c e 进行数据输出前， M u l t i p l eO u t p u t F or m a t 将调用一个 内部方法以决定输出的文件名是什么。通常需要继承并实现 M u l t i p l eO u t p u t F or m a t 的一个 子类并实现其中的 g en er a t eF i l eN a m eF or K e yV a l u e () 方法以根据当前的键值对由程序产生并 返回一个输出文件路径： p r ot ec t ed St r i n g g en er a t eF i l eN a m eF or K e yV a l u e ( K k e y , V v a l u e , St r i n g n a m e) 27 用户自定义输入输出格式 ¨ 划分多个输出文件集合 ¤ 例如：将专利描述文件数据集按照国家进行多文件集合输出 “ P A T E N T ” , ” G Y E A R” , ” G D A T E ” , ” A PPY E A R” , ” CO U N T R Y ” , ” PO ST A T E ” , ” A SSI G N E E ” , ” A SSC O D E ” , ” C L A I M S” , ” N C L A S S” , ” C A T ” , ” SU BC A T ” , ” C M A D E ” , ” C RE C E I V E ” , ” RA T I O C I T ” , ” G E N E RA L ” , ” O RI G I N A L ” , ” F WD A PL A G ” , ” BC K G T L A G ” , ” SE L F C T U B” , ” SE L F C T L B” , ” SE C D U PBD ” , ” SE C D L WBD ” 3070801, 1963, 1096, , ” BE ”, ””, , 1 , , 2 6 9 , 6 , 6 9 , , 1 , , 0 , , , , , , , 3070802, 1963, 1096, , ” US ”, ”T X ”, , 1 , , 2 , 6 , 6 3 , , 0 , , , , , , , , , 28 用户自定义输入输出格式 ¨ 划分多个输出文件集合 ¤ 例如：将专利描述文件数据集按照国家进行多文件集合输出 pu bl i c stati c c l ass MapC l as s e xt en d s M a p p er < L on g W r i t a b l e , T e xt , Nu l l W r i t a b l e , T e xt > { p u b l i c v oi d m a p ( L on g W r i t a b l e k e y , T e xt v a l u e , C on t e xt c on t e xt ） th r o w s I O E x c ep t i on , I n t er r u p t ed E x c ep t i on { c on t e xt . w r i t e ( N u l l W r i t a b l e . g et ( ) , v a l u e) ; } // N u l l W r i t a b l e . g et () 返回 s i n g l et on 单一实例 } pu bl i c stati c c l ass Sa v e B yC ount r yO ut put F or m a t e xt en d s M u l t i p l eT e xt O u t p u t F or m a t < N u l l W r i t a b l e , T e xt > { p r ot ec t ed St r i n g ge n e r a t e F i l e N a m e F o r K e y V a l u e ( Nu l l W r i t a b l e k e y , T e xt v a l u e , St r i n g f i l en a m e) { St r i n g [ ] arr = v a l u e . t oSt r i n g (). s pl i t(“ , ” , - 1); St r i n g c ou n t r y = arr [4]. s u bs tr i n g(1, 3); r et u r n c ou n t r y + “ /” + f i l en a m e ; } } 29 用户自定义输入输出格式 ¨ 划分多个输出文件集合 pu bl i c c l ass M u l t i F i l eD em o { p u b l i c s t a t i c v oi d m a i n ( St r i n g [ ] args ) t h r o w s E x c ep t i on { C on f i g u r a t i on c on f = n e w C on f i g u r a t i on ( ) ; J ob j ob = n e w J ob ( c on f , M u l t i F i l eD em o . c l a s s ); Pa t h i n = n e w Pa t h ( ar gs [0 ]); P a t h ou t = n e w P a t h ( ar gs [1 ]); F i l eI n p u t F or m a t . s et I n p u t P a t h s ( j ob , i n ) ; F i l eO u t p u t F or m a t . s et O u t p u t P a t h ( j ob , ou t ) ; j ob . s et J ob N a m e (“ M u l t i F i l eD em o ”) ; j ob . s et M a p p er C l a s s ( Ma p Cl a s s . c l a s s ); j ob . s et I n p u t F or m a t ( T e xt I n p u t F or m a t . c l a s s ); j ob . s et O u t p u t F or m a t ( Sa v e B y C o u n t r y Ou t p u t F o r m a t .c la s s ); j ob . s et O u t p u t K e yC l a s s ( Nul l W r i ta b l e . c l a s s ); j ob . s et O u t p u t V a l u eC l a s s ( T e xt . c l a s s ); j ob . s et N u m R ed u c eT a s k s (0 ); J ob . w a i t F or C om p l et i on ( t r u e) ; } } 30 用户自定义输入输出格式 ¨ 执行结果 31 用户自定义输入输出格式 ¨ M u l t i p l eO u t p u t F or m a t ( or g . a p a c h e . h a d oop . m a p r ed . l i b . M u l t i p l eO u t p u t F or m a t ) ¤ M u l t i p l eO u t p u t F or m a t 是 H a d oop 的 O u t p u t F or m a t 的一个扩展，用于处理多个输出文件。 ¤ 它允许你为每个 R ed u c er 任务定义一个不同的 O u t p u t F or m a t 。 这意味着你可以为每个 R ed u c er 任务指定不同的输出目录和输出文件格式。 ¤ 这对于根据特定的数据或逻辑将数据分发到不同的输出目录非常有用，更适合在整个 M a p R ed u c e 作业级别控制多个输出文件的格式和目录。 ¨ M u l t i p l eO u t p u t s ( or g . a p a c h e . h a d oop . m a p r ed u c e . l i b . ou t p u t . M u l t i p l eO u t p u t s ) ¤ M u l t i p l eO u t p u t s 是一个更高级别的 A PI ， 用于在 M a p p er 或 R ed u c er 内部根据某些条件将数据输 出到多个文件或目录。 ¤ 它允许你在 M a p p er 或 R ed u c er 内部为不同的输出文件指定不同的键值对，而不需要为每个 R ed u c er 任务创建不同的 O u t p u t F or m a t 。 ¤ 这对于根据数据的属性或业务逻辑将数据分发到多个输出目录非常有用，而无需创建多个 R ed u c er 任务，更适合在 M a p p er 或 R ed u c er 内部根据条件动态控制多个输出文件。 32 用户自定义输入输出格式 ¨ or g . a p a c h e . h a d oop . m a p r ed . * vs or g . a p a c h e . h a d oop . m a p r ed u c e .* ¨ 历史演变 : ¤ m a p r ed 包是 H a d oop 的早期版本中使用的包，用于实现 M a p R ed u c e 编程模型。 ¤ m a p r ed u c e 包是 H a d oop 0 . 2 0 版本之后引入的，用于替代 m a p r ed 包。这一改变是为了改 进和优化 M a p R ed u c e 的性能以及提供更灵活的编程接口。 ¨ 性能优化 : ¤ m a p r ed u c e 包相对于 m a p r ed 包进行了许多性能优化，包括更好的资源管理、任务调度、 错误处理等方面的改进，以提高 M a p R ed u c e 作业的执行效率。 ¨ A PI 灵活性 : ¤ m a p r ed u c e 包引入了一种新的 A PI ，使得编写 M a p R ed u c e 作业更加灵活和容易。这一 A PI 的设计更加现代化，与标准 Ja v a 编程实践更加一致，因此编写和维护 M a p R ed u c e 作业变 得更容易。 33 用户自定义 P a r t i t i on er 和 C om b i n er ¨ 定制 P a r t i t i on er ¤ 程序员可以根据需要定制 P a r t i t i on er 来改变 Map 中间结果到 R ed u c e 节点的分区方式，并在 J ob 中设置新的 P a r t i t i on er 34 cl a s s Ne w P a r t i t i o n e r e xt en d s H a s h P a r t i t i on er <K , V> { // o v er r i d e t h e m et h od getP a r titio n ( K ke y , V va l u e , int n u m R ed u c eT a s k s ) { t er m = k e y . t oSt r i n g ( ) . s p l i t ( “ , ” ) [ 0 ] ; // < t er m , d oc i d > = > t er m s u p er . g et P a r t i t i on ( t er m , v a l u e , n u m R ed u c eT a s k s ); } } 并在 J ob 中设置新的 P a r t i t i on er ： Jo b . se t P a r t i t i o n e r Cl a ss ( N e w P a r t i t i on er ) 用户自定义 P a r t i t i on er 和 C om b i n er ¨ 定制 C om b i n er ¤ 程序员可以根据需要定制 C om b i n er 来减少网络数据传输量，提高系统效率， 并在 J ob 中设置新的 C om b i n er 例如，每年申请美国专利的国家数统计 P a t en t d es c r i p t i on d a t a s et “ a p a t 6 3 _9 9 . t xt ” “P A T E N T ”, ” GY E AR ” , ” G D A T E ” , ” A PPY E A R” , ” CO UN T R Y ” , ” PO ST A T E ” , ” A SSI G N E E ” , ” A SSC O D E ” , ” C L A I M S” , ” N C L A SS” , ” C A T ” , ” SU BC A T ” , ” C M A D E ” , ” C RE C E I V E ” , ” RA T I O C I T ” , ” G E N E RA L ” , ” O RI G I N A L ” , ” F WD A PL A G ” , ” BC K G T L A G ” , ” SE L F C T U B” , ” SE L F C T L B” , ” SE C D U PBD ” , ” SE C D L WBD ” 3070801, 1963 ,1 0 9 6 ,, ” BE ”, ””, , 1 , , 2 6 9 , 6 , 6 9 , , 1 , , 0 , , , , , , , 3070802, 1963 ,1 0 9 6 ,, ” US ”, ”T X ”, , 1 , , 2 , 6 , 6 3 , , 0 , , , , , , , , , 3070803, 1963 ,1 0 9 6 ,, ” US ”, ”I L ”, , 1 , , 2 , 6 , 6 3 , , 9 , , 0 . 3 7 0 4 , , , , , , , 3070804, 1963 ,1 0 9 6 ,, ” US ”, ”O H”, , 1 , , 2 , 6 , 6 3 , , 3 , , 0 . 6 6 6 7 , , , , , , , 3070805, 1963 ,1 0 9 6 ,, ” US ”, ”CA ”, , 1 , , 2 , 6 , 6 3 , , 1 , , 0 , , , , , , , 35 用户自定义 P a r t i t i on er 和 C om b i n er ¨ 定制 C om b i n er 每年申请美国专利的国家数统计 1. M ap 中用 < y ea r , c ou n t r y> 作为 ke y 输出， E m i t ( < y ea r , c ou n t r y> , 1 ) ( < 1 9 6 3 , BE > , 1 ) , ( < 1 9 6 3 , U S> , 1 ) , ( < 1 9 6 3 , U S> , 1 ) , … 2. 实现一个定制的 P a r t i t i on er ，保证同一年份的数据划分到同一个 R ed u c e 节点 3 . R ed u c e 中对每一个 ( < y ea r , c ou n t r y> , [ 1 , 1 , 1 , …] ) 输入，忽略后部的出现次数，仅考虑 ke y 部分： < y ea r , c ou n t r y> 问题：如每碰到一个 < y ea r , c ou n t r y > ，即 em i t ( y ea r , 1 ) 有问题吗？ 答案：有问题。因为可能会有从不同 Ma p 节点发来的同样的 < y ea r , c ou n t r y> ，因此会出现对同一国家的重复 计数 解决办法：在 R ed u c e 中仅计数同一年份下不同的国家个数 问题： Ma p 结果 ( < y ea r , c ou n t r y> , [ 1 , 1 , 1 , …] ) 数据通信量较大 解决办法：实现一个 C om b i n er 将 [ 1 , 1 , 1 , …] 合并为 1 36 用户自定义 P a r t i t i on er 和 C om b i n er ¨ 定制 C om b i n er 每年申请美国专利的国家数统计 pu bl i c stati c c l ass Ne w C o m b i n e r e xt en d s R ed u c er < T e xt , Int W r it a b le , T e xt , Int W r it a b le > { p u b l i c v oi d r ed u c e( T e xt k e y , I t er a b l e < Int W r it a b le > v a l u es , C on t e xt c on t e xt ) th r o w s I O E x c ep t i on , I n t er r u p t ed E x c ep t i on { // 忽略 ( < y ea r , c ou n t r y> , [ 1 , 1 , 1 , …] ) 后部大量重复的 [ 1 , 1 , 1 , …] ， // 归并为 < y ea r , c ou n t r y> 的 1 次出现 c on t e xt . w r i t e (k e y , n e w Int W r it a b le (1)); } // 输出 k e y: < y ea r , c ou n t r y> ; v a l u e: 1 } 37 迭代 M a p R ed u c e 计算 ¨ 基本问题 ¤ 一些求解计算需要用迭代方法求得逼近结果（求解计算必须是收敛性的）。当用 M a p R ed u c e 进行这样的问题求解时，运行一趟 M a p R ed u c e 过程无法完成整个求解过程，因此， 需要采用迭代方法循环运行该 M a p R ed u c e 过程，直到达到一个逼近结果。 ¨ 例如：页面排序算法 P a g eR a n k ¤ 随机浏览模型：假设一位上网者随机地浏览一些网页 • 有可能从当前网页点击一个链接继续浏览（概率为 d ）； • 有可能随机跳转到其它 N 个网页中的任一个（概率为 1 - d ）。 ¤ 每个网页的 P a g eR a n k 值可以看成该网页被随机浏览的概率： 38 L( p j ) 为网页 p j 上的超链个数 迭代 M a p R ed u c e 计算 ¨ 页面排序算法 P a g eR a n k ¨ 问题是在求解 PR( p i ) 时，需要递归调用 PR( p j ) ，而 PR( p j ) 本身也是待求解的。因此， 我们只能先给每个网页赋一个假定的 PR 值，如 0.5 。但这样求出的 PR( p i ) 肯定不 准确。然而，当用求出的 PR 值反复进行迭代计算时，会越来越趋近于最终的准 确结果。 ¨ 因此，需要用迭代方法循环运行 M a p R ed u c e 过程，直至第 n 次迭代后的结果与 第 n - 1 次的结果小于某个指定的阈值 时结束，或者 通过经验控制循环固定的次 数。 39 多趟 M a p R ed u c e 的处理 40 publ i c c l a s s Pa g e R a n k D r i v e r { p r i v a t e s t a t i c int ti m e s = 10 ; publ i c s t a t i c v oi d m a i n( S t r i ng ar g s []) t h ro w s E x c e p t i o n { St r i n g [ ] f or G B = { \" \" , args [ 1 ] + \" /D a t a 0 \" } ; f or G B [0] = args [0]; G r a p h Bu i l d er . m ai n ( f or G B ) ; St r i n g [ ] f or I t r = { \" Da t a \" , \" Da t a \"} ; fo r ( in t i= 0 ; i< ti m e s ; i + + ) { f or I t r [0] = args [ 1 ] + \" /D a t a \" + ( i ); f or I t r [1] = args [ 1 ] + \" /D a t a \" + ( i + 1 ) ; P a g eR a n k I t er . m ai n ( f or I t r ); } St r i n g [ ] f or R V = { args [1]+ \" / Da t a \" + ti m e s , ar g s [1]+ \" / F i n al R an k \"} ; P a g eR a n k V i e w er . m ai n ( f or R V ); } } 链式 M a p R ed u c e 任务 ¨ 基本问题 ¤ 一些复杂任务难以用一趟 M a p R ed u c e 处理过程来完成，需要将其分为多趟简单些的 M a p R ed u c e 子任务完成。如： ¤ 专利文献引用直方图统计，需要先进行被引次数统计，然后在被引次数上再进行被引直方 图统计 41 “C I T I N G ”, ”C I T E D ” 3858241, 956203 3858241, 1324234 3858241, 3398406 3858241, 3557384 3858241, 3634889 3858242, 1515701 3858242, 3319261 3858242, 3668705 3858242, 3707004 ... 1 2 （ 2, 1 ） （ 2, 3 ） 10000 1 （ 1, 1 ） （ 1, 9 ） 100000 1 （ 1, 1 ） 1000006 1 （ 1, 1 ） （ 3, 1 ） 1000007 1 （ 1, 1 ） 100001 1 1 （ 1, 1 ） 1000017 1 （ 1, 1 ） 1000026 1 （ 1, 1 ） 1000033 2 （ 2, 1 ） 1000043 1 （ 1, 1 ） 1000044 2 （ 2, 1 ） 1000045 1 （ 1, 1 ） 1000046 3 （ 3, 1 ） …… …… Ma p R e d u c e 1 Ma p R e d u c e 2 链式 M a p R ed u c e 任务 ¨ M a p R ed u c e 子任务的顺序化执行 ¤ 多个 M a p R ed u c e 子任务可以用手工逐一执行，但更方便的做法是将这些子任务穿起来，前 面 M a p R ed u c e 任务的输出作为后面 M a p R ed u c e 的输入，自动地完成顺序化的执行 , 如： m a p r ed u c e - 1 à m a p r ed u c e - 2 à m a p r ed u c e - 3 à ... 42 M a p R ed u c e 作业控制执行代码： C on f i g u r a t i on j ob c on f = n e w C on f i g u r a t i on ( ) ; j ob = n e w J ob ( j ob c on f , \" i n v er t i n d e x\" ) ; j ob . s et J a r ByC l a s s ( I n v er t ed I n d e x er . c l a s s ); …… F i l eI n p u t F or m a t . a d d I n p u t P a t h ( j ob , n e w P a t h ( args [0])); F i l eO u t p u t F or m a t . s et O u t p u t P a t h ( j ob , n e w P a t h ( args [1])); j ob . w a i t F or C om p l et i on ( t r u e) ; 链式 M a p R ed u c e 任务 ¨ M a p R ed u c e 子任务的顺序化执行 ¤ 同样，链式 M a p R ed u c e 中的每个子任务需要穿件独立的 j ob c on f ，并按照前后子任务间的输 入输出关系设置输入输出路径，而任务完成后所有中间过程的输出结果路径都可以删除掉。 43 Co n f i g u r a t i o n job co n f 1 = n e w C o n f ig u r a t io n ( ) ; jo b 1 = n e w J o b ( jo b c o n f 1 , “ J o b 1 \") ; jo b 1 . s e t J a r B y C la s s ( jo b c la s s 1 ) ; …… Fi l e In p u tFo r m a t.a d d In p u tP a th (j o b 1 , in p a t h 1 ); Fi l e O u tp u tFo r m a t.s e tO u tp u tP a th (j o b 1 , out pat h1 ); jo b 1 . w a it F o r C o m p le t io n ( t r u e ) ; Co n f i g u r a t i o n job co n f 2 = n e w C o n f ig u r a t io n ( ) ; jo b 2 = n e w J o b ( jo b c o n f 2 , “ J o b 2 \") ; jo b 2 . s e t J a r B y C la s s ( jo b c la s s 2 ) ; …… Fi l e In p u tFo r m a t.a d d In p u tP a th (j o b 2 , out pat h1 ); Fi l e O u tp u tFo r m a t.s e tO u tp u tP a th (j o b 2 , out pat h2 ); jo b 2 . w a it F o r C o m p le t io n ( t r u e ) ; Co n f i g u r a t i o n job co n f 3 = n e w C o n f ig u r a t io n ( ) ; jo b 3 = n e w J o b ( jo b c o n f 3 , “ J o b 3 \") ; jo b 3 . s e t J a r B y C la s s ( jo b c la s s 3 ) ; …… Fi l e In p u tFo r m a t.a d d In p u tP a th (j o b 3 , out pat h2 ); Fi l e O u tp u tFo r m a t.s e tO u tp u tP a th (j o b 3 , out pat h3 ); jo b 3 . w a it F o r C o m p le t io n ( t r u e ) ; 链式 M a p R ed u c e 任务 ¨ M a p R ed u c e 前处理和后处理步骤的链式执行 ¤ 一个 M a p R ed u c e 作业可能会有一些前处理和后处理步骤，比如，文档倒排索 引处理前需要一个去除 St op - w or d 的前处理，倒排索引处理后需要一个变形 词后处理步骤 (making , made à m a k e) 。将这些前后处理步骤实现为单独的 M a p R ed u c e 任务可以达到目的，但将增加很多 I /O 操作，因而效率不高。 ¤ 一个办法是在核心的 Map 和 R ed u c e 过程之外，把这些前后处理步骤实现为一 些辅助的 Map 和 R ed u c e 过程，将这些辅助的 Map 和 R ed u c e 过程与核心的 Map 和 R ed u c e 过程合并为一个过程链，从而完成整个作业。 44 链式 M a p R ed u c e 任务 ¨ M a p R ed u c e 前处理和后处理步骤的链式执行 ¤ H a d oop 提供了链式 M a p p er ( or g . a p a c h e . h a d oop . m a p r ed . l i b . C h a i n M a p p er ) 和链式 R ed u c er ( or g . a p a c h e . h a d oop . m a p r ed . l i b . C h a i n R ed u c er ) 来完成这种处理 ¤ C h a i n M a p p er 和 C h a i n R ed u c er 分别提供了 a d d M a p p er 方法加入一系列 M a p p er ： Ch ai n M ap p e r .a d d M a p p er （ …… ） ; Ch ai n R e d u c e r .a d d M a p p er （ …… ） p u b l i c st a t i c vo i d addM apper ( Jo b C o n f jo b , // 主作业 C l a ss< ? e xt e n d s M a p p e r > m cl a ss , // 待加入的 ma p c l a s s C l a ss< ? > i n p u t K e yC l a ss , // 待加入的 ma p 输入键 cl ass C l a ss< ? > i n p u t V a l u e C l a ss , // 待加入的 ma p 输入键值 cl ass C l a ss< ? > o u t p u t K e yC l a ss , // 待加入的 ma p 输出键 cl ass C l a ss< ? > o u t p u t V a l u e C l a ss , // 待加入的 ma p 输出键值 cl ass bool ean b yV a l u e // 指示键 / 值是否应按值传递给链中的下一个 Ma p p e r Jo b C o n f ma p p e rC o n f // 待加入的 ma p 的 conf ) t h r o w s I O E xce p t i o n 45 链式 M a p R ed u c e 任务 ¨ M a p R ed u c e 前处理和后处理步骤的链式执行 ¤ 设有一个完整的 M a p R ed u c e 作业，由 M a p 1 , M a p 2 , R ed u c e , M a p 3 , M a p 4 构成。 Co n f ig u r a t io n co n f = n e w C o n f i g u r a t i o n ( ) ; Jo b j o b = n e w Jo b ( co n f ); j o b . se t Jo b N a m e (“ C h a i n Jo b ”); j o b . se t I n p u t F o r m a t ( T e xt I n p u t F o r m a t . cl a ss ); j o b . se t O u t p u t F o r m a t ( T e xt O u t p u t F o r m a t . cl a ss ); F i l e I n p u t F o r m a t . se t I n p u t P a t h s (j o b , i n ); F i l e O u t p u t F o r m a t . se t O u t p u t P a t h (j o b , o u t); Jo b C o n f ma p 1 C o n f = n e w Jo b C o n f ( f a l se ) ; Ch a i n M a p p e r .a d d Ma p p e r (j o b , Ma p 1 .c la s s , L o n g W r i t a b l e . cl a ss , T e xt . cl a ss , T e xt . cl a ss , T e xt . cl a ss , tru e , ma p 1 C o n f); Jo b C o n f ma p 2 C o n f = n e w Jo b C o n f ( f a l se ) ; Ch a i n M a p p e r .a d d Ma p p e r (j o b , Ma p 2 .c la s s , T e xt . cl a ss , T e xt . cl a ss , L o n g W r i t a b l e . cl a ss , T e xt . cl a ss , tru e , ma p 2 C o n f); 46 链式 M a p R ed u c e 任务 ¨ M a p R ed u c e 前处理和后处理步骤的链式执行 J ob C on f r ed u c eC on f = ne w J ob C on f ( f a l s e) ; Ch a i n R ed u c er .se tR e duc e r ( j ob , Re d u c e . c l a s s , L on g W r i t a b l e . c l a s s , T e xt . c l a s s , T e xt . c l a s s , T e xt . c l a s s , t r u e , r ed u c eC on f ); J ob C on f m a p 3 C on f = n e w J ob C on f ( f a l s e) ; Ch a i n R ed u c er .a ddM a ppe r ( j ob , Map 3 . c l as s , T e xt . c l a s s , T e xt . c l a s s , L on g W r i t a b l e . c l a s s , T e xt . c l a s s , t r u e , m a p 3 C on f ) ; J ob C on f m a p 4 C on f = n e w J ob C on f ( f a l s e) ; Ch a i n R ed u c er .a ddM a ppe r ( j ob , Map 4 . c l as s , L on g W r i t a b l e . c l a s s , T e xt . c l a s s , L on g W r i t a b l e . c l a s s , T e xt . c l a s s , t r u e , m a p 4 C on f ) ; J ob C l i en t . r u n J ob ( j ob ) ; 47 C h a i n R ed u c er . s et R ed u c er () 方法必须在 C h a i n R ed u c er 最开始的地方使用，其后方可加入后续的辅助处理 M a p p er ；另一个需要注意的问题是，这些链式 M a p p er 和 R ed u c er 之间传递的键值对数据类型必须保持前 后一致。 全局参数 / 数据文件的传递 ¨ 全局作业参数的传递 ¤ 为了能让用户灵活设置某些作业参数，避免作业参数在程序中的硬编码，一个 M a p R ed u c e 计算任务可能需要在执行时从命令行输入这些作业参数，并将这些参数 传递给各个计算节点。 ¤ 比如 ，对两个关系进行自然连接时 程序用硬编码方式指定第一个数据列为 j oi n 的主 键。 但为了要实现一个具有一定通用性的程序，可以任意指定一个列为 j oi n 主键的 话，就需要在程序运行时在命令行中指定 j oi n 主键所在的数据列。然后该输入参数 可以作为一个属性保存在 C on f i g u r a t i on 对象中，并允许 Ma p 和 R ed u c e 节点从 C on f i g u r a t i on 对象中获取和使用该属性值。 48 全局参数 / 数据文件的传递 ¨ 全局作业参数的传递 C on f i g u r a t i on 类专门提供以下用于保存和获取属性的方法： ¤ p u b l i c v oi d s et ( St r i n g n a m e , St r i n g v a l u e) // 设置字符串属性 ¤ p u b l i c St r i n g g et ( St r i n g n a m e) // 读取字符串属性 ¤ p u b l i c St r i n g g et ( St r i n g n a m e , St r i n g d ef a u l t V a l u e ) // 读取字符串属性 ¤ p u b l i c v oi d s et Bool ea n ( St r i n g n a m e , b ool ea n v a l u e) // 设置布尔属性 ¤ pu bl i c b ool ea n g et Bool ea n ( St r i n g n a m e , b ool ea n d ef a u l t V a l u e ) // 读取布尔属性 ¤ p u b l i c v oi d s et I n t ( St r i n g n a m e , int v a l u e) // 设置整数属性 ¤ pu bl i c int g et I n t ( St r i n g n a m e , int d ef a u l t V a l u e ) // 读取整数属性 ¤ p u b l i c v oi d s et L on g ( St r i n g n a m e , l on g v a l u e) // 设置长整数属性 ¤ p u b l i c l on g g et L on g ( St r i n g n a m e , l on g d ef a u l t V a l u e ) // 读取长整数属性 ¤ p u b l i c v oi d s et F l oa t ( St r i n g n a m e , f l oa t v a l u e) // 设置浮点数属性 ¤ p u b l i c f l oa t g et F l oa t ( St r i n g n a m e , f l oa t d ef a u l t V a l u e ) // 读取浮点数属性 ¤ p u b l i c v oi d s et St r i n g s ( St r i n g n a m e , St r i n g . . . v a l u es ) // 设置一组字符串属性 ¤ p u b l i c St r i n g [ ] g et St r i n g s ( St r i n g n a m e , St r i n g . . . d ef a u l t V a l u e ) // 读取一组字符串属性 ¨ 需要说明的是， s et St r i n g s 方法将把一组字符串转换为用“ , ”隔开的一个长字符串，然后 g et St r i n g s 时自动再根据 “ , ” spl i t 成一组字符串，因此，在该组中的每个字符串都不能包含“ , ”，否则会出错。 49 全局参数 / 数据文件的传递 ¨ 全局作业参数的传递 例：专利文献数据集 J oi n 时主键所在数据列参数的设置 C on f i g u r a t i on c on f = n e w C on f i g u r a t i on ( ) ; J ob j ob = n e w J ob ( c on f , \" n a t u r a l J oi n J ob \" ); ... // 将第三个输入参数设置为 J oi n Ke y 属性 j ob . g et C on f i g u r a t i on (). s et I n t (\" J oi n K e yC ol I d x \", I n t eg er . p a r s eI n t ( args [2])); …… j ob . w a i t F or C om p l et i on ( t r u e) ; 50 全局参数 / 数据文件的传递 ¨ 全局作业参数的传递 ¤ 在 m a p p er 类的初始化方法 s et u p ( ) 中从 c on f i g u r a t i on 对象中读出属性 pu bl i c s t at i c cl as s Map C l as s e xt en d s M a p p er < T e xt , T e xt , T e xt , T e xt > { int j oi n _k e y_c ol _i d x ; p r ot ec t ed v oi d se t u p ( M a p p er . C on t e xt c on t e xt ) { C on f i g u r a t i on j ob c on f = c on t e xt . g et C on f i g u r a t i on () ； j oi n _k e y_c ol _i d x = j ob c on f . g et I n t (“ J oi n K e yC ol I d x ”, - 1); // 无值时置 为 - 1 } p r ot ec t ed v oi d ma p ( T e xt k e y , T e xt v a l u e , C on t e xt c on t e xt ) th r o w s I O E x c ep t i on , I n t er r u p t ed E x c ep t i on { // 使用 j oi n _k e y_c ol _i d x 完成数据处理； …… } } 51 全局参数 / 数据文件的传递 ¨ 全局作业参数的传递 ¤ 同样需要时在 r ed u c er 类的初始化方法 s et u p ( ) 中从 c on f i g u r a t i on 对象中读出属性 pu bl i c s t at i c cl as s Re d u c e C l a s s e xt en d s R ed u c er < T e xt , T e xt , T e xt , T e xt > { in t j oi n _k e y_c ol _i d x ; p r ot ec t ed v oi d se tup ( M a p p er . C on t e xt c on t e xt ) { C on f i g u r a t i on j ob c on f = c on t e xt . g et C on f i g u r a t i on () ； j oi n _k e y_c ol _i d x = j ob c on f . g et I n t (“ J oi n K e yC ol I d x ”, - 1) ; // 无值时置为 - 1 } p r ot ec t ed v oi d r ed u c e( T e xt k e y , T e xt v a l u e , C on t e xt c on t e xt ) thr o ws I O E x c ep t i on , I n t er r u p t ed E x c ep t i on { // 使用 j oi n _k e y_c ol _i d x 完成数据处理； …… } } 52 全局参数 / 数据文件的传递 ¨ 全局数据文件的传递 ¤ 有时候一个 M a p R ed u c e 作业可能会使用一些较小的并且需要复制到各个节点的数据文 件。为此，可以使用 D i s t r i b u t ed C a c h e 文件传递机制，先将这些文件传送到 D i s t r i b u t ed C a c h e 中，然后各个节点从 D i s t r i b u t ed C a c h e 中将这些文件并复制到本地的文件 系统中使用。具体使用时，为提供访问速度，可将这些较小的文件数据读入内存。 ¤ J ob 类中： p u b l i c v oi d a d d C a c h eF i l e ( U RI ur i ) ：将一个文件放到 d i s t r i b u t ed c a c h e f i l e 中 ¤ M a p p er 或 R ed u c er 的 c on t e xt 类中： pu blic P at h [ ] g et L oc a l C a c h eF i l es () : 获取设置在 d i s t r i b u t ed c a c h e f i l es 中的文件路径，以便 能将这些文件读入到每个节点内存中 53 全局参数 / 数据文件的传递 ¨ 全局数据文件的传递 ¤ 在作业 C on f i g u r a t i on 时将文件存入 D i s t r i b u t ed C a c h e ： …… C on f i g u r a t i on c on f = g et C on f (); J ob j ob = J ob . g et I n s t a n c e ( c on f , \" w or d c ou n t 2 . 0 \" ) ; ; // 将命令行参数中的 r ea m i n g s A r g s 列表里指定的文件依次放置 到 d i s t r i b u t ed c a c h e f i l e 中 L i s t < St r i n g > ot h er A r g s = n e w A r r a yL i s t < St r i n g > ( ) ; f or ( i n t i = 0 ; i < r em a i n i n g A r g s . l en g t h ; ++ i ) { if (\" - sk i p\" . eq u a l s ( r em a i n i n g A r g s [ i ])) { j ob . a d d C a c h eF i l e (n e w P ath ( r em a i n i n g A r g s [+ + i ]). t oU r i ()); j ob . g et C on f i g u r a t i on (). s et Bool ea n (\" w or d c ou n t . s k i p . p a t t er n s \" , t r u e) ; } el s e { ot h er A r g s . add ( r em a i n i n g A r g s [ i ]); } } 54 全局参数 / 数据文件的传递 ¨ 全局数据文件的传递 pu bl i c stati c c l ass Ma p C l a s s e xt en d s M a p p er < T e xt , T e xt , T e xt , T e xt > { p u b l i c v oi d se t u p ( M a p p er . C on t e xt c on t e xt ) th r o w s I O E x c ep t i on , I n t er r u p t ed E x c ep t i on c on f = c on t e xt . g et C on f i g u r a t i on (); c a s eSen s i t i v e = c on f . g et Bool ea n (\" w or d c ou n t . c a s e . s en s i t i v e \" , t r u e) ; if ( c on f . g et Bool ea n (\" w or d c ou n t . s k i p . p a t t er n s \" , t r u e) ) { U RI [ ] p a t t er n s U RI s = J ob . g et I n s t a n c e ( c on f ) . g et C a c h eF i l es (); if ( p a t t er n s U RI s != null) { f or ( U RI p a t t er n s U RI : p a t t er n s U RI s ) { Pa t h p a t t er n s P a t h = n e w P a t h ( p a t t er n s U RI . g et P a t h ()); St r i n g p a t t er n s F i l eN a m e = p a t t er n s P a t h . g et N a m e (). t oSt r i n g (); p a r s eSk i p F i l e ( p a t t er n s F i l eN a m e ); } } } } 55 其它处理技术 ¨ 查询任务相关信息 ¤ 可以通过 C on f i g u r a t i on 对象，使用预定义的属性名称查询计算作业相关的信息。 56 其它处理技术 ¨ 输入输出到关系数据库 ¤ M a p R ed u c e 用于处理存储在 HDF S 中的大规模数据，但现实环境中有很多应用数据保存在关 系数据库中，因此， H a d oop 提供了访问关系数据库的能力以便在需要时能用 M a p R ed u c e 技 术处理关系数据库中的数据。这在基于 M a p R ed u c e 进行联机数据分析处理时尤为有用。 ¤ O L T P ( on l i n e t r a n s a c t i on p r oc es s i n g ) n 联机事务处理：主要是关系数据库应用系统中前台常规的各种事务处理 ¤ O L A P ( on l i n e a n a l yt i c a l p r oc es s i n g ) n 联机分析处理：主要是进行基于数据仓库的后台数据分析和挖掘，提供 优化的客户服务和 运营决 策支持 ¤ OL T P 与 OL A P 一般采用分离的数据库，前者数据库负责大量的常规的事务处理，后者用数据 仓库应对大量的数据分析处理负载。 57 其它处理技术 58 OL T P 数据库 OL A P 数据仓库 ETL E xt ra c t ：从 OL T P 数据库中抽取事务数据 T ra n s f o rm ：转换为数据仓库中的数据格式 L oa d ：装载到数据仓库中 企业数据库应用系统 问题： OL AP 端基于关系数据库的数据仓库解决方案，在数据量巨大 的情况下，复杂数据分析和挖掘处理的负载很大，速度性能跟不上 其它处理技术 59 OL T P 数据库 OL A P ETL 企业数据库应用系统 解决方案：提供基于 M a p R ed u c e 大规模数据并行处理的 OL AP ！ 问题：如何从 M a p R ed u c e 访问关系数据库？ Ha d o o p Ma p R e d u c e 数据仓库 其它处理技术 ¨ 输入输出到关系数据库 ¤ 从数据库中输入数据 n H a d oop 提供了相应的从关系库查询和读取数据的接口 ( or g . a p a c h e . h a d oop . m a p r ed . l i b . d b .*) n D BI n p u t F or m a t ：提供从数据库读取数据的格式 n D BW r i t a b l e ：提供读取数据记录的接口 ¤ 虽然 H a d oop 允许用以上接口从数据库中直接读取数据记录作为 M a p R ed u c e 的输入，但处理 效率不理想，因此，仅适合读取小量数据记录的计算和应用，不适合 OL A P 数据仓库大量数 据的读取处理。 ¤ 读取大量数据记录一个更好的解决办法是，用数据库中的 Du mp 工具将大量待分析数据输出 为文本数据文件，并上载到 HDF S 中进行处理。 60 其它处理技术 ¨ 输入输出到关系数据库 ¤ 向数据库中输出计算结果 n 基于数据仓库的数据分析和挖掘输出结果的数据量一般不会太大，因而可能适合于直接向数据库写入。 H a d oop 提供了相应的向关系库直接输出计算结果的编程接口 n D BO u t p u t F or m a t ：提供向数据库输出数据的格式 n D BC on f i g u r a t i on ：提供数据库配置和创建连接的接口 ¤ 创建数据库连接 n D BC on f i g u r a t i on 类中提供了一个静态方法创建数据库连接 : n p u b l i c s t a t i c v oi d c on f i g u r eD B ( J ob j ob , St r i n g d r i v er C l a s s , St r i n g dbU r l , St r i n g u s er N a m e , St r i n g pass w d ) ¤ 指定写入的数据表和字段 n D BO u t p u t F or m a t 中提供了一个静态方法完成这一工作： n p u b l i c s t a t i c v oi d s et O u t p u t ( J ob j ob , St r i n g t a b l eN a m e , St r i n g . . . f i el d N a m es ) 61 其它处理技术 ¨ 输入输出到关系数据库 ¤ 向数据库中输出计算结果 ¤ C on f i g u r a t i on 示例 C on f i g u r a t i on c on f = n e w C on f i g u r a t i on ( ) ; J ob j ob = n e w J ob ( c on f , J ob C l a s s . c l a s s ); j ob . s et O u t p u t F or m a t ( D BO u t p u t F or m a t . c l a s s ); D BC on f i g u r a t i on . c on f i g u r eD B ( j ob , “ c om . m ys q l . j d b c . D r i v er ”, “ j d b c : m ys q l : // d b . h os t . c om / my d b ” , “ u s er n a m e” , “ p a s s w or d ” ) D BO u t p u t F or m a t . s et O u t p u t ( j ob , “ E v en t s ” , “ ev en t _i d ”, “ t i m e” ) ; // 向 E v en t s 表 输出 ev en t _i d 和 ti m e 字 段 62 其它处理技术 ¨ 输入输出到关系数据库 ¤ 向数据库中输出计算结果 n 实现 D BW r i t a b l e n 为了实际完成向数据库中数据写入，程序员要实现 D BW r i t a b l e ： pu bl i c c l ass E v en t s D BW r i t a b l e i m p l em en t s W r i t a b l e , D BW r i t a b l e { p r i v a t e int id ; p r i v a t e l on g t i m es t a m p ; p u b l i c v oi d w r i t e( Da t a O u t p u t ou t ) t h r o w s I O E x c ep t i on { ou t . w r i t eI n t (i d); ou t . w r i t eL on g ( t i m es t a m p ) ; } p u b l i c v oi d r ea d F i el d s ( Da t a I n p u t in) t hr o w s I O E x c ep t i on { id = i n . r ea d I n t ( ) ; t i m es t a m p = i n . r ea d L on g (); } p u b l i c v oi d wr i t e ( Pr e pa r e dSt a t e m e nt st a t e m e n t ) th r o w s SQ L E x c ep t i on { s t a t em en t . s et I n t (1, i d); s t a t em en t . s et L on g ( 2 , t i m es t a m p ) ; } p u b l i c v oi d r ea d F i el d s ( R es u l t Set r es u l t Set ) th r o w s SQ L E x c ep t i on { id = r es u l t Set . g et I n t (1); t i m es t a m p = r es u l t Set . g et L on g (2); } // 除非使用 D BI n p u t F or m a t 直接从数据库输入数据 , 否则 r ea d F i el d s 方法不会被调用 } 63 TH A NK YO U","libVersion":"0.2.4","langs":""}