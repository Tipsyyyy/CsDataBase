{"path":"课程/金融大数据/课件/16 Spark简介.pdf","text":"Sp a r k 系统简介 摘要 p 为什么会有 Sp a r k ？ p Sp a r k 的生态圈 p Sp a r k 的基本构架和组件 p Sp a r k 的程序执行过程 p Sp a r k 的技术特点 2 摘要 p 为什么会有 Sp a r k ？ p Sp a r k 的生态圈 p Sp a r k 的基本构架和组件 p Sp a r k 的程序执行过程 p Sp a r k 的技术特点 3 为什么会有 Sp a r k ？ ¨ M a p R ed u c e 计算模式的缺陷 ¤ O r i g i n a l l y d es i g n ed f or h i g h - t h r ou g h p u t b a t c h d a t a p r oces s i n g , n ot g ood a t l o w l a t en c y ¤ N eed s t o s t or e d a t a i n t o H D F S b et w een j ob s , i n ef f i ci en t f or d a t a s h a r i n g i n i t er a t i v e com p u t i n g ¤ N ot d es i g n ed f or m a k i n g g ood u s e of m em or y , h a r d t o a c h i ev e h i g h p er f or m a n ce ¤ M a p R ed u ce i s n ot e xp r es s i v e f or com p l e x com p u t i n g p r ob l em s , s u c h a s g r a p h com p u t i n g , i t er a t i v e com p u t i n g 4 为什么会有 Sp a r k ？ ¨ M a p R ed u c e 计算模式的缺陷 ¤ 2 阶段固定模式，磁盘计算大量 I /O 性能低下 5 为什么会有 Sp a r k ？ ¨ 2013 年大数据计算模式的新变化 ¤ 由于 H a d oop 计算框架对很多非批处理大数据问题的局限性，除了原有的基 于 H a d oop H Ba s e 的数据存储管理模式和 M a p R ed u c e 计算模式外，人们开始关 注大数据处理所需要的其他各种计算模式和系统。 ¤ 后 H a d oop 时代新的大数据计算模式和系统出现，其中尤其 以内存计算为核 心、集诸多计算模式之大成的 Sp a r k 生态系统 的出现为典型代表。 6 ü 大数据查询分析 计算 ü 批处理计算 ü 流式计算 ü 迭代计算 ü 图计算 ü 内存计算 为什么会有 Sp a r k ？ ¨ Sp a r k 是加州大学伯克利分校 AM P 实验室 2009 年开发的通用内存并 行计算框架。 2010 年开放源代码。 ¨ Sp a r k 于 2013 年 6 月进入 Ap a c h e 成为孵化项目， 8 个月后成为 Ap a c h e 顶级项目。 ¨ 围绕 Sp a r k 推出了 Sp a r k SQ L 、 Sp a r k St r ea m i n g 、 ML l i b 和 Gr aph X 等组 件，逐渐形成大数据处理一站式解决平台。 ¨ 最新版本 ¤ 2023 年 9 月 13 日， Sp a r k 3.5.0 7 Sp a r k 发展历史 8 2019 Sp a r k 3. 0 为什么会有 Sp a r k ？ ¨ Sp a r k 基于内存计算思想提高计算性能 ¤ Sp a r k 提出了一种 基于内存的弹性分布式数据集 ( RD D ) ，通过对 RD D 的一系列操作完成计算任 务，可以大大提高性能 ¤ 同时一组 RD D 形成可执行的有向无环图 DA G ，构成灵活的计算流图 ¤ 覆盖多种计算模式 9 为什么会有 Sp a r k ？ ¨ 弹性分布式数据集 R es i l i en t D i s t r i b u t ed D a t a s et s ( RD D s ) ¤ Sp a r k 的主要抽象是提供一个弹性分布式数据集 ( RD D ) ， RD D 是指 能横跨集群 所有节点进行并行计算的分区元素集合 。 RD D 可以从 H a d oop 的文件系统中 的一个 文件中创建而来 ( 或其他 H a d oop 支持的文件系统 ) ，或者从一个已有 的 Sc a l a 集合转换得到 。 ¤ Sp a r k 使用 RD D 以及对应的 T r a n s f or m /A c t i on 等操作算子执行分布式计算。 10 为什么会有 Sp a r k ？ ¨ 弹性分布式数据集 R es i l i en t D i s t r i b u t ed D a t a s et s ( RD D s ) ¤ 基于 RD D 之间的 依赖关系组成 l i n ea g e ， 通过 重计算以及 c h ec k p oi n t 等机制 来保 证整个分布式计算的 容错性 。 ¤ 只读、可分区 ，这个数据集的 全部或部分可以缓存在内存中 ，在多次计算 间重用， 弹性 是指内存不够时可以与磁盘进行交换。 11 为什么会有 Sp a r k ？ 12 为什么会有 Sp a r k ？ 13 为什么会有 Sp a r k ？ 14 摘要 p 为什么会有 Sp a r k ？ p Sp a r k 的生态圈 p Sp a r k 的基本构架和组件 p Sp a r k 的程序执行过程 p Sp a r k 的技术特点 15 Sp a r k 生态圈 16 Sp a r k v s . H a d oop ¨ Sp a r k 把中间数据放在内存中，迭代运算效率高； M a p R ed u c e 中计算结果需要 落地，保存到磁盘上。 Sp a r k 支持 DA G 图的分布式并行计算，减少了迭代过程 中数据的落地，提高了处理效率。 ¨ Sp a r k 容错性高。 Sp a r k 引入了 RD D 的抽象，它是分布在一组节点中的只读对象 集合，这些集合是弹性的。在 RD D 计算时可以通过 C h ec k P oi n t 来实现容错，而 C h ec k P oi n t 有两种方式： C h ec k P oi n t Data 和 L og g i n g The U p d a t es 。 ¨ Sp a r k 更加通用。 H a d oop 只提供了 Map 和 R ed u c e 两种操作， Sp a r k 提供的数据集 操作类型很多。另外各个处理节点之间的通信模型不再像 H a d oop 只有 Sh u f f l e 一种，用户可以命名、物化、控制中间结果的存储、分区等。 17 Sp a r k v s . H a d oop 18 Sp a r k v s . H a d oop 19 Sp a r k 和 H a d oop 的协作性 ¨ H a d oop 的优势 ¨ Sp a r k 的优势 20 Sp a r k 和 H a d oop 的协作性 21 Sp a r k 和 H a d oop 的协作性 22 Sp a r k C or e ¨ 提供有向无环图 DA G 的分布式并行计算框架，并提供 Cac h e 机制来支持多次迭 代计算或者数据共享。 ¨ 引入 RD D 抽象，它是分布在一组节点中的只读对象集合，这些集合是弹性的， 如果数据集一部分丢失，则可以根据 L i n ea g e “血统”对它们进行重建，保证 了数据的高容错性。 ¨ 移动计算而非移动数据， RD D P a r t i t i on 可以就近读取分布式文件系统中的数据 块到各个节点内存中进行计算。 ¨ 使用多线程池模型来减少 tas k 启动开销 ¨ 采用容错的、高可伸缩性的 ak k a 作为通信框架 23 Sp a r k St r ea m i n g ¨ Sp a r k St r ea m i n g 是一个对实时数据流 进行高吞吐量 、容错处理的流式处理系统， 可以对多种数据源（如 Ka f k a 、 Flume 、 T w i t t er 、 Zer o 和 T C P 套接字）进行类似 Map 、 R ed u c e 和 J oi n 等复杂操作，并将结果保存到外部文件系统、数据库或应 用到实时仪表盘。 24 Sp a r k St r ea m i n g ¨ Sp a r k St r ea m i n g 的工作机制是对数据流进行分片，使用 Sp a r k 计算引擎处理分 片数据，并返回相应分片的计算结果。 ¨ Sp a r k St r ea m i n g 提供的基本流式数据抽象叫 d i s c r et i z ed s t r ea m ，或称 D St r ea m 。 D St r ea m 由一系列连续的 RD D 表示（每个数据流分片被表示为一个 RD D ），对 D St r ea m 的操作被转换成对相应 RD D 序列的操作。 25 Sp a r k St r ea m i n g 26 Sp a r k SQ L ¨ Sh a r k ，即 Hi v e on Sp a r k ，本质上是通过 Hi v e 的 HQ L 解析，把 HQ L 翻 译成 Sp a r k 上的 RD D 操作，然后通过 Hi v e 的 m et a d a t a 获取数据库里的 表信息，实际 HDF S 上的数据和文件，会由 Sh a r k 获取并放到 Sp a r k 上 运算。与 Hi v e 完全兼容。 ¨ 2014. 7. 1 ， Sh a r k à Sp a r k SQ L ¨ Sp a r k SQ L ，允许直接处理 RD D ，同时也可查询例如在 Hi v e 上存在的 外部数据。能够统一处理关系表和 RD D ，使得开发人员可以轻松地 使用 SQ L 命令进行外部查询，同时进行更复杂的数据分析。 27 Sp a r k SQ L ¨ Sp a r k SQ L 是一个用来处理结构化数据的分布式 SQ L 查询引擎， 具有以下几个特点： ¤ 与 Sp a r k 程序无缝对接 。使用集成的 A PI ， Sp a r k SQ L 允许使用 RD D 模型来查询 结构化数据，这使得在复杂程序里运行 SQ L 查询变得容易。 ¤ 统一数据访问接口 。 Sp a r k SQ L 提供统一的接口来访问各种结构化数据，包 括 Hi v e 、 P a r q u et 和 J s on 文件。 ¤ 与 Hi v e 高度兼容 。对已经存在的 Hi v e 数据、 Hi v e 查询语句和 UDF s 等， Sp a r k SQ L 都可以完美兼容，方便了应用迁移。 ¤ 使用标准链接 。 Sp a r k SQ L 可以使用工业标准 J D BC 和 O D BC 进行链接，减小了 开发人员的学习成本。 28 Sp a r k SQ L 29 Sp a r k SQ L ¨ 性能提升原因： ¤ 内存列存储（ In - M em or y C ol u m n a r St or a g e ） ： Sp a r k SQ L 的表数据在内存中 存储不是采用原生态的 JVM 对象存储方式，而是采用内存列存储； ¤ 字节码生成技术（ Byt ec od e G en er a t i on ） ： Sp a r k 1 . 1 . 0 在 C a t a l ys t 模块的 e xp r es s i on s 增加了 c od eg en 模块，使用动态字节码生成技术，对匹配的表达式 采用特定的代码动态编译。另外对 SQ L 表达式都作了 CG 优化， CG 优化的实 现主要还是依靠 Sc a l a 2 . 1 0 的运行时反射机制（ r u n t i m e r ef l ec t i on ）； ¤ Sc a l a 代码优化 ： Sp a r k SQ L 在使用 Sc a l a 编写代码的时候，尽量避免低效的、 容易 GC 的代码；尽管增加了编写代码的难度，但对于用户来说接口统一。 30 Sp a r k MLl i b p M L O p t i m i z er 会选择它认为最适合的已经在内部实现好了的机器学习算法和相关参数，来处理 用户输入的数据，并返回模型或别的帮助分析的结果； p ML I 是一个进行特征抽取和高级 ML 编程抽象的算法实现的 A PI 或平台； p ML l i b 是 Sp a r k 实现一些常见的机器学习算法和实用程序，包括分类、回归、聚类、协同过滤、 降维以及底层优化，算法可以进行扩充； p M L Ru n t i m e 基于 Sp a r k 计算框架，将 Sp a r k 的分布式计算应用到机器学习领域。 ML l i b 面向 RD D 。 31 Sp a r k MLl i b 32 Sp a r k ML ¨ 从 Sp a r k 2. 0 开始，基于 RD D 的 A PI （ sp a r k . m l l i b ）进入维护模式， 取而代之的是基于 Dat aF r am e 的 A PI （ sp a r k . m l ） ¨ Sp a r k M L 是基于 Dat aF r am e 进行机器学习 A PI 的开发，抽象层次更 高。把数据处理的流水线抽象出来，算法相当于流水线的一个组 件，可以被其他算法随意的替换，这样就让算法和数据处理的其 他流程分割开来，实现低耦合。 ¨ h t t p : //s p a r k . a p a c h e . or g /d oc s /l a t es t /m l - gu i de . h t m l 33 Gr aph X ¨ Gr a p h X 是 Sp a r k 中用于图 (e .g . W e b - G r a p h s a n d Soc i a l N et w or k s ) 和 图并行计算 ( e . g . P a g eR a n k a n d C ol l a b or a t i v e F i l t er i n g ) 的 A PI 。 ¨ Gr a p h X 的核心抽象是 R es i l i en t D i s t r i b u t ed Pr op er t y G r a p h ，一种点 和边都带属性的有向多重图。它扩展了 Sp a r k RD D 的抽象，有 Ta b l e 和 Gr a p h 两种视图，而只需要一份物理存储。两种视图都有 自己独有的操作符，从而获得了灵活操作和执行效率。 34 Gr aph X 35 摘要 p 为什么会有 Sp a r k ？ p Sp a r k 的生态圈 p Sp a r k 的基本构架和组件 p Sp a r k 的程序执行过程 p Sp a r k 的技术特点 36 Sp a r k 集群整体运行架构 37 • M a s t er n od e ：是集群部署时的 概念，是整个集群的控制器， 负责整个集群的正常运行，管 理 W or k er n od e 。 • W or k er n od e ：是计算节点，接 收主节点命令与进行状态汇报 • E x ec u t or s ：每个 W or k er 上有一 个 E x ec u t or ，负责完成 Ta s k 程序 的执行 • Sp a r k 集群部署后，需要在主 从节点启动 M a s t er 进程和 W or k er 进程，对整个集群进行 控制 Sp a r k 的基本构架和组件 38 • Sp a r k r u n s a s l i b r a r y i n y ou r p r og r a m ( 1 i n s t a n c e p er app) • Ru n t a s k s l oc a l l y or on c l u s t er • Y A RN , K u b er n et es , or s t a n d a l on e m od e • A c c es s s t or a g e s ys t em s v i a H a d oop I n p u t F or m a t A PI • C a n u s e H Ba s e , H D F S , S3 … Sp a r k 的基本构架和组件 ¨ Ap p l i c a t i o n ： 基于 Sp a r k 的用户程序，即由用户编写的调用 Sp a r k A PI 的应用 程序，它由集群上的一个驱动（ D r i v er ） 程序和多个执行器（ E x ec u t or ） 程序组 成。其中应用程序的入口为用户所定义的 main 方法。 ¨ Sp ar k C o n t e x t ： 是 Sp a r k 所有功能的主要入口点，它是用户逻辑与 Sp a r k 集群 主要的交互接口。通过 Sp ar k C o n t e x t ， 可以连接到集群管理器（ Cluster Ma n a g e r ）， 能够直接与集群 M a s t er 节点进行交互，并能够向 M a s t er 节点申 请计算资源，也能够将应用程序用到的 J A R 包或 Pyt h on 文件发送到多个执行 器（ Exec utor ） 节点上。 ¨ Cluster M a na g er ： 即集群管理器，它存在于 M a s t er 进程中，主要用来对应用 程序申请的资源进行管理。 39 Sp a r k 的基本构架和组件 ¨ Wo r k e r N o d e ： 任何能够在集群中运行 Sp a r k 应用程序的节点。 ¨ Ta s k ： 由 Sp ar k C o n t e x t 发送到 Exec utor 节点上执行的一个工作单元。 ¨ Dr iv er ： 也即驱动器节点，它是一个运行 Ap p l i c a t i o n 中 ma i n () 函数并创建 Sp ar k C o n t e x t 的进程。 Dr iv er 节点也负责提交 Jo b ， 并将 Jo b 转化为 Ta s k ， 在各个 Exec utor 进程间协调 Ta s k 的调度。 Dr iv er 节点可以不运行于集群节点机器上。 ¨ Exec utor ： 也即执行器节点，它是在一个在工作节点（ Wo r k e r N o d e ） 上为 Ap p l i c a t i o n 启动的进程，它能够运行 Ta s k 并将数据保存在内存或磁盘存储中， 也能够将结果数据返回给 Dr iv er 。 40 Sp a r k 的基本构架和组件 ¨ 在 Sp a r k 应用程序执行过程中， D r i v er 和 W or k er 扮演着最重要的角色 ¤ D r i v er 是应用执行起点，负责作业调度 ¤ W or k er 管理计算节点及创建并行处理任务 ¤ Ca c h e 存储中间结果等 ¤ In pu t D at a 为输入数据 41 Sp a r k 应用程序的组成结构 42 Sp a r k 应用程序的组成结构 43 ¨ A p p l i c a t i on ：基于 Sp a r k 的应用程序，包含 了一个 D r i v er Pr og r a m 和多个 e x ec u t or （ w or k er 中） ¨ J ob ：包含多个 Ta s k 的并行计算，由 Sp a r k A c t i on 催生 ¨ St a g e ： J ob 拆分成多组 Ta s k ，每组任务被称 为 St a g e ，也可称为 T a s k Set ¨ Ta s k ：基本程序执行单元，在一个 E x ec u t or 上执行 Sp a r k 应用程序的组成结构 ¨ Sp a r k C on t e xt ： Sp a r k C on t e xt 由用户程序启动，是 Sp a r k 运行的核 心模块，它对一个 Sp a r k 程序进行了必要的初始化过程，其中包 括了： ¤ 创建 Sp a r k C on f 类的实例 ：这个类中包含了用户自定义的参数信息和 Sp a r k 配 置文件中的一些信息等等 ( 用户名、程序名、 Sp a r k 版本等 ) ¤ 创建 Sp a r k E n v 类的实例 ：这个类中包含了 Sp a r k 执行时所需要的许多环境对 象，例如底层任务通讯的 Ak k a A c t or Sys t em 、 b l oc k m a n a g er 、 s er i a l i z er 等 ¤ 创建调度类的实例 ： Sp a r k 中的调度分为 T a s k Sc h ed u l er 和 D A G Sc h ed u l er 两种， 而它们的创建都在 Sp a r k C on t e xt 的初始化过程中。 44 Sp a r k D r i v er 的组成 45 • D r i ve r ：执行 A p p l i ca t i o n 的 ma i n () 函数并创建 S p a r kC o n t e xt 。 • RDD ： Sp a r k 基本计算单元，一组 RDD 形成可执行的有向无环图（操作主 要有： T r a n sf o r m a t i o n 和 A ct i o n ） • D A G S ch e d u l e r ：根据 Jo b 构建的基于 St a g e 的 DAG ，并提交 St a g e 给 T a skS ch e d u l e r • T a skS ch e d u l e r ：将 T a sk 分发给 E xe cu t o r 执行 • S p a r kE n v ： 线程级别 运行环境，存储运行时的重要组件的引用，创建并包 含了： • M a p O u t P u t T r a cke r ：存储 Sh u f f le 元信息 • B r o a d ca st M a n a g e r ：控制广播变量并存储其元信息 • B l o ckM a n a g e r ：存储管理、创建和查找块 • M e t r i csS yst e m ：监控运行时性能指标信息 • S p a r kC o n f ：存储配置信息 W or k er n od e 的结构 46 ¨ 在 St a n d a l on e 模式中， E x ec u t or Ba c k en d 被实例化成 C oa r s eG r a i n ed E x ec u t or Ba c k en d 进程。 ¨ Sp a r k 是一个多线程模型。 C oa r s eG r a i n ed E x ec u t or Ba c k en d 进程包含一个 E x ec u t or 对象，该对象持有一个线 程池，每个线程可以执行一个 ta s k 。 同一个 E x ec u t or 进程内，多个 ta s k 之间可以共享内存资源。 ¨ 对同一个 A p p l i c a t i on ， 它在一个 W or k er 上只能拥有一个 E x ec u t or ， W or k er 与 E x ec u t or 之间是一一对应的关系， 而每个 W or k er n od e 可以有多个 W or k er 。 ¨ W or k er 通过持有 E x ec u t or Ru n n er 对象来控制 C oa r s eG r a i n ed E x ec u t or Ba c k en d 的启停。 此处 Ca c h e 部分即为 Sp a r k 编程模型 中对 RD D 进行内存持久化存储的部位。 Sp a r k 调度器 ¨ Sp a r k 中主要有两种调度器： D A G Sc h ed u l er 和 T a s k Sc h ed u l er ， D A G Sc h ed u l er 主要是把一个 J ob 根据 RD D 间的依赖关系，划分 为多个 St a g e ， 对于划分后的每个 St a g e 都抽象为一个由多个 Ta s k 组成的任务集（ T a s k Set ）， 并交给 T a s k Sc h ed u l er 来进行进一 步的任务调度。 T a s k Sc h ed u l er 负责对每个具体的 Ta s k 进行调度。 47 Sp a r k RD D 调度过程 48 ¨ Sp a r k 对 RD D 执行调度的过程，创建 RD D 并生成 DA G ， 由 D A G Sc h ed u l er 分解 DA G 为包含多个 Ta s k （ 即 T a s k Set ） 的 St a g es ， 再将 T a s k Set 发送至 T a s k Sc h ed u l er ， 由 T a s k Sc h ed u l er 来调度每个 Ta s k ， 并分配到 W or k er 节点上执 行，最后得到计算结果。 D A G Sc h ed u l er ¨ 当创建一个 RD D 时，每个 RD D 中包含一个或多个分区，当执行 A c t i on 操作时， 相应的产生一个 J ob ， 而一个 J ob 会根据 RD D 间的依赖关系分解为多个 St a g e ， 每个 St a g e 由多个 Ta s k 组成（即 T a s k Set ）， 每个 Ta s k 处理 RD D 中的一个 P a r t i t i on 。 一个 St a g e 里面所有分区的任务集合被包装为一个 T a s k Set 交给 T a s k Sc h ed u l er 来进行任务调度。这个过程是由 D A G Sc h ed u l er 来完成的。 49 T a s k Sc h ed u l er ¨ D A G Sc h ed u l er 将一个 T a s k Set 交给 T a s k Sc h ed u l er 后， T a s k Sc h ed u l er 会为每个 T a s k Set 进行任务调度， Sp a r k 中的任务调度分为两种： FIFO （ 先进先出）调度和 FA I R （ 公平调度）调度。 ¤ FIFO 调度：即谁先提交谁先执行，后面的任务需要等待前面的任务执行。这 是 Sp a r k 默认的调度模式。 ¤ FA I R 调度： 支持将作业分组到池中，并为每个池设置不同的调度权重，任务 可以按照权重来决定执行顺序。 ¤ s p a r k . s c h ed u l er . m od e 可选 FIFO 或 FA I R ，默认是 FIFO 50 FIFO 调度算法 F I F O Sc h ed u l i n g A l g or i t h m FA I R 调度算法 F a i r Sc h ed u l i n g A l g or i t h m • we ig h t ： 控制池在集群中的份额，默认情况下， 所有池的权值为 1 ； • mi n S h a re ： 最小 CP U 核心数，默认为 0 。权重相 同时，越小可以获得更多的资源。 摘要 p 为什么会有 Sp a r k ？ p Sp a r k 的生态圈 p Sp a r k 的基本构架和组件 p Sp a r k 的程序执行过程 p Sp a r k 的技术特点 53 Sp a r k 程序执行过程 ¨ 1. 用户编写的 Sp a r k 程序提交到相应的 Sp a r k 运行框架中。 ¨ 2 . Sp a r k 创建 Sp a r k C on t e xt 作为本次程序的运行环境。 ¨ 3. Sp a r k C on t e xt 连接相应的集群配置，来确定程序的资源配置使用情况。 ¨ 4. 连接集群资源成功后， Sp a r k 获取当前集群上存在 E x ec u t or 的节点，即当前集 群中 Sp a r k 部署的子节点中处于活动并且可用状态的节点（ Sp a r k 准备运行你的 程序并且确定数据存储） ¨ 5 . Sp a r k 分发程序代码到各个节点。 ¨ 6. 最终， Sp a r k C on t e xt 发送 tas ks 到各个运行节点来执行。 54 Sp a r k 程序执行过程 ¨ 几个基本概念 ¤ 更详细地说，一个作业（ J ob ）就是 一组 T r a n s f or m a t i on 操作和一个 a c t i on 操作的集合 。每执 行一次 a c t i on 操作，那么就会提交一个 J ob 。 ¤ St a g e 分为两种， Sh u f f l e St a g e 和 f i n a l St a g e ，每个作业必然只有一个 f i n a l St a g e ，即每个 a c t i on 操作会生成一个 fi n al st ag e ，如果一个作业中还包含 Sh u f f l e 操作，那么每进行一次 Sh u f f l e 操作，便会生成一个 Sh u f f l e St a g e 。 ¤ Sh u f f l e 操作 只有在宽依赖 的时候才会触发。 ¤ 任务（ Ta s k ） 作用的单位是 P a r t i t i on ，针对同一个 St a g e ，分发到不同的 P a r t i t i on 上进行执行。 ¨ 总而言之， J ob 和 St a g e 是针对一个 RD D 执行过程的划分，而 Ta s k 则是具体到了 RD D 中每个分区的执行 55 Sp a r k 程序执行过程 ¨ 一个作业就是一张 RD D 世系（ L i n ea g e ）图： DA G 图 56 Sp a r k 程序执行过程 ¨ 构建 RD D 世系关系的优势 ¤ 基于 RD D 世系的并行执行优化 ¤ 更快速，更细粒度的容错 57 joi n un i o n gr o u pB y ma p St a ge 3 St a ge 1 St a ge 2 A: B: C: D: E: F: G: = p r e v i o u s l y c o m p u t e d pa r t it io n Ta s k 摘要 p 为什么会有 Sp a r k ？ p Sp a r k 的生态圈 p Sp a r k 的基本构架和组件 p Sp a r k 的程序执行过程 p Sp a r k 的技术特点 58 Sp a r k 的技术特点 ¨ RD D ： Sp a r k 提出的 弹性分布式数据集 ，是 Sp a r k 最核心的分布式 数据抽象， Sp a r k 的很多特性都和 RD D 密不可分。 ¨ T r a n s f or m a t i on & A c t i on ： Sp a r k 通过 RD D 的两种不同类型的运算实 现了 惰性计算 ，即在 RD D 的 T r a n s f or m a t i on 运算时， Sp a r k 并没有进 行作业的提交；而在 RD D 的 A c t i on 操作时才会触发 Sp a r k C on t e xt 提 交作业。 59 Sp a r k 的技术特点 ¨ L i n ea g e ：为了保证 RD D 中数据的鲁棒性， Sp a r k 系统通过 血统关 系 （ l i n ea g e ）来记录一个 RD D 是如何通过其他一个或者多个父类 RD D 转变过来的，当这个 RD D 的数据丢失时， Sp a r k 可以通过它父 类的 RD D 重新计算。 ¨ Sp a r k 调度： Sp a r k 采用了事件驱动的 Sc a l a 库类 Ak k a 来完成任务的 启动，通过复用线程池的方式来取代 M a p R ed u c e 进程或者线程启 动和切换的开销。 60 Sp a r k 的技术特点 ¨ A PI ： Sp a r k 使用 Sc a l a 语言进行开发，并且默认 Sc a l a 作为其编程语 言。因此，编写 Sp a r k 程序比 M a p R ed u c e 程序要简洁得多。同时， Sp a r k 系统也支持 Ja v a 、 Pyt h on 语言进行开发 ¨ Sp a r k 生态： Sp a r k SQ L 、 Sp a r k St r ea m i n g 、 Gr a p h X 等为 Sp a r k 的应 用提供了丰富的场景和模型，适合应用于不同的计算模式和计算 任务 ¨ Sp a r k 部署： Sp a r k 拥有 St a n d a l on e 、 Y A RN 、 K8S 等多种部署方式， 可以部署在多种底层平台上 61 Sp a r k 的技术特点 ¨ 适用于需要多次操作特定数据集的应用场合。需要反复操作的次 数越多，所需读取的数据量越大，受益越大，数据量小但是计算 密集度较大的场合，受益就相对较小 ¨ 由于 RD D 的特性， Sp a r k 不适用那种异步细粒度更新状态的应用， 例如 we b 服务的存储或者是增量的 we b 爬虫和索引。就是对于那 种增量修改的应用模型不适合 ¨ 数据量不是特别大，但是要求实时统计分析需求 62 Sp a r k 的技术特点 ¨ 综上所述， Sp a r k 是 一种 为 大规模数据处理而设计的快速通用的 分布式计算引擎 ，适合于完成一些迭代式、关系查询、流式处理 等计算密集型任务。 63 TH A NK YO U","libVersion":"0.2.4","langs":""}