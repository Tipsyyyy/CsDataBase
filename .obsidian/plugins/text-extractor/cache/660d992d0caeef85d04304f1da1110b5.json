{"path":"课程/数据结构/课件/文件.pdf","text":"第十章 文件、外部排序 与外部搜索 • 主存储器和外存储器 • 文件组织 • 多级索引结构 • 外排序 1 主存储器与外存储器 • 主存储器又叫内存储器，简称为内存；外存 储器简称为外存。 • 外存储器与内存储器相比，优点是：  价格较低  永久的存储能力 • 缺点：  访问外存储器上的数据比访问内存要慢5～ 6个数量级 • 要求我们在开发系统时必须考虑如何使外存 访问次数达到最少。 2 磁带（tape） • 磁带是一种顺序存取设备。 • 磁带主要用于备份、存储不经常使用的数据， 以及作为将数据从一个系统转移到另一个系统 的脱机介质。 3 读出头 写入头 磁带 送带盘 卷带盘 • 磁带卷在一个卷盘上，运行时磁带经过读写磁 头，把磁带上的信息读入计算机，或者把计算 机中的信息写到磁带上去。 • 数据记录在磁带带面上。在带面上并列存放有 9 个磁道的信息，即每一横排有 9 位二进制信 息：8 位数据加 1 位奇偶校验位。 • 磁带的存储密度用 BPI（Bit Per Inch）为单位， 典型的存储密度有 3 种：6250BPI（=246排 /mm）、1600BPI（=64排/mm）、800BPI （32排/mm）。正常走带速度为3～5m/Sec， 因设备而异。 4 • 数据的传送速度 = 存储密度×走带速度。 • 在应用中使用文件进行数据处理的基本单位叫 做逻辑记录，简称为记录；在磁带上物理地存 储的记录叫做物理记录。 • 在使用磁带或磁盘存放逻辑记录时，常常把若 干个逻辑记录打包进行存放，把这个过程叫做 “块化”（blocking）。经过块化处理的物理 记录叫做块化记录。 • 磁带设备是一种启停设备。磁带每次启停都有 一个加速与减速的过程，在这段时间内走带不 5 稳定，只能走空带，这段空带叫做记录间间隙 IRG（Inter Record Gap）或者块间间隙IBG （Inter Block Gap），其长度因设备而异。 6 磁带速度 75-200英寸/秒 传输速度 7000-1250000字/秒 1.5-16 ms 1.5-16 ms 定速 加速 IBG 0.3～0.75英寸 减速 物理记录 启动位置 IBG 0.3～0.75英寸 停止位置 传输开始 传输完成 经过时间 • 如果每个逻辑记录是 80个字符，IRG为 0.75英 寸，则对存储密度为 1600BPI 的磁带，一个 逻辑记录仅占 80/1600 = 0.05英寸。每传输一 个逻辑记录磁带走过 0.05英寸，接着磁带要走 过一个IRG占0.75英寸。结果大部分时间都花 费在走空带上，存储利用率只有1/16。 • 如果将若干逻辑记录存放于一个块，将IRG变 成IBG，可以提高存储利用率。例如，将50个 有80个字符的逻辑记录放在一个块内，此块的 长度将达到50×80/1600 = 2.5英寸，存储利用率 达到0.77。因此在磁带上采用按块读写。 7 • 在磁带设备上读写一块信息所用时间 tIO = ta + tb • 其中，ta 是延迟时间，即读写磁头到达待读写 块开始位置所需花费的时间，它与当前读写磁 头所在位置有关。tb是对一个块进行读写所用 时间，它等于数据传输时间加上IBG时间。 • 磁带设备只能用于处理变化少，只进行顺序存 取的大量数据。 8 磁盘（disc） • 磁盘存储器通常称为直接存取设备，或随机存 取设备，它访问外存上文件的任一记录的时间 几乎相同。 • 磁盘存储器可以顺序存取，也可以随机存取。 • 目前使用较多的是活动臂硬盘组：若干盘片构 成磁盘组，它们安装在主轴上，在驱动装置的 控制下高速旋转。除了最上面一个盘片和最下 面一个盘片的外侧盘面不用以外，其他每个盘 片上下两面都可存放数据。将这些可存放数据 的盘面称为记录盘面。 910 主轴 盘片 活动臂 （回转臂） 读写磁头 磁道 柱面 • 每个记录盘面上有很多磁道，数据就存放在这 些磁道上。它们在记录盘面上形成一个个同心 圆。 • 每个记录盘面都有一个读写磁头。所有记录盘 面的读写磁头都安装在同一个动臂上，随动臂 向内或向外做径向移动，从一个磁道移到另一 个磁道。 • 任一时刻，所有记录盘面的读写磁头停留在各 个记录盘面的半径相同的磁道上。运行时，由 于盘面做高速旋转，磁头所在的磁道上的数据 相继在磁头下，从而可以读写数据 。 11 • 各个记录盘面上半径相同的磁道合在一起称 为柱面。动臂的移动实际上是将磁头从一个 柱面移动到另一个柱面上。 • 一个磁道可以划分为若干段，称为扇区，一 个扇区就是一次读写的最小数据量。这样， 对磁盘存储器来说，从大到小的存储单位是： 盘片组、柱面、磁道和扇区。 • 对磁盘存储器进行一次存取所需时间： 1. 当有多个盘片组时，要选定某个盘片组。 这是由电子线路实现的，速度很快。 12 2. 选定盘片组后再选定某个柱面，并移动动 臂把磁头移到此柱面上。这是机械动作， 速度较慢。这称为“寻查（seek）”。 3. 选定柱面后，要进一步确定磁道，即确定 由哪个读写磁头读写，由电子线路实现。 4. 确定磁道后，还要确定所要读写数据在磁 盘上的位置（如在哪一个扇区）。这实际 上就是在等待要读写的扇区转到读写磁头 下面。这是机械动作。这段时间一般称为 旋转延迟（rotational delay）时间。 5. 真正进行读写时间。 13 • 在磁盘组上一次读写的时间主要为： tio＝tseek＋tlatency＋trw • 其中，tseek是平均寻查时间，是把磁头定位到 要求柱面所需时间，这个时间的长短取决于磁 头移过的柱面数。tlatency是平均等待时间，是 将磁头定位到指定块所需时间。trw是传送一个 扇区数据所需的时间。 • 在MS-DOS系统中，多个扇区集结成组，称为 簇。簇是文件分配的最小单位，其大小由操作 系统决定。在UNIX系统中不使用簇，文件分 配的最小单位和读写的最小单位是一个扇区， 称为一个块（block）。 14 缓冲区（buffer） • 磁盘一次读写操作访问一个扇区，称为访问 “一页”（page）或“一块”（block），又 称为“一次访外”。 • 为了实施磁盘读写操作，在内存中需要开辟一 些区域，用以存放需要从磁盘读入的信息，或 存放需要写出的信息。这些内存区域称为缓冲 区。多数操作系统至少设置两个缓冲区，一个 为输入缓冲区，一个为输出缓冲区。 15 • 例如，在从磁盘向内存读入一个扇区的数据时， 数据被存放到输入缓冲区，如果下次需要读入 同一个扇区的数据，就可以直接从缓冲区中读 取数据，不需要重新读盘。 • 缓冲区大小应与操作系统一次读写的块的大小 相适应，这样可以通过操作系统一次读写把信 息全部存入缓冲区中，或把缓冲区中的信息全 部写出到磁盘。 • 如果缓冲区大小与磁盘上的块大小不适配，就 会造成存储空间的浪费。 • 缓冲区的构造可以看作一个先进先出的队列。 16 缓冲区的定义及其操作 #include <iostream.h> #include <assert.h> const int DefaultSize = 2048; template <class T> struct buffer { T *data; //缓冲区数组 int current, maxSize; //当前指针, 缓冲区容量 buffer (int sz = DefaultSize) : maxSize(sz), current(0) { data = new T[sz]; assert (data != NULL); } ～buffer() { delete []data; } 17 void OutputInfo (ostream& out, T x); //缓冲区输出 void InputInfo (istream& in, T& x); //缓冲区输入 }; template <class T> void buffer<T>::OutputInfo (ostream& out, T x) { if (current == maxSize) { for (int i = 0; i < maxSize; i++) out << data[i]; current = 0; } data[current] = x; current++; }; 18 template <class T> void buffer<T>::InputInfo (istream& in, T& x) { if (current < maxSize) { x = data[current]; current++; } else { for (int i = 0; i < maxSize; i++) in >> data[i]; current = 0; } }; 19 文件组织 • 什么是文件  文件是存储在外存上的数据结构，一般是在逻 辑上具有完整意义的一组相关信息项的有序序 列。  文件分操作系统文件和数据库文件  操作系统中的文件是流式文件：是没有结 构的字符流  数据库文件是具有结构的数据集合  数据结构中讨论的是数据库文件。 • 操作系统对文件是按物理记录读写的，在数据库 中文件按页块存储和读写。 20 文件的基本概念 文件的组成 • 文件由记录组成；记录由若干数据项组成。 • 记录是文件存取的基本单位，数据项是文件可 使用的最小单位。 • 从不同的观点，文件记录分为逻辑记录和物理 记录。前者是面向用户的基本存取单位，后者 是面向外设的基本存取单位。 • 能够唯一标识一个记录的数据项或数据项集称 为主关键码项，其值称为主关键码； • 不唯一标识一个记录的数据项或数据项集称为 次关键码项，其值称为次关键码。 21 • 文件结构包括文件的逻辑结构、文件的存储结 构和文件的操作。 • 文件的逻辑结构是线性结构，各个记录以线性 方式排列。 • 文件的存储结构是指文件在外存上的组织方式， 它与文件特性有关。  顺序组织  直接存取组织（散列组织）  索引组织 • 文件的操作是定义在逻辑结构上的，但操作的 具体实现要在存储结构上进行。 22 • 评价一个文件组织的效率  执行文件操作所花费的时间  文件组织所需要的空间 23 文件的操作 检索 维护 简单查询 范围查询 函数查询 布尔查询 插入 删除 修改 重构 恢复 顺序文件 (Sequential File ) • 顺序文件中的记录按它们进入文件的先后顺序 存放，其逻辑顺序与物理顺序一致。 • 如果文件的记录按主关键码有序，则称其为顺 序有序文件，否则称其为顺序无序文件。 • 顺序文件通常存放在顺序存取设备（如磁带） 上或直接存取设备（如磁盘）上。 • 当存放在顺序存取设备上时只能按顺序搜索法 存取；当存放在直接存取设备上时，可以使用 顺序搜索法、折半搜索法等存取。 24 • 顺序文件的存储方式 1. 连续文件：文件的全部记录顺序地存放于 外存的一个连续的区域中。优点是存取速 度快、存储利用率高、处理简单。缺点是 区域大小需事先定义，不能扩充。 2. 串联文件：文件记录成块存放于外存中， 在块中记录顺序连续存放，但块与块之间 可以不连续，通过块链指针顺序链接。优 点是文件可以扩充、存储利用率高。缺点 是影响了存取和修改的效率。 25 直接存取文件 (Direct Access File) • 又叫散列文件。利用散列技术组织文件。处理 类似散列法，但它是存储在外存上的。 • 文件记录的逻辑顺序与物理顺序不一定相同。 通过记录的关键码可直接确定该记录的地址。 • 使用散列函数把关键码集合映射到地址集合时， 往往会产生地址冲突，处理冲突有两种处理方 式：  按桶散列  可扩充散列 26 (1) 按桶散列 • 文件中的记录成组存放，若干个记录组成一个 存储单位，称之为桶。假若一个桶能存放m个 记录，则m个互为同义词的记录可以存放在同 一地址的桶中。当第m+1个同义词出现时，才 发生“溢出”。 (a) 溢出链  当发生“溢出”时，将第m+1个同义词存放 到“溢出桶”。并称存放前m个同义词的桶 为“基桶”。溢出桶和基桶大小相同。当在 基桶中检索不成功，就循指针到溢出桶中检 索。 27 桶大小为3的溢出桶链表示例 • 在这种散列文件中删除记录时，因为可能需要 重新链接，所以只需做一个逻辑删除标记即可， 待系统做周期性重构时再做物理删除。 28 070 ∧ 512 204 246 O1 597 177 ∧ 262 157 ∧ 116 613 ∧ 285 635 208 O2 923 076 ∧ 0 1 2 3 4 5 6 O1 O2 O3 O4 O5 O6 O7 015 337 988 O3 817 117 390 O4 575 540 435 ∧ 362 ∧ 基桶编号 基桶区 溢出桶编号 溢出桶区 (b) 分布式溢出空间  溢出桶按照一定的间 隔分布在基桶之间。 如果有一个基桶溢出 了，系统就将记录存 放在下一个溢出桶中。  如果溢出桶自己溢出 了，则使用下一个相 继的溢出桶，这需要 第二次溢出处理。 29 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 分布式溢出桶 基桶 基桶 基桶 溢出桶 溢出桶 • 如果系统对基桶按0, 1, 2, 3, 4, 5, …进行编号， 在按间隔 G = 5 插入溢出桶后，可按下列公式 按字节求出各个桶的实际存储地址： • 其中，B0是在文件中第0号桶的起始地址，B 是每个桶的字节数。在括号中的除数5表示每 隔5个基桶安排一个溢出桶。 (c) 相继溢出法  此方法不设置溢出桶。当记录应存放的桶溢 出时，溢出记录存放到下一个相继的桶中。 30 .          +×+= 5 i iBB 0桶的地址  如果该桶已满，就把它放 到再下一个桶中，如此处 理，直至把记录存放好。  相继溢出法的优点是对溢 出不需要漫长的寻找。紧 邻的桶通常相距不多于一 次磁盘旋转。但当邻近的 多个桶被挤满时，则为了 查找空闲空间就需要检查 许多桶。如果桶的容量很 小更是如此。 31 362 177 597 157 817 575 070 246 015 542 389 116 204 512 435 337 117 635 613 262 988 285 923 076 208 相继溢出法 0 1 2 4 3 5 6 7 9 8 10 H(key) = key % 11 (2) 可扩充散列 • 这是基于数字搜索树的一种散列方法，细节参 见10.5节。 32 散列文件优缺点 • 散列文件具有随机存放、记录不需进行排序、 插入删除方便、存取速度快、不需要索引区和 节省存储空间等优点。 • 散列文件不能顺序存取，只能按关键码随机存 取。在经过多次插入、删除后，可能出现溢出 桶满而基桶内多数记录已被删除的情况。此时 需要重新组织文件。 33 索引文件 (Indexed File) • 索引文件由索引表和数据表（主文件）组成。 • 索引表用于指示逻辑记录与物理记录间的对 应关系，它是按关键码有序的表。  索引顺序文件：主文件也按关键码有序。 此时可对主文件分组，一组记录对应一个 索引项。称这种索引表为稀疏索引。  索引非顺序文件：主文件中记录未按关键 码有序。此时，每一个主文件记录必须对 应一个索引项。称这种索引表为稠密索引。 34 • 静态索引：采用多级索引结构，每一级索引均 为有序表。优点是结构简单，缺点是修改很不 方便，每次修改都要重组索引。 • 动态索引：采用可动态调整的平衡搜索树结构， 如二叉搜索树、B树与B+树等。优点是插入、 删除和搜索都很方便。 • 在文件中搜索时，访问外存所花费时间比在内 存中搜索所需的时间大得多，因此，外存上搜 索一个记录的时间代价主要取决于访问外存的 次数，即索引树的高度。 35 职工号 姓名 性别 职务 婚否 … 83 张珊 女 教师 已婚 … 08 李斯 男 教师 已婚 … 03 王璐 男 教务员 已婚 … 95 刘琪 女 实验员 未婚 … 24 岳跋 男 教师 已婚 … 47 周斌 男 教师 已婚 … 17 胡江 男 实验员 未婚 … 51 林青 女 教师 未婚 … 36 0 1k 2k 3k 4k 5k 6k 7k 索引表 数据表 key addr 03 2k 08 1k 17 6k 24 4k 47 5k 51 7k 83 0 95 3k 索引非顺序文件示例索引顺序文件示例 • 当记录在外存中有序存放时，可以把所有n个 记录分为b个子表 (块) 存放，一个索引项对应 数据表中一组记录 (子表)。 37 22 12 13 30 29 33 36 42 44 48 39 40 60 74 56 79 80 66 92 82 88 98 94 子表1 子表2 子表3 子表4 数据区 33 48 80 98 索引表 1 2 3 4 max_key addr • 对索引顺序文件进行搜索，一般分为两级:  先在索引表ID中搜索给定值K, 确定满足 ID[i-1].max_key < K ≤ ID[i].max_key 的 i 值, 即待查记录可能在的子表的序号。  然后再在第 i 个子表中按给定值搜索要求的 记录。 • 索引表是按max_key有序的, 且长度也不大,可 以折半搜索，也可以顺序搜索。 • 各子表内各个记录如果也按关键码有序, 可以 采用折半搜索或顺序搜索; 如果不是按关键码 有序, 只能顺序搜索。 38 • 索引顺序文件的搜索成功时的平均搜索长度 ASLIndexSeq = ASLIndex + ASLSubList • 其中, ASLIndex 是在索引表中搜索子表位置的 平均搜索长度，ASLSubList 是在子表内搜索记 录位置的搜索成功的平均搜索长度。 • 设把长度为n的表分成均等的b个子表，每个 子表s个记录，则b = n/s。又设表中每个记 录的搜索概率相等，则每个子表的搜索概率 为1/b，子表内各记录的搜索概率为 1/s。 • 若对索引表和子表都用顺序搜索，则索引顺 序搜索的搜索成功时的平均搜索长度为 ASLIndexSeq = (b+1)/2+(s+1)/2 = (b+s)/2 +1 39 • 索引顺序文件的平均搜索长度与表中的记录个 数n有关，与每个子表中的记录个数s有关。在 给定n的情况下，s 应选择多大？ • 用数学方法可导出, 当 s = 时, ASLIndexSeq取 极小值 +1。这个值比顺序搜索强，但比折 半搜索差。但如果子表存放在外存时，还要受 到页块大小的制约。 • 若采用折半搜索确定记录所在的子表, 则搜索 成功时的平均搜索长度为 ASLIndexSeq = ASLIndex + ASLSubList ≈ log2 (b+1)-1 + (s+1)/2 ≈ log2(1+n / s ) + s/2 40 n n 倒排表 (Inverted Index List) • 对包含有大量数据记录的数据表或文件进行搜 索时，最常用的是针对记录的主关键码建立索 引。主关键码可以唯一地标识该记录。用主关 键码建立的索引叫做主索引。 • 主索引的每个索引项给出记录的关键码和记录 在表或文件中的存放地址。 • 但在实际应用中有时需要针对其它属性进行搜 索。例如，查询如下的职工信息： (1) 列出所有教师的名单； (2) 已婚的女性职工有哪些人？ 41 记录关键码 key 记录存放地址 addr • 这些信息在数据表或文件中都存在，但都不是 关键码，为回答以上问题，只能到表或文件中 去顺序搜索，搜索效率极低。 • 因此，除主关键码外，可以把一些经常搜索的 属性设定为次关键码，并针对每一个作为次关 键码的属性，建立次索引。 • 在次索引中，列出该属性的所有取值，并对每 一个取值建立有序链表，把所有具有相同属性 值的记录按存放地址递增的顺序或按主关键码 递增的顺序链接在一起。 4243 0 1k 2k 3k 4k 5k 6k 7k 索引表 数据表 职工号 姓名 性别 职务 婚否 … 83 张珊 女 教师 已婚 … 08 李斯 男 教师 已婚 … 03 王璐 男 教务员 已婚 … 95 刘琪 女 实验员 未婚 … 24 岳跋 男 教师 已婚 … 47 周斌 男 教师 已婚 … 17 胡江 男 实验员 未婚 … 51 林青 女 教师 未婚 … key addr 03 2k 08 1k 17 6k 24 4k 47 5k 51 7k 83 0 95 3k 索引非顺序文件示例• 次索引的索引项由次关键码、链表长度和链表 本身等三部分组成。 • 例如，为了回答上述的查询，我们可以分别建 立“性别”、“婚否”和“职务”次索引。 44 性别次索引 次关键码 男 女 计 数 5 3 地址指针 指针 03 08 17 24 47 51 83 95 45 婚否次索引 次关键码 已婚 未婚 计 数 5 3 地址指针 指针 03 08 24 47 83 17 51 95 职务次索引 次关键码 教师 教务员 实验员 计 数 5 1 2 地址指针 指针 08 24 47 51 83 03 17 95 (1) 列出所有教师的名单； (2) 已婚的女性职工有哪些人？ • 通过顺序访问“职务”次索引中的“教师”链， 可以回答上面的查询(1)。 • 通过对“性别”和“婚否”次索引中的“女性” 链和“已婚”链进行求“交”运算，就能够找 到所有既是女性又是已婚的职工记录，从而回 答上面的查询(2)。 • 倒排表是次索引的一种实现。在表中所有次关 键码的链都保存在次索引中，仅通过搜索次索 引就能找到所有具有相同属性值的记录。 • 在次索引中记录记录存放位置的指针可以用主 关键码表示: 可通过搜索次索引确定该记录的主 关键码, 再通过搜索主索引确定记录的存放地址。 46 • 在倒排表中各个属性链表的长度大小不一,管 理比较困难。为此引入单元式倒排表。 • 在单元式倒排表中, 索引项中不存放记录的存 储地址, 而是存放该记录所在硬件区域（即存 储区域）的标识。 • 硬件区域可以是磁盘柱面、磁道或一个页块, 以一次 I / O 操作能存取的存储空间作为硬件 区域为最好。 47 • 为使索引空间最小, 在索引中标识这个硬件区 域时可以使用一个能转换成地址的二进制数, 整个次索引形成一个(二进制数的) 位矩阵。 • 例如, 对于记录学生信息的文件, 次索引可以是 如图（下页）所示的结构。二进位的值为 1 的 硬件区域包含具有该次关键码的记录。 4849 硬 件 区 域 1 2 3 4 5 … 251 252 253 254 … 次关键码 1 男 1 0 1 1 1 … 1 0 1 1 … (性别) 女 1 1 1 1 1 … 0 1 1 0 … 次关键码 2 广东 1 0 0 1 0 … 0 1 0 0 … (籍贯) 北京 1 1 1 1 1 … 0 0 1 1 … 上海 0 0 1 1 1 … 1 1 0 0 … …… 次关键码 3 建筑 1 1 0 0 1 … 0 1 0 1 … (专业) 计算机 0 0 1 1 1 … 0 0 1 1 … 电机 1 0 1 1 0 … 1 0 1 0 … …… 单元式倒排表结构 50  针对一个查询：找出所有广东籍学建筑的男学 生。可以从“性别”、“籍贯”、“专业”三 个次索引分别抽取属性值为“男”、“广东”、 “建筑”的位向量，按位求交，求得满足查询 要求的记录在哪些硬件区域中，再读入这些硬 件区域，从中查找所需的数据记录。  由运算结果可知，在硬件区域1，……中有所需 的记录。然后将硬件区域1，……等读入内存， 在其中进行检索，就可取出所需记录。 1 0 1 1 1 …… 1 0 1 1 1 0 0 1 0 …… 0 1 0 0 AND 1 1 0 0 1 …… 0 1 0 1 1 0 0 0 0 …… 0 0 0 0 多级索引结构 51  当数据记录数目特别大，索引表本身也很大， 在内存中放不下，需要分批多次读取外存才能 把索引表搜索一遍。  此时, 可以建立索引的索引(二级索引)。二级索 引可以常驻内存，二级索引中一个索引项对应 一个索引块，登记该索引块的最大关键码及该 索引块的存储地址。  如果二级索引在内存中也放不下，需要分为许 多块多次从外存读入。可以建立二级索引的索 引(三级索引)。这时, 访问外存次数等于读入索 引次数再加上1次读取记录。  必要时, 还可以有4级索引, 5级索引, …。 • 多级索引结构常用 m 叉树表示，称为m路搜索 树。 • m路搜索树可能是静态索引结构，即结构在初始 创建，数据装入时就已经定型，在整个运行期 间，树的结构不发生变化。 • m路搜索树还可能是动态索引结构, 即在整个系 统运行期间, 树的结构随数据的增删及时调整, 以保持最佳的搜索效率。 5253 多级索引结构形成 m 路搜索树 数据区 一级索引 二级索引 三级索引 四级索引ISAM (索引顺序存取方法文件) • 它是静态索引结构。典型的例子是对磁盘上 的数据文件建立盘组、柱面、磁道三级地址 的多级索引。 • ISAM文件用柱面索引对各个柱面进行索引。 一个柱面索引项保存该柱面上的最大关键码 （最后一个记录）以及柱面开始地址指针。 • 如果柱面太多，可以建立柱面索引的分块索 引，即主索引。主索引不太大，一般常驻内 存。 5455 C0T0 C0T1 R20 R25 R30 R40 R45 R48 R55 C0T2 R64 R69 R74 R78 R83 R91 R100 C0T3 R110 R125 C0T4 溢出区 …… 55 C0T1 100 C0T2 125 C0T3 C1T0 C1T1 R146 R151 R159 R164 R168 R172 R181 C1T2 R189 R190 R193 R198 R203 R210 R222 C1T3 R234 R246 R255 R269 R270 C1T4 溢出区 …… 181 C1T1 222 C1T2 270 C1T3 125 C0T0 270 C1T0 … 525 C5T0 714 C6T0 833 C7T0 … 1510 C11T0 … … 5540 C84T0 主索引 525 C0T1 1510 C6T1 … … … 5540 C79T1 C7T0 C7T1 R720 R724 R727 R736 R743 R759 R758 C7T2 R765 R769 R777 R781 R785 R790 R793 C7T3 R799 R801 R825 R833 C7T4 溢出区 …… 758 C7T1 793 C7T2 833 C7T3 柱面索引 各柱面信息 磁道 索引 磁道 索引 磁道 索引 • 在每个柱面上，所有数据记录存放于基本区， 此外保留一部分磁道作为溢出区。所有记录在 基本区按关键码升序排列，后一磁道所有记录 的关键码均大于前一磁道所有记录的关键码。 • 在一个柱面上所有记录分布在一系列磁道上， 通过磁道索引进行搜索。磁道索引一般放在每 个柱面上第0号磁道中， • 每个磁道索引的索引项由两部分组成： 56 最大关键码 开始地址指针 最大关键码 溢出链头指针 基本区索引项 溢出区索引项 • 基本区索引项存放本磁道在基本区最大关键码 （在基本区该磁道最后一个记录）和本磁道在 基本区的开始地址，溢出区索引项存放本磁道 在溢出区最大关键码和本磁道在溢出区中溢出 记录链（有序链表）的第一个结点地址。 • 在某一磁道插入一个新记录时，如果原来该磁 道基本区记录已经放满，则根据磁道索引项指 示位置插入新记录后，把最后的溢出记录（具 有最大关键码）移出磁道基本区，再根据溢出 索引项将这个溢出记录放入溢出区，并以有序 链表插入算法将溢出记录链入。 57 动态索引结构 • 现在我们所讨论的 m 路搜索树多为可以动态 调整的多路搜索树，它的递归定义为： • 一棵 m 路搜索树, 它或者是一棵空树, 或者是 满足如下性质的树： 根最多有 m 棵子树, 并具有如下的结构： ( n, P0, K1, P1, K2, P2, ……, Kn, Pn ) 其中, Pi 是指向子树的指针, 0≤i≤n<m; Ki 是关 键码, 1≤i≤n<m。 Ki < Ki+1, 1≤i < n。 58 动态的 m 路搜索树 在子树 Pi 中所有的关键码都小于 Ki+1, 且大于 Ki，0 < i < n。 在子树 Pn 中所有的关键码都大于Kn； 在子树 P0 中的所有关键码都小于 K1。 子树 Pi 也是 m 路搜索树，0≤i < n 。 59 一棵3路搜索树的示例 35 20 40a b c d e 25 3010 15 45 50 M路搜索树的C++描述 const int MaxValue = ……; //关键码集合中不可能有的最大值 template <class T> struct MtreeNode { //树结点定义 int n; //索引项个数 MtreeNode<T> *parent; //父结点指针 T key[m+1]; //key[m]为监视哨，key[0]未用 int *recptr[m+1]; //索引项记录起始地址指针 MtreeNode<T> *ptr[m+1];//子树结点指针，ptr[m] 在插入溢出时使用 }; 60 template <class T> //搜索结果三元组 struct Triple { MtreeNode<T> *r; //结点地址指针 int i; //结点中关键码序号i int tag; //tag=0,成功; =1,失败 }; template <class T> class Mtree { //m叉搜索树定义 protected: MtreeNode<T> *root; //根指针 int m; //路数 public: Triple<T> Search(const T& x); //搜索 }; 61 • AVL树是 2 路搜索树。若已知 m 路搜索树的度 m 和它的高度 h, 则树中的最大结点个数为： • 每个结点中最多有m-1个关键码，在一棵高度 为 h 的m路搜索树中关键码最大个数为mh-1。 高度h=3的二叉搜索树, 关键码最大数为7； 高度h=4的3路搜索树, 关键码最大数为34-1 = 80。 ( )1 1 1 1 -1 − − =∑ = h h i i m m m 62 m路搜索树的搜索算法 • 在 m 路搜索树上的 搜索过程是一个在 结点内搜索和自根 结点向下逐个结点 搜索的交替的过程。 63 35 20 40a b c d e 25 3010 15 45 50 root 搜索35 template <class T> Triple<T> Mtree<T>::Search (const T& x) { //用关键码 x 搜索驻留在磁盘上的m路搜索树 //各结点格式为n,p[0],(k[1],p[1]),…,(k[n],p[n]), n < m //函数返回一个类型为Triple(r,i,tag)的记录。 //tag = 0, 表示 x 在结点r中找到, 该结点的k[i]等于x; //tag = 1, 表示没有找到x, 可插入结点为r, 插入到该 //结点的k[i]与k[i+1]之间。 Triple result; //记录搜索结果三元组 GetNode (root); //从盘上读取结点root MtreeNode<T> *p = root, *q = NULL; //p是扫描指针,q是p的父结点指针 int i = 0； 64 while (p != NULL) { //从根开始检测 i = 0; p->key[(p->n)+1] = MaxValue; while (p->key[i+1] < x) i++; //在结点内搜索 if (p->key[i+1] == x) { //搜索成功 result.r = p; result.i = i+1; result.tag = 0; return result; } q = p; p = p->ptr[i]; //本结点无x, q记下当前结点, p下降到子树 GetNode(p); //从磁盘上读取结点p } result.r = q; result.i = i; result.tag = 1; return result; //搜索失败,返回插入位置 }; 65 • 提高搜索树的路数 m, 可以改善树的搜索性能。 对于给定的关键码数 n，如果搜索树是平衡的， 可以使 m 路搜索树的性能接近最佳。下面将 讨论一种称之为B 树的平衡的 m 路搜索树。 66 B 树 • 一棵 m 阶B 树是一棵平衡(balanced)的 m 路 搜索树, 它或者是空树, 或者是满足下列性质 的树： 根结点至少有 2 个子女。 除根结点以外的所有结点 (不包括失败结 点)至少有 m/2个子女。 所有的失败结点都位于同一层。 • 在B 树中的“失败”结点是当 x 不在树中时 才能到达的结点。这些结点实际不存在，指 向它们的指针为NULL。它们不计入树的高度。 67 • 注意，m阶B树继承了m路搜索树的定义。原 来m路搜索树定义中的规定在m阶B树中都保 留。 • 事实上，在B 树的每个结点中还包含有一组指 针recptr[m+1]，指向实际记录的存放地址。 • key[i]与recptr[i] (1≤i≤n<m) 形成一个索引项 (key[i], recptr[i])，通过key[i]可找到某个记录 的存储地址recptr[i]。 • 在讨论B树结构的操作时先不涉及recptr[i]， 因此在后续讨论中该指针不出现。 6869 非B 树 B 树 30 35 20 40 25 3010 15 45 50 root 45 5035 4020 root 10 15 25 B树类和B树结点类的定义 template <class T> class Btree : public Mtree<T> { //B树类定义 //继承m叉搜索树的所有属性和操作， //Search从Mtree继承， MtreeNode直接使用 public: Btree(); //构造函数 bool Insert (const T& x); //插入关键码x bool Remove (T& x); //删除关键码x }; 70 B 树的搜索算法 • B树的搜索算法继承了m路搜索树Mtree上的搜 索算法。 • B树的搜索过程是一个在结点内搜索和循某一 条路径向下一层搜索交替进行的过程。 • 搜索成功，报告结点地址及在结点中的关键码 序号；搜索不成功，报告最后停留的叶结点地 址及新关键码在结点中可插入的位置。 • B 树的搜索时间与B 树的阶数 m 和B 树的高度 h直接有关, 必须加以权衡。 71 • 在B 树上进行搜索, 搜索成功所需的时间取决 于关键码所在的层次; 搜索不成功所需的时间 取决于树的高度。 • 定义B树的高度h为叶结点（失败结点的双亲） 所在的层次，那么，树的高度h与树中的关键 码个数 N 之间有什么关系？ • 如果让B树每层结点个数达到最大（m-1）， 且设关键码总数为N, 则树的高度达到最小： N≤mh-1 h≥logm(N+1) • 如果让m阶B树中每层结点个数达到最少，则 72 B 树的高度可能达到最大。设树中关键码个数 为N，从B 树的定义知：  1层：1个结点  2层：至少2个结点  3层：至少2 m/2个结点  4层：至少2 m/22 个结点  如此类推，……  h层：至少有2 m/2h-2 个结点。 • 所有这些结点都不是失败结点。失败结点在第 h+1层，失败结点个数为N+1。 73 • 这是因为树中关键码有N个，而失败数据一般 与已有关键码交错排列。因此，有 N+1 = 失败结点数 = 位于第h+1层的结点数 ≥2 m/2h-1 ∴ N≥2 m/2h-1-1 ∴ h-1≤log m/2((N+1)/2) ∴ h≤logm/2((N+1)/2)+1 • 示例：若B 树的阶数 m = 199, 关键码总数 N = 1999999，则B 树的高度 h 不超过 log100 1000000 +1= 4 74 m值的选择 • 如果提高B 树的阶数 m, 可以减少树的高度, 从而减少读入结点的次数, 因而可减少读磁盘 的次数。 • 事实上，m 受到内存可使用空间的限制。当 m 很大超出内存工作区容量时，结点不能一 次读入到内存，增加了读盘次数，也增加了 结点内搜索的难度。 • m值的选择：应使得在B 树中找到关键码 x 的时间总量达到最小。 75 • 这个时间由两部分组成： 从磁盘中读入结点所用时间 在结点中搜索 x 所用时间 • 根据定义, B 树的每个结点的大小都是固定的, 结点内最多有m-1个索引项 (keyi, recptri, Pi), 1≤i < m。 • 设 keyi 所占字节数为α，recptri 和 Pi 所占字节 数为β，则结点大小近似为 m(α+2β) 个字节。 读入一个结点所用时间为： tseek+ tlatency+ m(α+2β) ttran = a + bm 76 B 树的插入 • B 树是从空树起, 逐个插入关键码而生成的。 • 在B 树中每个非失败结点的关键码个数都在 [ m/2-1, m-1] 之间。 • 插入在某个叶结点开始。如果在关键码插入 后结点中的关键码个数超出了上界 m-1，则 结点需要“分裂”，否则可以直接插入。 • 实现结点“分裂”的原则是： 设结点 p 中已经有 m-1 个关键码，当再插 入一个关键码后结点中的状态为 77 ( m, P0, K1, P1, K2, P2, ……, Km, Pm) 其中 Ki < Ki+1, 1 ≤ i < m 这时必须把结点 p 分裂成两个结点 p 和 q， 它们包含的信息分别为：  结点 p： ( m/2-1, P0, K1, P1, ……, Km/2-1, Pm/2-1)  结点 q： (m-m/2, Pm/2, Km/2+1, Pm/2+1, ……, Km, Pm) 位于中间的关键码 Km/2与指向新结点 q 的 指针形成一个二元组 ( Km/2, q )，插入到这 两个结点的双亲结点中去。 7879 结点“分裂”的示例 2 53 75 n P0 K1 P1 K2 P2 p 3 53 75 139 n P0 K1 P1 K2 P2 K3 P3 p 加入139, 结点溢出 1 75 n P0 K1 P1 1 53 n P0 K1 P1 1 139 n P0 K1 P1 结点 分裂 P q m = 3 80 示例:从空树开始加入关键码建立3阶B树 n=1 加入53 53 n=2 加入75 53 75 n=3 加入139 75 13953 49 75 n=5 加入49,145 75 139 14549 53 n=6 加入36 139 1455336 • 在插入新关键码时，需要自底向上地分裂结 点，最坏情况下从被插关键码所在叶结点到 根的路径上的所有结点都要分裂。 81 若设B 树 的高度为h, 则在自顶向 下搜索到叶 结点的过程 中需要进行 h 次读盘。 n=7 加入101 49 5336 139 145101 75 B 树的删除 • 在B 树上删除一个关键码时，若结点中所剩 关键码个数少于下限，要考虑结点的调整或 合并问题，删除过程如下： 首先需要找到这个关键码所在的结点, 从 中删去这个关键码。 若该结点不是叶结点，且被删关键码为 Ki， 1≤i≤n, 则在删去该关键码之后, 应以该结点 Pi 所指示子树中的最小关键码 x 来代替被 删关键码 Ki 所在的位置; 然后在 x 所在的叶结点中删除 x。 82 • 在叶结点上的删除有 4 种情况。 ① 被删关键码所在叶结点同时是根结点且删 除前该结点中关键码个数n≥2，则直接删去 该关键码并将修改后的结点写回磁盘。 ② 被删关键码所在叶结点不是根结点且删除 前该结点中关键码个数 n≥m/2, 则直接 删去该关键码并将修改后的结点写回磁盘, 删除结束。 83 36 49m = 3 删除36 49 84 55 58 删除55简单删除 75 80 m = 3 删除55 10 40 65 60 7030 50a cb d e f g h 58 75 8010 40 65 60 7030 50a cb d e f g h 85 ③ 被删关键码所在叶结点删除前关键码个数 n = m/2-1, 若这时与该结点相邻的右兄弟 (或左兄弟) 结点的关键码个数 n≥m/2，则 可按以下步骤调整该结点、右兄弟 (或左兄 弟) 结点以及其双亲，以达到新的平衡。 a) 将双亲结点中刚刚大于 (或小于) 该被删关 键码的关键码 Ki (1≤i≤n) 下移； b) 将右兄弟 (或左兄弟) 结点中的最小 (或最 大) 关键码上移到双亲结点的 Ki 位置； c) 将右兄弟 (或左兄弟) 结点中的最左 (或最 右) 子树指针平移到被删关键码所在结点 86 中最后 (或最前) 子树指针位置； d) 在右兄弟 (或左兄弟) 结点中，将被移走的 关键码和指针位置用剩余的关键码和指针 填补、调整。再将结点中的关键码个数减 1。 87 结点联合调整 55 58 75 80 m = 3 删除65 10 40 65 60 7030 50a cb d e f g h 55 58 8010 40 70 60 7530 50a cb d e f g h 调整g,c,h 删除65 88 ④ 被删关键码所在叶结点删除前关键码个数 n = m/2-1，若这时与该结点相邻的右兄弟 (或左兄弟) 结点的关键码个数 n = m/2-1, 则必须按以下步骤合并这两个结点。 a) 若要合并 p 中的子树指针 Pi 与 Pi+1 所指 的结点, 且保留 Pi 所指结点, 则把 p 中的 关键码 Ki+1下移到 Pi 所指的结点中。 b) 把 p 中子树指针 Pi+1 所指结点中的全部指 针和关键码都照搬到 Pi 所指结点的后面。 删去 Pi+1 所指的结点。 c) 在结点 p 中用后面剩余的关键码和指针 填补关键码 Ki+1 和指针 Pi+1。 d) 修改结点 p 和选定保留结点的关键码个 数。 89 • 在合并结点的过程中, 双亲结点中的关键码个 数减少了。 • 若双亲结点是根结点且结点关键码个数减到 0, 则将该双亲结点删去, 合并后保留的结点成 为新的根结点; 否则将双亲结点与合并后保留 的结点都写回磁盘, 删除处理结束。 • 若双亲结点不是根结点且关键码个数减到 m/2-2，又要与它自己的兄弟结点合并, 重 复上面的合并步骤。最坏情况下这种结点合 并处理要自下向上直到根结点。 9091 55 删除55结点合并 80 m = 3 删除55 10 40 60 58 7530 50a cb d e f g h 合并f, g 58 60 8010 40 7530 50a cb d e f h 92 55 非叶结点删除 删除50 删除55 55 58 75 80 m = 3 删除50 10 40 65 60 7030 50a cb d e f g h 58 75 80 删除55 10 40 65 60 7030 a cb d e f g h 用55取代 用58取代 93 58 75 8010 40 65 60 7030 a cb d e f g h 合并f, g 58 75 8010 40 60 65 7030 a cb d e f h 结点合并与调整 删除70 94 58 8010 40 60 65 7530 a cb d e f h 删除70 用75取代 删除75 58 10 40 60 65 8030 a cb d e f h 删除75 用80取代 调整f, c, h 95 58 8010 40 60 6530 a cb d e f h 删除10 8030 40 60f h 58 65 d b B+树 • B+ 树是B 树的变种，它与B 树的不同之处在 于： 所有关键码都存放在叶结点中，上层的非叶 结点的关键码是其子树中最小（或最大）关 键码的复写。 叶结点包含了全部关键码及指向相应数据记 录存放地址的指针，且叶结点本身按关键码 从小到大顺序链接。 • 每个非叶结点结构有两种方式处理。按下层结 点“最大关键码复写”和“最小关键码复写”。 96 按“最大关键码复写”原则组织 • 一棵m阶B+ 树的结构定义如下：  每个结点最多有 m 棵子树；  根结点最少有 1 棵子树，除根结点外，其他 结点至少有 m/2棵子树；  有 n棵子树的结点有 n 个关键码。  所有非叶结点可以看成是叶结点的索引，结 点中关键码Ki 与指向子树的指针Pi 构成对 子树 (即下一层索引块) 的索引项 ( Ki, Pi )， Ki 是子树中最大的关键码。 97  所有叶结点在同一层，按从小到大的顺序存 放全部关键码，各个叶结点顺序链接。 • 叶结点中存放的是对实际数据记录的索引，每 个索引项 ( Ki, Pi ) 给出数据记录的关键码及实 际存储地址。 • 例如，在一棵4阶B+ 树中，所有非叶结点中的 子树棵数2≤n≤4，其所有的关键码都出现在叶 结点中，且在叶结点中关键码有序地排列。上 面各层结点中的关键码都是其子树上最大关键 码的副本。 98 • 通常在B+ 树中有两个头指针：一个指向B+ 树 的根结点，一个指向关键码最小的叶结点。因 此，可以对B+ 树进行两种搜索运算：循叶结 点自己拉起的链表顺序搜索；从根开始进行自 顶向下直到叶结点的随机搜索。 99 m = 4 10 15 18 22 27 34 40 44 47 54 67 72 74 78 81 84 15 34 47 67 78 84 67 84 root B+ 树的插入 • B+ 树的插入仅在叶结点上进行。每插入一个(关 键码-指针) 索引项后都要判断结点中的索引项 个数是否超出范围m。 • 当插入后叶结点中的关键码个数n > m时，需要 将叶结点分裂为两个结点：它们包含的关键码 个数分别为 (m+1)/2和 (m+1)/2。并且它们 的双亲结点中应同时包含这两个结点的最大关 键码和结点地址。 • 在非叶结点中关键码的插入与叶结点的插入情 100 况类似，但在做根结点分裂时，必须创建新的 父结点，作为树的新根。 • 例如，在一棵4阶B+树中的插入过程如下。 101 连续插入24, 72, 01, 39的B+树 01 24 39 72 加入 53, 结 点分裂 01 24 39 53 72 39 72 加入63, 90, 88, 15的B+树 01 15 24 39 53 63 72 39 72 90 88 90 102 加入10, 44, 68, 74的B+树 01 10 15 44 53 63 15 39 63 24 39 68 72 74 88 90 72 90 63 90 B+树的删除 • B+ 树的删除仅在叶结点上进行。当在叶结点上删除一个 (关键码-指针)索引项后，结点中的索引项个数仍然不少于 m/2，这属于简单删除，其上层索引可以不改变。 • 如果删除结点的最大关键码，但因在其上层的副本只起了 一个引导搜索的“分界关键码”的作用，所以即使树中已 经删除了关键码，但上层的副本仍然可以保留。 • 如果在叶结点中删除后，结点中索引项个数小于 m/2， 必须做结点的调整或合并工作。如果右兄弟结点中的子树 棵数大于 m/2，从右兄弟结点中移最左的（关键码-指针） 索引项到这个被删关键码所在的结点，并修改上层的“分 界关键码”的值。 103 从4阶B+树中做简单删除 104 m = 4 10 15 18 22 27 34 40 44 47 54 67 72 74 78 81 84 15 34 47 67 78 84 67 84 × 简单删除关键码47, 上层索引可以不改 10 15 18 22 27 34 40 44 54 67 72 74 78 81 84 15 34 47 67 78 84 67 84 从4阶B+树中删除时的调整 105 m = 4 10 15 18 22 27 34 40 44 47 54 67 72 74 78 81 84 15 34 47 67 78 84 67 84 × 删除关键码15, 调整 上层索引改变 10 18 22 27 34 40 44 47 54 67 72 74 78 81 84 18 34 47 67 78 84 67 84 • 如果右兄弟结点的关键码数已达到下限 m/2， 没有多余的关键码可以移入被删关键码所在的 结点，必须进行结点的合并。将右兄弟结点中 的所有（关键码-指针）索引项移入被删关键码 所在结点，再将右兄弟结点删去。 • 这种结点合并将导致双亲结点中“分界关键码” 的减少，有可能减到非叶结点中关键码个数的 下限 m/2以下。这样将引起双亲结点的调整 或合并。 • 如果根结点的最后两个子女结点合并，树的层 数就会减少一层。 106107 删除 关键 码74, 78, 结点合并 10 18 22 27 34 40 44 47 54 67 72 74 78 81 84 18 34 47 67 78 84 67 84 10 18 22 27 34 40 44 47 54 67 72 81 84 18 34 47 67 84 47 84 外排序 • 当待排序的记录数目特别多时，在内存中不 能一次处理。必须把它们以文件的形式存放 于外存，排序时再把它们一部分一部分调入 内存进行处理。这样，在排序过程中必须不 断地在内存与外存之间传送数据。这种基于 外部存储设备（或文件）的排序技术就是外 排序。 108 外排序的基本过程 • 基于磁盘进行的排序大多使用归并排序方法。 其排序过程主要分为两个阶段： ① 建立用于外排序的内存缓冲区。根据它们 的大小将输入文件划分为若干段, 用某种 内排序方法对各段进行排序。经过排序的 段叫做初始归并段 (Run)。当它们生成后 就被写到外存中去。 ② 按归并树模式, 把①生成的初始归并段加 以归并, 一趟趟扩大归并段和减少归并段 数, 直到最后归并成一个大归并段为止。 109 • 示例：设有一个包含4500个记录的输入文件。 现用一台其内存至多可容纳750个记录的计算 机对该文件进行排序。输入文件放在磁盘上, 磁盘每个页块可容纳250个记录, 这样全部记录 可存储在 4500 / 250＝18 个页块中。输出文件 也放在磁盘上, 用以存放归并结果。 • 由于内存中可用于排序的存储区域能容纳750 个记录, 因此内存中恰好能存3个页块的记录。 • 在外排序一开始, 把18块记录, 每3块一组, 读入 内存。利用某种内排序方法进行内排序, 形成 初始归并段, 再写回外存。总共可得到6个初始 归并段。然后一趟一趟进行归并排序。 110111 两路归并排序的归并树 R1 750 R2 750 R3 750 R4 750 R5 750 R6 750 初始 归并段 R12 1500 R34 1500 R56 1500 R1234 3000 R123456 4500 第一趟 归并结果 第二趟 归并结果 第三趟 归并结果 • 若把内存区域等份地分为 3 个缓冲区。其中的 两个为输入缓冲区, 一个为输出缓冲区, 可以在 内存中利用简单两路归并函数 merge( ) 实现两 路归并。 • 首先, 从参加归并排序的两个输入归并段 R1 和 R2 中分别读入一块, 放在输入缓冲区1 和输入缓 冲区2 中。然后在内存中进行两路归并，归并 结果顺序存放到输出缓冲区中。 112 输入缓冲区 2 输入缓冲区 1 输出缓冲区 • 若总记录个数为 n，磁盘上每个页块可容纳 b 个 记录，内存缓冲区可容纳 i 个页块，则每个初始 归并段长度为 len = i * b，可生成 m = n / len 个等长的初始归并段。 • 在做 2 路归并排序时, 第一趟从 m 个初始归并段 得到 m/2个归并段，以后各趟将从 l (l >1) 个 归并段得到 l/2个归并段。总归并趟数等于归 并树的高度减一： log2m。 • 估计两路归并排序时间 tES 的上界为： tES = m*tIS + d*tIO + S*n*tmg tIS为每个初始归并段进行内排序的时间；d为访问外存块的次数； tmg是取得一个记录的时间；S是归并趟数 113 • 对 4500 个记录排序的例子, 各种操作的计算时 间如下：  读18个输入块, 内部排序6段, 写18个输出块 ＝6 tIS＋36 tIO  成对归并初始归并段 R1～R6 ＝36 tIO＋4500 tmg  归并两个具有1500个记录的归并段R12和R34 ＝24 tIO＋3000 tmg  最后将 R1234 和 R56 归并成一个归并段 ＝ 36 tIO＋4500 tmg • 合计 tES＝6 tIS＋132 tIO＋12000 tmg 114 • 由于 tIO = tseek + tlatency + trw, 其中, tseek和tlatency是 机械动作，而trw、tIS、tmg是电子线路的动作, 所以tIO远远大于tIS和tmg。想要提高外排序的 速度，应着眼于减少d。 • 若对相同数目的记录，在同样页块大小的情 况下做 3 路归并或做 6 路归并(当然, 内存缓冲 区的数目也要变化)，则可做大致比较： 115 归并路数 k 总读写磁盘次数 d 归并趟数 S 2 132 3 3 108 2 6 72 1 • 增大归并路数, 可减少归并趟数, 从而减少总 读写磁盘次数d。 • 对 m 个初始归并段, 做 k 路平衡归并, 一趟可 将 m 个初始归并段归并为 l = m/k个归并段， 以后每一趟归并将 l 个归并段归并成 l = l / k 个归并段，直到最后形成一个大的归并段为 止。归并趟数S＝logkm＝树的高度减一 。 116 k路平衡归并 (k-way Balanced merging) • 做 k 路平衡归并时, 如果有 m 个初始归并段, 则 相应的归并树有 logkm+1 层, 需要归并 logkm趟。下图给出对有 36 个初始归并段的 文件做 6 路平衡归并时的归并树。 117 • 做内部k路归并时, 在k个记录中选择最小者， 需要顺序比较 k-1 次。每趟归并n个记录需要 做 (n-1)*(k-1) 次比较, S 趟归并总共需要的 比较次数为: S*(n-1)*(k-1) = logkm* (n-1) * (k-1) = log2m* (n-1) * (k-1) / log2k • 在初始归并段个数 m 与记录个数 n 一定时, log2m*(n-1) = const, 而 (k-1) / log2k随着k 的增大而增大。因此, 增大归并路数 k, 会使得 内部归并的时间增大。 118 • 使用“败者树”从k个归并段中选最小者, 当k 较大时 (k ≥6)，选出排序码最小的记录只需比 较 log2k次。 S*(n-1)*log2k= logkm* (n-1) * log2k = log2m* (n-1) * log2k/ log2k = log2m* (n-1) • 排序码比较次数与 k 无关, 总的内部归并时间 不会随 k 的增大而增大。 • 下面讨论利用败者树在 k 个输入归并段中选择 最小者，实现归并排序的方法。 119 • 败者树是一棵完全二叉树。其中  每个叶结点存放各归并段在归并过程中当 前参加比较的记录；  每个非叶结点存放它两个子女结点中记录 排序码大的结点(即败者)；（假设需要按从 小到大排序） • 在根结点的上一层另外增加一个结点，存放树 中当前记录排序码最小的结点 (最小记录)。 • 败者树与胜者树的区别在于一个选择了败者 (排序码大者), 一个选择了胜者(排序码小者)。 120121 Run0: {17, 21, ∞} Run1: {05, 44, ∞} Run2: {10, 12, ∞} Run3: {29, 32, ∞} Run4: {15, 56, ∞} 冠军 (最小记录), 输出段1的当前记录 29 32 ∞ 15 56 ∞ 17 21 ∞ 05 44 ∞ 10 12 ∞ 15 100517 29 3 0 2 4 1 k3 k4 k0 k1 k2 Run3 Run4 Run0 Run1 Run2 ls1 ls0 ls2 ls4 ls3选中 示例：设有 5 个初始归并段, 它们 中各记录的排序码分别是（增加一 个关键码为∞的记录表示末尾）： 122 次最小记录 输出段1的最小记录， 段1的下一记录参选， 调整败者树 29 32 ∞ 15 56 ∞ 17 21 ∞ 05 44 ∞ 10 12 ∞ 15 104417 29 3 0 1 4 2 k3 k4 k0 k1 k2 Run3 Run4 Run0 Run1 Run2 ls1 ls0 ls2 ls4 ls3 选中 • 败者树的高度为 log2k+1，在每次调整、找下 一 个具有最小排序码记录时, 最多做 log2k次排序 码比较。 • 在内存中应为每一个归并段分配一个输入缓冲区, 其大小应能容纳一个页块的记录, 编号与归并段 号一致。每个输入缓冲区应有一个指针, 指示当 前参加归并的记录。 • 在内存中还应设立一个输出缓冲区, 其大小相当 于一个页块大小。它也有一个缓冲区指针, 指示 当前可存放结果记录的位置。每当一个记录 i 被 选出, 就执行OutputRecord(i)操作, 将记录存放到 输出缓冲区中。 123 • 在实现利用败者树进行多路平衡归并算法时, 把 败者树的叶结点和非叶结点分开定义。 • 败者树叶结点key[]有k+1个, key[0]到key[k-1]存 放各归并段当前参加归并的记录的排序码 ， key[k]是辅助工作单元, 在初始建立败者树时使 用: 存放一个最小的在各归并段中不可能出现的 排序码: -MaxValue。 • 败者树非叶结点 loser[] 有 k 个 , 其中 loser[1] 到 loser[k-1] 存 放各次比较的败者的归并段号 , loser[0]中是最后胜者所在归并段号。另外还有 一个存放各归并段参加归并记录的数组r[k]。 124 • 每选出一个当前排序码最小的记录, 就需要在 将它送入输出缓冲区之后, 从相应归并段的输 入缓冲区中取出下一个参加归并的记录, 替换 已经取走的最小记录, 再从叶结点到根结点, 沿 某一特定路径进行调整, 将下一个排序码最小 记录的归并段号调整到loser[0]中。 • 段结束标志MaxNum升入loser[0], 排序完成。 125126 利用败者树进行 5 路平衡归并的过程 (1) 初始状态 (2) 加入15, 调整 29 15 5 17 5 05 5 10 -∞ 5 5 k3 k4 k5 k0 k1 k2 ls1 ls0 ls2 ls3 ls4 10 k2 5 05 ls3 k1 17 5 k0 ls2 4ls4 15 k4 -∞ k5 29 k3 5ls1 5ls 0 127 (3)加入29, 调整 (4) 加入10, 调整 29 15 3 17 4 05 5 10 -∞ 5 5 k3 k4 k5 k0 k1 k2 ls1 ls0 ls2 ls3 ls4 10 k2 2 05 ls3 k1 17 4 k0 ls2 3ls4 15 k4 -∞ k5 29 k3 5ls1 5ls0 128 29 15 3 17 4 05 2 10 -∞ 1 5 k3 k4 k5 k0 k1 k2 ls1 ls0 ls2 ls3 ls4 10 k2 2 05 ls3 k1 17 0 k0 ls2 3ls4 15 k4 -∞ k5 29 k3 4ls1 1ls0 (5) 加入05, 调整 (6) 加入17, 调整 输出05 129 (7) 输出05后调整 (8) 输出10后调整 29 15 3 17 0 44 1 10 4 2 k3 k4 k0 k1 k2 ls1 ls0 ls2 ls3 ls4 12 k2 1 44 ls3 k1 17 0 k0 ls2 3ls4 15 k4 29 k3 4ls1 2ls0 输入44 输出12输出10 输入12 130 29 15 3 17 0 44 2 ∞ 1 4 k3 k4 k0 k1 k2 ls1 ls0 ls2 ls3 ls4 ∞ k2 2 44 ls3 k1 17 3 k0 ls2 4ls4 56 k4 29 k3 1ls1 0ls0 输入∞ 输出17输出15 输入56 (9) 输出12后调整 (10) 输出15后调整 131 29 56 4 21 3 44 2 ∞ 1 0 k3 k4 k0 k1 k2 ls1 ls0 ls2 ls3 ls4 ∞ k2 2 44 ls3 k1 ∞ 0 k0 ls2 4ls4 56 k4 29 k3 1ls1 3ls0 输入21 输出29输出21 输入∞ (11) 输出17后调整 (12) 输出21后调整 132 (13) 输出29后调整 (14) 输出32后调整 32 56 4 ∞ 0 44 2 ∞ 1 3 k3 k4 k0 k1 k2 ls1 ls0 ls2 ls3 ls4 ∞ k2 2 44 ls3 k1 ∞ 0 k0 ls2 3ls4 56 k4 ∞ k3 4ls1 1ls0 输入32 输出44输出32 输入∞ 133 (15) 输出44后调整 (16) 输出56后调整 ∞ 56 3 ∞ 0 ∞ 2 ∞ 1 4 k3 k4 k0 k1 k2 ls1 ls0 ls2 ls3 ls4 ∞ k2 2 ∞ ls3 k1 ∞ 0 k0 ls2 3ls4 ∞ k4 ∞ k3 1ls1 4ls0 输出∞， 结束 输出56 输入∞ 输入∞ • 归并路数 k 不是越大越好。归并路数 k 增大, 相应需增加输入缓冲区个数。如果可供使用的 内存空间不变, 势必要减少每个输入缓冲区的 容量, 使内外存交换数据的次数增大。 134","libVersion":"0.2.4","langs":""}