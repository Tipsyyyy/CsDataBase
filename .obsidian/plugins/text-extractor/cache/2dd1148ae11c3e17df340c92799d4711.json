{"path":"课程/金融大数据/课件/17 Spark Basic Programming (I).pdf","text":"Sp a r k 基础编程 (I ) 摘要 ¨ Sp a r k 安装运行 ¨ Sp a r k 编程模型 ¨ Sp a r k 编程示例 摘要 ¨ Sp a r k 安装运行 ¨ Sp a r k 编程模型 ¨ Sp a r k 编程示例 Sp a r k 安装运行 ¨ Sp a r k 系统运行所需的软件环境 ¨ St a n d a l on e 模式安装 Sp a r k ¨ Sp a r k 和集群管理工具的结合 4 S p a r k r u n s o n Ja va 8 / 1 1 , S ca l a 2 . 1 2 , P yt h o n 3 . 6 + a n d R 3 . 5 + . P yt h o n 3 . 6 su p p o r t i s d e p r e ca t e d a s o f S p a r k 3 . 2 . 0 . Ja va 8 p r i o r t o ve r si o n 8 u 2 0 1 su p p o r t i s d e p r e ca t e d a s o f S p a r k 3 . 2 . 0 . F o r t h e S ca l a A P I , S p a r k 3 . 2 . 0 u se s S ca l a 2 . 1 2 . Y o u w i l l n e e d t o u se a co m p a t i b l e S ca l a ve r si o n ( 2 . 1 2 . x) . Sp a r k 系统运行的软件环境 ¨ 操作系统 ¤ Sp a r k 是运行在 Ja v a 虚拟机上的，因此在 Wi n d o w s 、 Li n u x 和 Mac OS 上都能够安 装 Sp a r k 。但由于 Sp a r k 中的一些工具和脚本（如启动脚本）是针对 Li n u x 环境 编写的，因此建议在 Li n u x 操作系统上安装和运行 Sp a r k 。 ¨ SSH ¤ 主要用于在集群环境下远程管理 Sp a r k 节点以及 Sp a r k 节点间的安全共享访问。 ¨ Ja v a ¤ 主要用于运行 Sp a r k 以及使用 Sp a r k 提供的 J a v a A PI 进行开发，如 Ja v a 8 5 Sp a r k 系统运行的软件环境 ¨ Sc a l a ¤ 除了 J a v a A PI 以外， Sp a r k 还向程序员提供了 Sc a l a A PI ，如要用 Sc a l a 开发 Sp a r k 应用，则需要安装 Sc a l a ¨ Pyt h on ¤ 类似的， Sp a r k 也提供了 Pyt h on A PI ，如要用 Pyt h on 开发 Sp a r k 应用，则需要安 装 Pyt h on ¨ HDF S ¤ Sp a r k 是一个分布式计算引擎，其输入输出数据可以保存在分布式文件系统 中。这里推荐使用 H a d oop 中的 HDF S 。 6 St a n d a l on e 模式 ¨ Sp a r k 框架本身自带了完整的资源调度管理服务，可以独立部署 到一个集群中，而不需要依赖其他系统来为其提供资源管理调度 服务。 7 St a n d a l on e 模式的安装 ¨ 软件环境准备 ¨ 下载编译好的 Sp a r k 包 ¨ 修改 Sp a r k 配置文件 ¨ 启动 Sp a r k ¨ 运行测试程序 ¨ 查看集群状态 8 软件环境的准备 ¨ 安装 SSH ， Ja v a ， HDF S （必须） ¨ 安装 Sc a l a ，建议 Sc a l a 2. 12 （可选） ¨ 安装 Pyt h on ，建议 PySp a r k （可选） ¤ pi p in s t a ll p ys p a r k ¤ Pyt h on 3 . 6 + 9 下载编译好的 Sp a r k 包 ¨ 下载地址： h t t p : //s p a r k . a p a c h e . or g /d o w n l oa d s . h t m l 10 修改 Sp a r k 配置文件 ¨ Sp a r k 的配置文件存放在 Sp a r k 安装目录下的 c on f 目录中： ¤ sp a r k - en v . s h ：主要完成 Sp a r k 环境变量设置 ¤ sp a r k - d ef a u l t s . c on f ： Sp a r k 默认配置 ¤ w or k er s ：主要完成 W or k er 节点的 IP 设置 11 启动 Sp a r k ¨ Sp a r k 提供了一系列用于启动 / 停止的脚本 ¤ sbi n /s t a r t - m a s t er . s h ：启动 M a s t er ¤ sbi n /s t a r t - s l a v es . s h ：启动所有的 W or k er ¤ sbi n /s t a r t - all.sh ：启动 M a s t er 和所有的 W or k er ¤ sbi n /s t op - m a s t er . s h ：停止 M a s t er ¤ sbi n /s t op - s l a v es . s h ：停止所有的 W or k er ¤ sbi n /s t op - all.sh ：停止 M a s t er 和所有的 W or k er ¨ 执行启动脚本后，可以使用 J PS 命令查看进程信息。若 Sp a r k 正常启 动，那么在 M a s t er 节点会有一个 M a s t er 进程，在每个 W or k er 节点会 有 W or k er 进程。 12 We b UI ¨ Sp a r k M a s t er ¤ sbi n /s t a r t - all.sh ：启动 M a s t er 和所有的 W or k er ¤ h t t p : //l oc a l h os t : 8 0 8 0 ¨ Sp a r k H i s t or y Ser v er ¤ sbi n /s t a r t - h i s t or y - s er v er . s h ：启动 H i s t or y Ser v er n 配置 spar k - en v . s h n e xp or t SP A RK _H I ST O R Y _O PT S= “ - D s p a r k . h i s t or y . u i . p or t =1 8 0 8 0 - D s p a r k . h i s t or y . f s . l og D i r ec t or y = < 本 地文件目录或 HDF S 目录 >\" n 配置 spar k - d ef a u l t s . c on f n s p a r k . ev en t L og . en a b l ed tr ue n s p a r k . ev en t L og . d i r < 本地文件目录或 HDF S 目录 > ¤ h t t p : //l oc a l h os t : 1 8 0 8 0 13 运行测试程序 ¨ 启动 Sp a r k ，可以向 Sp a r k 集群提交一个测试程序 ¤ . /b i n /r u n - e xa m p l e Sp a r k Pi 10 ¨ 运行 Sh el l ¤ . /b i n /s p a r k - s h el l ¨ 退出 Sh el l ¤ sc a l a >: qu i t 14 We b UI ¨ 在 Sp a r k Sh el l 运行期间，可以用浏览器查看 Sp a r k 状态 ¤ h t t p : //l oc a l h os t : 4 0 4 0 15 We b UI 16 We b UI 17 Sp a r k 本地部署模式 ¨ l oc a l ¤ 运行该模式非常简单，只需要把 Sp a r k 的安装包解压后，改一些常用的 配置即可使用，而不用启动 Sp a r k 的 M a s t er 、 W or k er 守护进程 ( 只有集 群的 St a n d a l on e 方式时，才需要这两个角色 ) ，也不用启动 H a d oop 的各 服务（除非你要用到 HDF S ）。 ¤ 常用于本地开发测试，本地还分为 l oc a l 单线程和 l oc a l - c l u s t er 多线 程。 模式： n l oc a l ： 只启动一个 e x ec u t or n l oc a l [ N ] ：启动 N 个 e x ec u t or ，用单机的多个线程来模拟 sp a r k 分布式计算，通常 用来检验开发出来的程序逻辑上有没有问题。 n l oc a l [ * ] ： 启动跟 cp u 数目相同的 e x ec u t or 18 Sp a r k 集群部署模式 ¨ St a n d a l on e ¤ Sp a r k 自带的一种集群管理模式，即独立模式，自带完整的服务，可单独部 署到一个集群中，无需依赖任何其他资源管理系统。它是 Sp a r k 实现的资源 调度框架，其主要的节点有 D r i v er 节点、 M a s t er 节点和 W or k er 节点。 St a n d a l on e 模式也是最简单最容易部署的一种模式。 ¨ Sp a r k on Y A RN ¨ Sp a r k on K u b er n et es 19 Sp a r k 和集群管理工具的结合 ¨ 管理的难题 ¨ 统一资源管理平台和集装箱思想 ¨ 使用 Y A RN 或 K u b er n et es 运行 Sp a r k ¨ 使用 D oc k er 部署 Sp a r k 20 Sp a r k 和集群管理工具的结合 ¨ 不同计算引擎各有所长，真实应用中往往需要同时使用不同的计 算框架； ¨ 不同框架和应用会争抢资源，互相影响，使得管理难度和成本增 加； ¨ 应用往往在单机上开发，在小规模集群上测试，在云上运行。在 不同环境下部署时总要经历复杂而且痛苦的配置过程。 21 Sp a r k 和集群管理工具的结合 ¨ 统一的资源管理平台将资源独立管理 ¤ Y A RN ， K u b er n et es ¨ 集装箱思想 ¤ 将应用和依赖“装箱”，一次配置，随处 部署 ¤ D oc k er ¨ 通过资源管理可在同一个集群平台上 部署不同的计算框架和应用，从而实 现多租户资源共享 22 Sp a r k 和集群管理工具的结合 ¨ 资源管理 ：所有接入的框架要先向它申请资源，申请成功之后，再由平台自身的调度器决定 资源交由哪个任务使用 ¨ 资源共享 ：通过资源管理可在同一集群平台上部署不同的计算框架和应用，实现多租户资源 共享 ¨ 资源隔离 ：不同的框架中的不同任务往往需要的资源（内存， C PU ，网络 IO 等）不同，它们运 行在同一个集群中，会相互干扰。所以需要实现资源隔离以免任务之间由资源争用导致效率 下降 ¨ 提高资源利用效率 ：当将各种框架部署到同一个大的集群中，进行统一管理和调度后，由于 各种作业交错且作业提交频率大幅度升高，则为资源利用率的提升增加了机会 ¨ 扩展和容错 ：统一资源管理平台不能影响到上层框架的可扩展性和容错，同时自身也应具备 良好的可扩展性和容错性 23 Y A RN ¨ Y A RN 是 H a d oop 2 . 0 时代的编程架构，被 称为新一代 M a p R ed u c e 。其核心思想是 将原 M a p R ed u c e 框架中的 J ob T r a c k er 和 T a s k T r a c k er 重新设计，变成了： ¤ R es ou r c eM a n a g er ¤ A p p l i c a t i on M a s t er ¤ N od eM a n a g er ¨ 除了支持 H a d oop 2 . 0 以外，实际上， Y A RN 还是一个独立的底层资源管理框 架，可用于支持和运行其他各种计算框 架，例如 Sp a r k 24 Y A RN ¨ R es ou r c eM a n a g er 是一个中心的服务，它负责作业与资源的调度，负责调度、 启动每一个 J ob 所属的 A p p l i c a t i on M a s t er ，监控 A p p l i c a t i on M a s t er 的存在情况。 接收 J ob Su b m i t t er 提交的作业，按照作业的上下文环境 ( C on t e xt ) 信息，以及从 N od eM a n a g er 收集来的状态信息，启动调度过程，分配一个 C on t a i n er 作为 A p p l i c a t i on M a s t er ¨ A p p l i c a t i on M a s t er 负责一个 J ob 生命周期内的所有工作，类似老的框架中的 J ob T r a c k er 。但注意每一个 J ob （不是每一种）都有一个 A p p l i c a t i on M a s t er ，它 可以运行在 R es ou r c eM a n a g er 以外的机器上 ¨ N od eM a n a g er 功能比较专一，就是负责 C on t a i n er 状态的维护，并向 R es ou r c eM a n a g er 保持心跳 25 Sp a r k on Y A RN 26 Sp a r k on Y A RN ¨ 1. 在 spar k - en v . s h 里面，设置 H A D O O P_C O N F _D I R 为 h a d oop 配置文件的目录 ¨ 2. 在 spar k - d ef a u l t . c on f 里设置其它可配置选项。具体请参考 s p a r k . a p a c h e . or g /d oc s /l a t es t /r u n n i n g - on - ya r n . h t m l ¨ 3. 试运行 ¤ 使用 -- m a s t er 选项选择 Sp a r k on Y A RN 的运行模式，共有 ya r n - c l i en t 和 ya r n - c l u s t er 两种选项。 ¤ 例如： sp a r k - su b m i t -- cl as s p a t h . t o . y ou r . C l a s s -- m a s t er y a r n - c l u s t er [ op t i on s ] < a p p j a r > ¤ 或 sp a r k - s h el l -- m a s t er y a r n - c l i en t ¤ 其中， ya r n - c l u s t er 是指 ya r n 的 a p p l i c a t i on m a s t er 进程中包含 s p a r k d r i v er ，发起任务的客户端可以在任务 初始化完成之后离开，不和 ya r n 维持通信。而 ya r n - c l i en t 模式中， s p a r k d r i v er 会运行在客户端，故而客 户端不能离开。 27 Sp a r k on Y A RN ¨ C l i en t 模式 28 过程： 1. 客户端生成作业信息提交给 R es ou r c eM a n a g er ( RM ) 2 . RM 在本地 N od eM a n a g er 启动 c on t a i n er 并将 A p p l i c a t i on M a s t er ( A M ) 分配给该 N od eM a n a g er (NM) 3. N M 接收到 RM 的分配，启动 A p p l i c a t i on M a s t er 并初 始化作业，此时这个 NM 就称为 D r i v er 4 . A p p l i c a t i on 向 RM 申请资源，分配资源同时通知其 他 N od eM a n a g er 启动相应的 E x ec u t or 5 . E x ec u t or 向本地启动的 A p p l i c a t i on M a s t er 注册汇报 并完成相应的任务 Sp a r k on Y A RN ¨ C l u s t er 模式 29 过程： 1. 客户端生成作业信息提交给 R es ou r c eM a n a g er ( RM ) 2 . RM 在某一个 N od eM a n a g er ( 由 Ya r n 决定 ) 启动 c on t a i n er 并将 A p p l i c a t i on M a s t er ( A M ) 分配给该 N od eM a n a g er (NM) 3. N M 接收到 RM 的分配，启动 A p p l i c a t i on M a s t er 并初 始化作业，此时这个 NM 就称为 D r i v er 4 . A p p l i c a t i on 向 RM 申请资源，分配资源同时通知其 他 N od eM a n a g er 启动相应的 E x ec u t or 5 . E x ec u t or 向 NM 上的 A p p l i c a t i on M a s t er 注册汇报并完 成相应的任务 Sp a r k on Y A RN 30 H a d oop 和 Sp a r k 的统一部署 31 K u b er n et es ¨ K u b er n et es 是 G oog l e 基于 Bor g 开源的容器编排调度引擎，支持自 动化部署、大规模可伸缩、应用容器化管理。在生产环境中部署 一个应用程序时，通常要部署该应用的多个实例以便对应用请求 进行负载均衡。 ¨ 在 K u b er n et es 中，我们可以创建多个容器，每个容器里面运行一 个应用实例，然后通过内置的负载均衡策略，实现对这一组应用 实例的管理、发现、访问，而这些细节都不需要运维人员去进行 复杂的手工配置和处理。 32 K u b er n et es 33 Sp a r k on K u b er n et es 34 Sp a r k on K u b er n et es 35 Sp a r k on K u b er n et es 36 ¨ K u b er n et es 原生调度：不再需要二层调度，直接使用 K u b er n et es 的资源调度功能， 跟其他应用共用整个 K u b er n et es 管理的资源池； ¨ 资源隔离，粒度更细：原先 Ya r n 中的 q u eu e 在 Sp a r k on K u b er n et es 中已不存在， 取而代之的是 K u b er n et es 中原生的 n a m es p a c e ， 可以为每个用户分别指定一个 n a m es p a c e ， 限制用户的资源 q u ot a ； ¨ 细粒度的资源分配：可以给每个 spar k 任务指定资源限制，实际指定多少资源 就使用多少资源，因为没有了像 Ya r n 那样的二层调度（圈地式的），所以可以 更高效和细粒度的使用资源； Sp a r k on K u b er n et es ¨ 监控的变革：因为做到了细粒度的资源分配，所以可以对用户提交的每一个任 务做到资源使用的监控，从而判断用户的资源使用情况，所有的 m et r i c 都记录 在数据库中，甚至可以为每个用户的每次任务提交计量； ¨ 日志的变革：用户不再通过 Y ar n 的 web 页面来查看任务状态，而是通过 p od 的 l og 来查看，可将所有的 K u b er n et es 中的应用的日志等同看待收集起来，然后可 以根据标签查看对应应用的日志； 37 更高效地获取资源、更有效率地获取资源！ 摘要 ¨ Sp a r k 安装运行 ¨ Sp a r k 编程模型 ¨ Sp a r k 编程示例 Sp a r k 编程模型与编程接口 ¨ Sp a r k 为了解决以往分布式计算框架存在的一些问题 ( 重复计算、 资源共享、系统组合 ) ，提出了一个分布式数据集的抽象数据模 型： ¤ RD D ( R es i l i en t D i s t r i b u t ed D a t a s et s ) : 弹性分布式数据集 39 Sp a r k 编程模型与编程接口 ¨ RD D 是一种分布式的内存抽象，允许在大型集群上执行基于内存 的计算（ In - M em or y C om p u t i n g ），同时还保持了 M a p R ed u c e 等数 据流模型的容错特性。 ¨ RD D 只读、可分区，这个数据集的全部或部分可以缓存在内存中， 在多次计算间重用。 ¨ 简单来说， RD D 是 M a p R ed u c e 模型的一种简单的扩展和延伸。 40 Sp a r k 的基本编程方法与示例 ¨ 在一个存储于 HDF S 的 L og 文件中，计算出现 E RRO R 的行数，本程序使用 sc al a 语言编写，这个语言也是 Sp a r k 开发和编程 的推荐语言。 d ef ma i n ( ar gs : A r r a y[ St r i n g ] ) { // 定义一个 ma i n 函数 // 定义一个 s p a r k C on f ，提供 Sp a r k 运行的各种参数，如程序名称、用户名称等 va l c on f = n e w Sp a r k C on f (). s et A p p N a m e ( \" Sp a r k Pi \" ) // 创建 Sp a r k 的运行环境，并将 Sp a r k 运行的参数传入 Sp a r k 的运行环境中 va l sc = n e w Sp a r k C on t e xt ( c on f ) // 调用 Sp a r k 的读文件函数，从 HDF S 中读取 L og 文件，输出一个 RD D 类型的实例： f i l eRD D 。具体类型： RD D [ St r i n g ] va l f i l eRD D = s c . t e xt F i l e (“ hd f s : ///r oot /L og ” ) // 调用 RD D 的 f i l t er 函数，过滤 f i l eRD D 中的每一行，如果该行中含有 E RRO R ，保留；否则，删除。生成另一个 RD D 类型的实例： f i l t er RD D 。具 体类型 : RD D [ St r i n g ] // 注： l i n e= > l i n e . c on t a i n s ( “ E RRO R” ) 表示对每一个 lin e 应用 c on t a i n s ( ) 函数 va l f i l t er RD D = f i l eRD D . f i l t er ( l i n e= > l i n e . c on t a i n s ( “ E RRO R” ) ) // 统计 f i l t er RD D 中总共有多少行， r es u l t 为 In t 类型 va l r es u l t = f i l t er RD D . c ou n t () s c . s t op () // 关闭 Sp a r k } 41 RD D 的创建 ¨ va l f i l e= s c . t e xt F i l e (“ hd f s : ///r oot /L og ” ) 这句代码创建了一个 RD D ，那么 RD D 是怎么创建的？又有那些注意事项？ ¨ 从形式上看， RD D 是一个分区的只读记录的集合。因此， RD D 只能通过两种方 式创建： ¤ 1 、通过从存储器中读取，例如上述代码，从 HDF S 中读取。 例如： va l rdd = s c . p a r a l l el i z e ( 1 t o 1 0 0 , 2 ) // 生成一个 1 到 100 的数组，并行化成 RD D ¤ 2 、其他 RD D 的数据上的 确定性操作 来创建 ( 即 T r a n s f or m a t i on ) 。 例如： va l f i l t er RD D = f i l e . f i l t er ( l i n e= > l i n e . c on t a i n s ( “ E RRO R” ) ) // 通过 fi l e 的 f i l t er 操作生成一个新的 f i l t er RD D 42 RD D 的操作 ¨ 转换（ t r a n s f or m a t i on ） ：这是一种惰性操作，即使用这种方法时，只是定义了 一个新的 RD D ，而并不马上计算新的 RD D 内部的值。 ¤ 例： va l f i l t er RD D = f i l eRD D . f i l t er ( l i n e= > l i n e . c on t a i n s ( “ E RRO R” ) ) ¤ 上述这个操作对于 Sp a r k 来说仅仅记录从 fi l e 这个 RD D 通过 f i l t er 操作变换到 f i l t er RD D 这个 RD D 的变换，并不计算 f i l t er RD D 的结果。 ¨ 动作（ a c t i on ） ：立即计算这个 RD D 的值，并返回结果给程序，或者将结果写 入到外存储中。 ¤ 例： va l r es u l t = f i l t er RD D . c ou n t () ¤ 上述操作计算最终的 r es u l t 结果是多少，包括前边 t r a n s f or m a t i on 时的变换。 43 RD D 的操作 44 RD D 的 t r a n s f or m a t i on 图示 ¨ va l f i l t er RD D = f i l eRD D . f i l t er ( line => l i n e . c on t a i n s ( “ E RRO R” ) ) ¨ 设 f i l eRD D 中包含以下 7 行数据： ¨ ” E RRO R1 E RRO R2 E RRO R3 T RU E 4 E RRO R5 E RRO R6 T RU E 7 ” 45 RD D 的 a c t i on 图示 ¨ 例： va l r es u l t = f i l t er RD D . c ou n t () 46 Sp a r k 支持的一些常用 t r a n s f or m a t i on 操作 47 Sp a r k 支持的一些常用 t r a n s f or m a t i on 操作Sp a r k 支持的一些常用 t r a n s f or m a t i on 操作Sp a r k 支持的一些常用 a c t i on 操作 50 Sp a r k 支持的一些常用 a c t i on 操作 51 RD D 之间的依赖关系 ¨ 在 Sp a r k 中存在两种类型的依赖： ¤ 窄依赖：父 RD D 中的一个 P a r t i t i on 最多被子 RD D 中的一个 P a r t i t i on 所依赖 n 例： va l f i l t er RD D = f i l eRD D . f i l t er ( l i n e= > l i n e . c on t a i n s ( “ E RRO R” ) ) ¤ 宽依赖：父 RD D 中的一个 P a r t i t i on 被子 RD D 中的多个 P a r t i t i on 所依赖 52 根据 RD D 分区的依赖关系划分阶段（ St a g e ） ¨ Sp a r k 通过分析各个 RD D 的依赖关系生成了 DA G ，再通过分析各个 RD D 中的分区 之间的依赖关系来决定如何划分阶段，具体划分方法是：在 DA G 中进行反向解 析，遇到宽依赖就断开，遇到窄依赖就把当前的 RD D 加入到当前的阶段中；将 窄依赖尽量划分在同一个阶段中，可以实现流水线计算。 ¨ 把一个 DA G 图划分成多个“阶段”以后，每个阶段都代表了一组关联的、相互 之间没有 Sh u f f l e 依赖关系的任务组成的任务集合。每个任务集合会被提交给任 务调度器（ T a s k Sc h ed u l er ）进行处理，由任务调度器将任务分发给 E x ec u t or 运行。 53 根据 RD D 分区的依赖关系划分阶段 54 RD D 的运行 55 RD D 的运行 ¨ Sp a r k 采用惰性机制， T r a n s f or m a t i on 算子的代码不会被立即执行， 只有当遇到第一个 A c t i on 算子时，会生成一个 J ob ， 并执行前面的一 系列 T r a n s f or m a t i on 操作。一个 J ob 包含 N 个 T r a n s f or m a t i on 和 1 个 A c t i on 。 ¨ 每个 J ob 会分解成一系列可并行处理的 Ta s k ， 然后将 Ta s k 分发到不同 的 E x ec u t or 上运行。 56 RD D 的运行 ¨ Ta s k 为一个 St a g e 中的一个执行单元，也是 Sp a r k 中的最小执行单元，一般来说， 一个 RD D 有多少个 P a r t i t i on ， 就会有多少个 Ta s k ， 因为每一个 Ta s k 只是处理一 个 P a r t i t i on 上的数据。在一个 St a g e 内，所有的 RD D 操作以串行的 Pi p el i n e 方式， 由一组并发的 Ta s k 完成计算，这些 Ta s k 的执行逻辑完全相同，只是作用于不同 的 P a r t i t i on 。 每个 St a g e 里面 Ta s k 的数目由该 St a g e 最后一个 RD D 的 P a r t i t i on 个数 决定。 ¨ Sp a r k 中 Ta s k 分为两种类型， Sh u f f l eM a p T a s k 和 R es u l t T a s k ， 位于最后一个 St a g e 的 Ta s k 为 R es u l t T a s k ， 其他阶段的属于 Sh u f f l eM a p T a s k 。 Sh u f f l eM a p T a s k 和 R es u l t T a s k 分别类似于 H a d oop 中的 Map 和 R ed u c e 。 57 RD D 的运行 58 RD D 的容错实现 ¨ 在 RD D 中，存在两种容错的方式： ¤ L i n ea g e （血统系统、依赖系统） n RD D 提供一种基于粗粒度变换的接口，这使得 RD D 可以通过记录 RD D 之间的变 换，而不需要存储实际的数据就可以完成数据的恢复，使得 Sp a r k 具有高效的 容错性。 ¤ C h ec k P oi n t （检查点） n 对于很长的 l i n ea g e 的 RD D 来说，通过 l i n ea g e 来恢复耗时较长。因此，在对包 含宽依赖的长血统的 RD D 设置检查点操作非常有必要。 n 由于 RD D 的只读特性使得 Sp a r k 比常用的共享内存更容易完成 c h ec k p oi n t 。 59 RD D 的容错实现 ¨ 细粒度容错 60 在窄依赖中，在子 RD D 的分区丢失，要重算父 RD D 分区时，父 RD D 相应分区的 所有数据都是子 RD D 分区的数据，并不存在冗余计算。 RD D 的容错实现 ¨ 细粒度容错 61 在宽依赖情况下，丢失一个子 RD D 分区，重算的每个父 RD D 的每个分区的所 有数据并不是都给丢失的子 RD D 分区用的，会有一部分数据相当于对应的 是未丢失的子 RD D 分区中需要的数据，这样就会产生冗余计算开销和巨大 的性能浪费。 RD D 持久化 ¨ Sp a r k 提供了三种对持久化 RD D 的存储策略： ¤ 未序列化的 Ja v a 对象，存在内存中 n 性能表现最优，可以直接访问在 JA V A 虚拟机内存里的 RD D 对象。 ¤ 序列化的数据，存于内存中 n 取消 JVM 中的 RD D 对象，将对象的状态信息转换为可存储形式，减小 RD D 的存储开销，但 使用时需要反序列化恢复。 n 在内存空间有限的情况下，这种方式可以让用户更有效的使用内存，但是这么做的代价 是降低了性能。 ¤ 磁盘存储 n 适用于 RD D 太大难以在内存中存储的情形，但每次重新计算该 RD D 都会带来巨大的额外开 销。 62 RD D 持久化 sc al a > va l lis t = L is t ( \" H a d oop \" , \" Sp a r k \" , \" H i v e \") l i s t : L i s t [ St r i n g ] = L i s t ( H a d oop , Sp a r k , H i v e) sc al a > va l rdd = s c . p a r a l l el i z e (l i s t) rdd : or g . a p a c h e . s p a r k . r d d . RD D [ St r i n g ] = P a r a l l el C ol l ec t i on RD D [ 2 2 ] a t p a r a l l el i z e a t < c on s ol e> : 2 9 sc al a > rdd. c ac h e () // 会调用 p er s i s t ( M E M O R Y _O N L Y ) ，但是，语句执行到这里，并不会缓存 rdd ，这时 rdd 还没有被计算生 成 sc al a > pri n tl n ( r d d . c ou n t ()) // 第一次行动操作，触发一次真正从头到尾的计算，这时才会执行上面的 rdd. c ac h e () ，把这个 rdd 放到缓存中 3 sc al a > pri n tl n ( r d d . c ol l ec t (). m k St r i n g (\" , \" )) // 第二次行动操作，不需要触发从头到尾的计算，只需要重复使用上面缓存中的 rdd H a d oop , Sp a r k , H i v e 63 完整的存储级别介绍 64 RD D 内部设计 ¨ 每个 RD D 都包含： ¤ 一组 RD D 分区（ p a r t i t i on ），即数据集的原子组成部分 ¤ 对父 RD D 的一组依赖，这些依赖描述了 RD D 的 L i n ea g e ¤ 一个函数，即在父 RD D 上执行何种计算 ¤ 元数据，描述分区模式和数据存放的位置 65 RD D 内部接口 66 分区 ¨ RD D 是弹性分布式数据集，通常 RD D 很大，会被分成很 多个分区，分别保存在不同的节点上。 RD D 分区的一个 分区原则是使得分区的个数尽量等于集群中的 C PU 核心 （ c or e ）数目。 p a r t i t i on 是 RD D 的最小单元， RD D 是由分 布在各个节点上的 p a r t i t i on 组成的。 p a r t i t i on 的数量决定 了 tas k 的数量，每个 tas k 对应着一个 p a r t i t i on 。 ¨ 对于不同的 Sp a r k 部署模式而言，都可以通过设置 s p a r k . d ef a u l t . p a r a l l el i s m 这个参数的值，来配置默认的分 区数目。 67 分区 ¨ 因此，对于 p a r a l l el i z e 而言，如果没有在方法中指定分区数，则默认为 s p a r k . d ef a u l t . p a r a l l el i s m sc a l a > va l a r r a y = A r r a y( 1 , 2, 3, 4, 5) a r r a y: A r r a y[ In t ] = A r r a y( 1 , 2 , 3 , 4 , 5 ) sc a l a > va l rd d = s c . p a r a l l el i z e (a r r a y , 2 ) # 设置两个分区 rd d : or g . a p a c h e . s p a r k . r d d . RD D [ In t ] = P a r a l l el C ol l ec t i on RD D [ 1 3 ] a t p a r a l l el i z e a t < c on s ol e> : 2 9 ¨ 对于 t e xt F i l e 而言，如果没有在方法中指定分区数，则默认为 m i n ( d ef a u l t P a r a l l el i s m , 2 ) ，其中， d ef a u l t P a r a l l el i s m 对应的就是 s p a r k . d ef a u l t . p a r a l l el i s m 。 ¨ 如果是从 HDF S 中读取文件，则分区数为文件分片数 ( 比如， 1 2 8 M B/ 片 ) 。 68 Sp a r k 编程接口 ¨ Sp a r k 用 Sc a l a 语言实现了 RD D 的 A PI ¨ Sc a l a 是一种基于 JV M 的静态类型、函数式、面向对象的语言 ¨ Sc a l a 具有简洁（特别适合交互式使用）、有效（因为是静态类 型）等优点 ¨ Sp a r k 支持多种语言的 A PI ： ¤ Sc a l a ¤ Pyt h on ¤ Ja v a ¤ R 69 摘要 ¨ Sp a r k 安装运行 ¨ Sp a r k 编程模型 ¨ Sp a r k 编程示例 Sp a r k 编程示例 ¨ W or d c ou n t ¨ K - M ea n s 聚类 71 W or d C ou n t M a p R ed u c e 代码 ¨ Ma p 类代码 // 定义 Map 类实现字符串分解 pu bl i c stati c c l ass T ok en i z er M a p p er e xt en d s M a p p er < O b j ec t , T e xt , T e xt , Int W r it a b le > { p r i v a t e f i n a l s t a t i c Int W r it a b le on e = n e w Int W r it a b le (1); p r i v a t e T e xt w or d = n e w T e xt ( ) ; // 实现 ma p ( ) 函数 p u b l i c v oi d m a p ( O b j ec t k e y , T e xt v a l u e , C on t e xt c on t e xt ) t h r o w s I O E x c ep t i on , I n t er r u p t ed E x c ep t i on { // 将字符串拆解成单词 St r i n g T ok en i z er it r = n e w St r i n g T ok en i z er ( v a l u e . t oSt r i n g ()); w h i l e ( i t r . h a s M or eT ok en s ()) { w or d . s et ( i t r . n e xt T ok en ()); // 将分解后的一个单词写入 w or d 类 c on t e xt . w r i t e ( w or d , on e) ; // 收集 < k e y , v a l u e> } } } 72 W or d C ou n t M a p R ed u c e 代码 ¨ R ed u c e 类代码 // 定义 R ed u c e 类规约同一 ke y 的 va l u e pu bl i c s t at i c cl as s I n t Su m R ed u c er e xt en d s R ed u c er < T e xt , In t W r it a b le , T e xt , In t W r it a b le >{ p r i v a t e In t W r it a b le r es u l t = n e w In t W r it a b le (); // 实现 r ed u c e( ) 函数 p u b l i c v oi d r ed u c e( T e xt k e y , I t er a b l e < In t W r it a b le > v a l u es , C on t e xt c on t e xt ) t h r o w s I O E x c ep t i on , I n t er r u p t ed E x c ep t i on { in t su m = 0 ; // 遍历迭代 v a l u es ，得到同一 ke y 的所有 va l u e f or ( In t W r it a b le va l : v a l u es ) { s u m + = v a l . g et (); } r es u l t . s et (s um); // 产生输出对 < k e y , v a l u e> c on t e xt . w r i t e ( k e y , r es u l t ) ; } } 73 W or d C ou n t Sp a r k Sc a l a 代码 v al fi l e = s p a r k . t e xt F i l e ( \" hd f s : // . . \" ) v al c ou n t s = fi l e . fl at M ap ( line => line .s plit ( \"\" )) // 分词 . map ( w or d =>( w or d , 1)) // 对应 m a p p er 的工作 . r ed u c eByK e y (_ + _ ) // 相同 ke y 的不同 va l u e 之间进行 ”+ ” 运算 c ou n t s . s a v eA s T e xt F i l e ( \" hd f s : //. . . \" ) 74 这里， ma p 操作表示对列表中的每个元素应用一个函数， 在 sca l a 中，函数可以写成 ” x = > f ( x) ” 的形式，也可以更简洁 地写成 f( _) 。例如 lin e = > l i n e . sp l i t (“ ”) 可以简写为 _ . sp l i t ( “ ” ) 。 flatM ap 是在 ma p 之后增加了一个“扁平化”的操作，将 ma p 之后可能形成的形如 L i st ( L i st ( 1 , 2 ) , L i st ( 3 , 4 ) ) 的数据集 “扁平”为 L i st ( 1 , 2 , 3 , 4 ) 。 W or d C ou n t Sp a r k Ja v a 代码 J a v a RD D < St r i n g > f i l e = s p a r k . t e xt F i l e (\" hd f s : //. . . \" ) ; J a v a RD D < St r i n g > w or d s = fi l e . fl at M ap (n e w F l a t M a p F u n c t i on < St r i n g , St r i n g > ( ) { pu bl i c I t er a b l e < St r i n g > c a l l ( St r i n g s ) { r et u r n A r r a ys . a s L i s t ( s. s p l i t (\" \" )); }}) ; // 对应 fl at M ap ( l i n e = > line .s p lit (“ ” )) 操作 J a v a P a i r RD D < St r i n g , I n t eg er > p a i r s = w or d s . m a p T oP a i r ( n e w P a i r F u n c t i on < St r i n g , St r i n g , I n t eg er > ( ) { p u b l i c T u p l e2 < St r i n g , I n t eg er > c a l l ( St r i n g s ) { r et u r n n e w T u p l e2 < St r i n g , I n t eg er > ( s , 1 ) ; }}) ; // 对应 m a p ( w or d = > ( w or d , 1 ) ) J a v a P a i r RD D < St r i n g , I n t eg er > c ou n t s = p a i r s . r ed u c eByK e y ( n e w F u n c t i on 2 < I n t eg er , I n t eg er > ( ) { p u b l i c I n t eg er c a l l ( I n t eg er a , I n t eg er b ) { r et u r n a + b ; }}) ; // 对应 r ed u c eByK e y ( _ + _) c ou n t s . s a v eA s T e xt F i l e (\" hd f s : //. . . \" ) ; 75 W or d C ou n t Sp a r k J a v a 8 代码 Ja v a 8 引入了 Lam bda 表达式（“闭包”或“匿名方法”）， Lam bda 表达式允许通 过表达式来代替功能接口。 J a v a RD D < St r i n g > l i n es = s p a r k . r ea d (). t e xt F i l e ( args [0]). j a v a RD D (); J a v a RD D < St r i n g > w or d s = l i n es . f l a t M a p ( s - > A r r a ys . a s L i s t ( SP A C E . s p l i t (s ) ). i t er a t or ( ) ) ; J a v a P a i r RD D < St r i n g , I n t eg er > on es = w or d s . m a p T oP a i r ( s - > n e w T u p l e2 < > ( s , 1 ) ); J a v a P a i r RD D < St r i n g , I n t eg er > c ou n t s = on es . r ed u c eByK e y ( (i 1, i 2) - > i 1 + i 2 ); L i s t < T u p l e2 < St r i n g , I n t eg er > > ou t p u t = c ou n t s . c ol l ec t (); f or ( T u p l e2 < ?, ? > t u p l e : ou t p u t ) { Sys t em . ou t . p r i n t l n ( t u p l e . _1 ( ) + \" : \" + t u p l e . _2 ( ) ) ; } 76 W or d C ou n t Sp a r k Pyt h on 代码 f r om __f u t u r e__ i m p or t p r i n t _f u n c t i on i m p or t s ys f r om op er a t or i m p or t a d d f r om p ys p a r k . s q l i m p or t Sp a r k Ses s i on i f __n a m e__ = = \" __m a i n __\" : if l en ( s ys . a r g v ) ! = 2: p r i n t ( \" U s a g e: w or d c ou n t < f i l e> \" , f i l e= s ys . s t d er r ) e xi t ( - 1) 77 W or d C ou n t Sp a r k Pyt h on 代码 spar k = Sp a r k Ses s i on . b u i l d er . a p p N a m e (\" Pyt h on W or d C ou n t \") . g et O r C r ea t e () l i n es = s p a r k . r ea d . t e xt ( s ys . a r g v [1]). rdd. m ap (l am bda r: r[0]) c ou n t s = l i n es . f l a t M a p ( l a m b d a x: x. s p l i t ( ' ' ) ) . m a p ( l a m b d a x: ( x, 1 ) ) \\ . r ed u c eByK e y (add) ou t p u t = c ou n t s . c ol l ec t () f or ( w or d , c ou n t ) i n ou t p u t : pri n t(\" %s: % i \" % ( w or d , c ou n t ) ) c ou n t s . s a v eA s T e xt F i l e ( \" ou t p u t \" ) s p a r k . s t op () 78 spar k - su bm i t \\ -- m a s t er s p a r k : //l oc a l h os t : 7 0 7 7 \\ src / w or d c ou n t . p y \\ < f i l e p a t h or ur l > K - M ea n s 算法示例 ¨ 1. 基于 M a p R ed u c e 的 K - M ea n s 聚类算法 ¨ 2. 基于 Sp a r k 的 K - M ea n s 聚类算法 ¨ 3. 基于 Sp a r k 的 K - M ea n s 聚类算法代码 79 基于 M a p R ed u c e 的 K - M ea n s 聚类算法 ¨ 算法设计思路 ¤ 将所有的数据分布到不同的 M a p R ed u c e 节点上，每个节点只对自己的 数据进行计算 ¤ 每个 Ma p 节点能够读取上一次迭代生成的 c l u s t er c en t er s ，并判断自己的 各个数据点应该属于哪一个 c l u s t er ¤ R ed u c e 节点综合属于每个 c l u s t er 的数据点，计算出新的 c l u s t er c en t er s 80 基于 M a p R ed u c e 的 K - M ea n s 聚类算法 ¨ Ma p 阶段的处理 ¤ 在 Ma p 类的初始化方法 s et u p 中读取全局的聚类中心信息 ¤ 对 Ma p 方法收到的每一个数据点 p ，计算 p 与所有聚类中心间的距离， 并选择一个距离最小的中心作为 p 所属的聚类，输出 < C l u s t er I D , (p , 1 )> 键值对 ¤ 对每个 Ma p 节点上即将传递到 R ed u c e 节点的每一个 < C l u s t er I D , (p , 1 )> 键 值对，用 C om b i n er 进行数据优化，合并相同 C l u s t er I D 下的所有数据点并 求取这些点的均值 pm 以及数据点个数 n 81 基于 M a p R ed u c e 的 K - M ea n s 聚类算法 ¨ R ed u c e 阶段的处理 ¤ 经过 Ma p 和 C om b i n e 后从 Ma p 节点输出的所有 C l u s t er I D 相同的中间结果 < C l u s t er I D , [ ( p m 1 , n 1 ) , ( p m 2 , n 3 ) …] > ，计算新的均值 pm ，输出 < C l u s t er I D , pm> ¤ 所有输出的 < C l u s t er I D , ( p m , n) > 形成新的聚类中心，供下一次迭代计算 82 基于 M a p R ed u c e 的 K - M ea n s 聚类算法 ¨ 性能分析 ¤ 优点 n 相比于单机运行的 K - M ea n s 算法， M a p R ed u c e 通过并行计算每个 M a p R ed u c e 节点上的数据 到 c l u s t er c en t er s 的距离，显著提高了 K - M ea n s 算法的效率 ¤ 不足 n M a p R ed u c e 每次执行迭代操作都被作为独立作业重新进行处理，需要重新初始化和读写、 传输数据 n M a p R ed u c e 每次迭代很可能存在大量不变数据，而每次都要重新载入和处理 n M a p R ed u c e 每次迭代需要一个额外的 M a p R ed u c e J ob 用来检测迭代终止条件 n M a p R ed u c e 下一轮迭代必须等待上一轮迭代终止，必须重新从分布式文件系统载入数据 83 基于 Sp a r k 的 K - M ea n s 聚类算法 ¨ Sp a r k 并行化 K - M ea n s 算法设计思路 ¤ 将所有数据分布到集群中所有节点的 RD D 内存数据结构中，每个节点 计算自己内存中的数据 ¤ 每个节点读取上一次迭代生成的 c l u s t er c en t er s ，并判断自己内存中的 数据点应该属于哪一个 c l u s t er ¤ 汇总每个节点更新的信息，综合属于各个 c l u s t er 的数据点，计算出新 的 c l u s t er c en t er s 84 ¨ Sp a r k 并行化 K - M ea n s 算法流程 ¤ 1. 从 HDF S 上读取数据转化为 RD D ，将 RD D 中的每个数据对象转化为向量 形成新的 RD D 存入缓存，随机抽样 K 个向量作为全局初始聚类中心 ¤ 2. 计算 RD D 中的每个向量 p 到聚类中心 c l u s t er c en t er s 的距离，将向量划 分给最近的聚类中心，生成以 < C l u s t er I D , ( p , 1 ) > 为元素的新的 RD D ¤ 3. 聚合新生成的 RD D 中 Ke y 相同的 < C l u s t er I D , ( p , 1 ) > 键值对，将相同 C l u s t er I D 下的所有向量相加并求取向量个数 n ，生成新的 RD D 85 基于 Sp a r k 的 K - M ea n s 聚类算法 ¨ Sp a r k 并行化 K - M ea n s 算法流程 ¤ 4. 对生成的 RD D 中每一个元素 < C l u s t er I D , ( p m , n ) > ，计算 C l u s t er I D 聚类的 新的聚类中心，生成以 < C l u s t er I D , p m /n > 为元素的新的 RD D ¤ 5. 判断是否达到最大迭代次数或者迭代是否收敛，不满足条件则重复 步骤 2 到步骤 5 ，满足则结束，输出最后的聚类中心 86 基于 Sp a r k 的 K - M ea n s 聚类算法 ¨ 性能分析 ¤ Sp a r k 的大部分操作都是在内存中完成的，相比于 M a p R ed u c e 每次从分 布式文件系统中获取数据要高效 ¤ Sp a r k 的所有迭代操作都在一个 J ob 中完成，相比于 M a p R ed u c e 没有重 启多次 J ob 带来的开销 ¤ Sp a r k 任务执行结束直接退出，不需要另外一个 J ob 来检测迭代终止条 件 87 基于 Sp a r k 的 K - M ea n s 聚类算法基于 Sp a r k 的 K - M ea n s 聚类算法 Sc a l a 代码 ¨ Sc a l a 示例 ¤ 读取数据和初始化聚类中心 va l l i n es = s c . t e xt F i l e (\" d a ta / ml l i b / k m ea n s _d a t a . t xt \" ) va l dat a = l i n es . m a p (s => s. s p l i t ( \" \" ) . m a p ( _. t oD ou b l e ) ) . c a c h e( ) va l k P oi n t s = d a t a . t a k eSa m p l e (f a l s e , K , 4 2 ). ma p (s => s p a r k . u t i l . V ec t or (s )) // t a k eSa m p l e ( Bool ea n , In t , L on g ) 采样函数， fa l se 表示不使用替换方法采样， K 表示样本数， 42 表示随机 种子 ¤ 划分数据给聚类中心 va l c l os es t = dat a. m ap // 产生 < C l u s t er I D , ( p , 1 ) > 键值对 (p => ( c l os es t P oi n t ( s p a r k . u t i l . V ec t or (p ), k P oi n t s ), (p , 1 ) ) // c l os es t P oi n t 计算最近的聚类中心，产生 C l u s t er I D ( s p a r k . u t i l . V ec t or (p ), 1 ) ) 88 基于 Sp a r k 的 K - M ea n s 聚类算法 Sc a l a 代码 ¨ Sc a l a 示例 ¤ 聚合生成新的聚类中心 // 同一个聚类下所有向量相加并统计向量个数 v al p oi n t St a t s = c l os es t . r ed u c eByK e y { ca s e ( ( x1 , y1 ) , ( x2 , y2 ) ) = > ( x1 + x2 , y1 + y2 ) // 产生 ( pm , n ) } // 将同一 c l u s t er I D 的所有 ( p , 1 ) 的两个分量分别相加，得到 < C l u s t er I D , ( pm , n )> // 计算生成新的聚类中心 v al n e w P oi n t s = p oi n t St a t s . m a p { pai r = > ( p a i r . _1 , p a i r . _2 . _1 / p a i r . _2 . _2 ) } . c ol l ec t A s M a p () // 由 < C l u s t er I D , ( pm , n )> 产生 ( C l u s t er I D , pm / n ) 。其中， p a i r . _1 表示聚类的 C l u s t er I D ， p a i r . _2 . _1 表示聚类中所有向量之和 pm ， p a i r . _2 . _2 表示聚类中所有向量的个数 n 89 基于 Sp a r k 的 K - M ea n s 聚类算法 Ja v a 代码 ¨ Ja v a 示例 ¤ 读取数据和初始化聚类中心 J a v a RD D < St r i n g > d a t a = s c . t e xt F i l e (p a th ); J a v a RD D < V ec t or > p a r s ed D a t a = dat a. m ap ( n e w F u n c t i on < St r i n g , V ec t or > ( ) { p u b l i c V ec t or c a l l ( St r i n g s ) { St r i n g [ ] sa rr a y = s. s p l i t (\" \" ); V ec t or < D ou b l e> v a l u es = n e w V ec t or < D ou b l e> ( ) ; f or ( i n t i = 0 ; i < s a r r a y . l en g t h ; i ++) v a l u es . a d d ( D ou b l e . p a r s eD ou b l e ( sa rr a y [ i ])); r et u r n v a l u es ; } }) ; // 读取数据 p a r s ed D a t a . c a c h e (); // 缓存数据 f i n a l L i s t < V ec t or > k P oi n t s = p a r s ed D a t a . t a k eSa m p l e (f a l s e , 2 , 4 2 ); // 初始化聚类中心 90 // 其中 ta k eS a m p l e 为采样函数， fa l s e 表示不使用替换方法采样， 2 表示样本数， 42 表示随机种子 ¨ 划分数据给聚类中心 J a v a P a i r RD D < I n t eg er , T u p l e2 < V ec t or , I n t eg er > > c l os es t = p a r s ed D a t a . m a p T oP a i r ( ne w P a i r F u n c t i on < V ec t or , I n t eg er , T u p l e2 < V ec t or , I n t eg er > > ( ) { p u b l i c T u p l e2 < I n t eg er , T u p l e2 < V ec t or , I n t eg er > > c a l l ( V ec t or p ) { in t c l u s t er I D = k m ea n s . c l os es t P oi n t (p , k P oi n t s ); // c l os es t P oi n t 计算最近的聚类中心，产生 C l u s t er I D T u p l e2 < V ec t or , I n t eg er > p a i r = n e w T u p l e2 < V ec t or , I n t eg er > ( p , 1 ) ; r et u r n n e w T u p l e2 ( c l u s t er I D , p a ir ) ; } } ); 91 基于 Sp a r k 的 K - M ea n s 聚类算法 Ja v a 代码 ¨ 聚合同一个聚类中的向量 J a v a P a i r RD D < I n t eg er , T u p l e2 < V ec t or , I n t eg er > > p oi n t St a t s = c l os es t . r ed u c eByK e y ( n e w F u n c t i on 2 < T u p l e2 < V ec t or , I n t eg er > , T u p l e2 < V ec t or , I n t eg er > , T u p l e2 < V ec t or , I n t eg er > > ( ) { p u b l i c T u p l e2 < V ec t or , I n t eg er > c a l l ( T u p l e2 < V ec t or , I n t eg er > t u p l e1 , T u p l e2 < V ec t or , I n t eg er > t u p l e2 ) { V ec t or ne w v = n e w V ec t or < D ou b l e> ( ) ; // ne w v 统计聚类中向量之和 int c ou n t = 0 ; //c ou n t 统计聚类中向量个数 f or ( int i = 0 ; i < t u p l e1 . _1 ( ) . s i z e( ) & & i < t u p l e2 . _1 ( ) . s i z e( ) ; i ++) { ne w v .a d d ( ( d ou b l e) t u p l e1 . _1 ( ) . g et ( i ) + ( d ou b l e) t u p l e2 . _1 ( ) . g et ( i )); c ou n t = t u p l e1 . _2 ( ) + t u p l e2 . _2 ( ) ; } r et u r n n e w T u p l e2 < V ec t or , I n t eg er > ( ne w v , c ou n t ) ; } } ); 92 基于 Sp a r k 的 K - M ea n s 聚类算法 Ja v a 代码 ¨ 生成新的聚类中心 J a v a P a i r RD D < I n t eg er , V ec t or > n e w P oi n t s St a t s = p oi n t St a t s . m a p T oP a i r ( ne w P a i r F u n c t i on < T u p l e2 < I n t eg er , T u p l e2 < V ec t or , I n t eg er > > , I n t eg er , V ec t or > ( ) { p u b l i c T u p l e2 < I n t eg er , V ec t or > c a l l ( T u p l e2 < I n t eg er , T u p l e2 < V ec t or , I n t eg er > > t u p l e) { int c l u s t er I D = t u p l e . _1 ( ) ; // c l u s t er I D 表示聚类的类别 V ec t or ne w v = n e w V ec t or < D ou b l e> ( ) ; // ne w v 表示聚类中的向量之和 int c ou n t = t u p l e . _2 ( ) . _2 ( ) ; //c ou n t 表示聚类中向量个数 f or ( i n t i = 0 ; i < t u p l e . _2 ( ) . _1 ( ) . s i z e( ) ; i ++) { ne w v .a d d ( ( d ou b l e) t u p l e . _2 ( ) . _1 ( ) . g et ( i ) * 1 . 0 / c ou n t ) ; } r et u r n n e w T u p l e2 < I n t eg er , V ec t or > ( c l u s t er I D , ne w v ); } }) ; M a p < I n t eg er , V ec t or > n e w P oi n t = n e w P oi n t s St a t s . c ol l ec t A s M a p (); 93 基于 Sp a r k 的 K - M ea n s 聚类算法 Ja v a 代码K - M ea n s 聚类算法性能比较 ¨ 性能比较 94 参考文献 ¨ Sp a r k 官方网站 h t t p : //s p a r k . a p a c h e . or g / ¨ Sp a r k 主要开发者 M a t ei Za h a r i a 的博士论文： Za h a r i a M . A n a r c h i t ec t u r e f or f a s t a n d g en er a l d a t a p r oc es s i n g on l a r g e c l u s t er s [ R] . T ec h n i c a l R ep or t N o . U C B/E E C S - 2014 - 12, 3 F e b 2014. h t t p : // w w w . eec s . b er k el e y . ed u /Pu b s / T ec h Rp t s /2 0 1 4 /E E C S - 2014 - 12. h t m l , 2014. ¨ M es os 官方网站 h t t p : //m es os . a p a c h e . or g / ¨ K u b er n et es 官方网站 h t t p s : //k u b er n et es . i o ¨ D oc k er 官方网站 h t t p s : //w w w . d oc k er . c om / ¨ H a d oop 官方网站中关于 Y A RN 的介绍 h t t p : //h a d oop . a p a c h e . or g /d oc s /c u r r en t /h a d oop - y a r n /h a d oop - ya r n - s i t e/Y A RN . h t m l 95 TH A NK YO U","libVersion":"0.2.4","langs":""}