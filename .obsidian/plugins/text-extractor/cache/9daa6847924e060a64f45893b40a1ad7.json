{"path":"课程/金融大数据/课件/19 Spark Advanced Programming (I).pdf","text":"Sp a r k 高级编程 (I ) 摘要 ¨ Sp a r k SQ L ¨ Sp a r k ML lib 摘要 ¨ Sp a r k SQ L ¨ Sp a r k ML lib Sp a r k SQ L 4 Spa r k SQ L i s A p a ch e S p a r k' s m o d u l e f o r w o r ki n g w i t h st r u ct u r e d d a t a . Sp a r k SQ L 5 Sp a r k SQ L ¨ Sp a r k SQ L ：用来操作结构化和半结构化数据 ¤ 可以从各种结构化数据源中（例如 J SO N 、 Hiv e 、 P a r q u et 等）读取数据； ¤ 不仅支持在 Sp a r k 程序内使用 SQ L 语句进行数据查询，也支持从外部工 具中通过 J D BC /O D BC 连接 Sp a r k SQ L 进行查询； ¤ 支持 SQ L 与常规的 Pyt h on /J a v a /Sc a l a 代码高度整合，包括连接 RD D 与 SQ L 表、公开的自定义 SQ L 函数接口等。 ¨ Sc h em a RD D à Dat aF r am e /D a t a s et 6 Sp a r k SQ L 架构 7 Sp a r k SQ L 执行流程 8 C a t a l ys t 优化器 Sp a r k SQ L 支持的数据格式和编程语言 9 Sp a r k SQ L 特点 ¨ 数据兼容：兼容 Hi v e ，还可以从 RD D 、 P a r q u et 文件、 J SO N 文件中获取数据，可 以在 Sc a l a 代码里访问 Hi v e 元数据，执行 Hi v e 语句，并且把结果取回作为 RD D 使 用。支持 P a r q u et 文件读写。 ¨ 组件扩展：语法解析器、分析器、优化器 ¨ 性能优化：内存列存储、动态字节码生成、内存缓存数据 ¨ 支持多种语言： Sc a l a 、 Ja v a 、 Pyt h on 、 R ，还可以在 Sc a l a 代码里写 SQ L ，支持 简单的 SQ L 语法检查，能把 RD D 转化为 DataF r am e 存储起来。 10 RD D ¨ 弹性 ¤ 数据可完全放内存或完全放磁盘，也可部分存放在内存，部分存放在磁盘， 并可以自动切换 ¤ RD D 出错后可自动重新计算（通过血缘自动容错） ¤ 可 c h ec k p oi n t （设置检查点，用于容错），可 p er s i s t 或 cac h e （缓存） ¤ 里面的数据是分片的（也叫分区， p a r t i t i on ），分片的大小可自由设置和细 粒度调整 ¨ 分布式 ¨ 数据集 11 Da t a F r a m e ¨ DataF r am e i s a D a t a s et or g a n i z ed i n t o n a m ed c ol u m n s . I t i s c on c ep t u a l l y eq u i v a l en t t o a t a b l e i n a r el a t i on a l d a t a b a s e or a d a t a f r a m e i n R/Pyt h on , b u t w i t h r i c h er op t i m i z a t i on s u n d er t h e h ood . D a t a F r a m es c a n b e c on s t r u c t ed f r om a w i d e a r r a y of s ou r c es s u c h a s : s t r u c t u r ed d a t a f i l es , t a b l es i n H i v e , e xt er n a l d a t a b a s es , or e xi s t i n g RD D s . ¨ T h e DataF r am e A PI i s a v a i l a b l e i n Sc a l a , J a v a , Pyt h on , a n d R. I n Sc a l a a n d J a v a , a DataF r am e i s r ep r es en t ed b y a D a t a s et of R o w s . I n t h e Sc a l a A PI , DataF r am e is s i m p l y a t yp e a l i a s of D a t a s et [ R o w ] . Wh i l e , i n J a v a A PI , u s er s n eed t o u s e D a t a s et < R o w > t o r ep r es en t a DataF r am e . 12 Da t a F r a m e v s . RD D ¨ DataF r am e 的推出，让 Sp a r k 具备了处理大规模结构化数据的能力，不仅比原有 的 RD D 转化方式更加简单易用，而且获得了更高的计算性能。 Sp a r k 能够轻松 实现从 M ySQ L 到 DataF r am e 的转化，并且支持 SQ L 查询。 13 D a t a s et ¨ A D a t a s et i s a d i s t r i b u t ed c ol l ec t i on of d a t a . D a t a s et i s a n e w i n t er f a c e a d d ed i n Sp a r k 1 . 6 t h a t p r ov i d es t h e b en ef i t s of RD D s ( s t r on g t yp i n g , a b i l i t y t o u s e p o w er f u l l a m b d a f u n c t i on s ) w i t h t h e b en ef i t s of Sp a r k SQ L ’ s op t i m i z ed e x ec u t i on en g i n e . A D a t a s et c a n b e c on s t r u c t ed f r om J V M ob j ec t s a n d t h en m a n i p u l a t ed u s i n g f u n c t i on a l t r a n s f or m a t i on s ( m a p , fl a t M a p , f i l t er , et c . ) . T h e D a t a s et A PI i s a v a i l a b l e i n Sc a l a a n d J a v a . 14 D a t a s et v s . RD D ¨ 相对于 RD D ， D a t a s et 提供了强类型支持，也是在 RD D 的每行数据 加了类型约束。 15 RDD D a t a se t D a t a se t ：每行数据是一个 O b j e ct Da t a F r a m e v s . D a t a s et ¨ 相比 Dat aF r am e ， D a t a s et 提供了 编译时类型检查 ¨ RD D 转换 Dat aF r am e 后不可逆，但 RD D 转换 D a t a s et 是可逆的。 ¨ D a t a s et 包含了 Dat aF r am e 的功能，在 Sp a r k 2. 0 中两者统一， Dat aF r am e 表示为 D a t a Set [R o w ] ，即 D a t a s et 的子集。 ¨ 使用 A PI 尽量使用 D a t a s et ，不行再选用 Dat aF r am e ，其次选择 RD D 。 16 Da t a F r a m e v s . D a t a s et ¨ 编译时类型检查 17 Da t a F r a m e v s . D a t a s et ¨ 可逆 vs . 不可逆 18 Da t a F r a m e ¨ Dat aF r am e 初始化 19 Da t a F r a m e ¨ U n t yp ed D a t a s et O p er a t i on s (a k a Dat aF r am e O p er a t i on s ) 20 Da t a F r a m e ¨ 常用的 Dat aF r am e 操作 ¤ df . p r i n t Sc h em a () ¤ df . s el ec t ( df ( \" n a m e\" ) , df ( \" a g e\" ) + 1 ) . s h o w ( ) ¤ df . f i l t er ( df ( \" a g e\" ) > 2 0 ) . s h o w ( ) ¤ df . g r ou p By ( \" a g e\" ) . c ou n t ( ) . s h o w ( ) ¤ df . s or t ( df ( \" a g e\" ) . d es c ). s h o w () ¤ df . s or t ( df ( \" a g e\" ) . d es c , df ( \" n a m e\" ) . as c ). s h o w () ¤ df . s el ec t ( df ( \" n a m e\" ) . a s ( \" u s er n a m e\" ) , df ( \" a g e\" ) ) . s h o w ( ) 21 Da t a F r a m e ¨ 运行 SQ L 22 Da t a F r a m e ¨ 全局临时视图 23 D a t a s et ¨ D a t a s et 初始化 24 RD D ß à Da t a F r a m e ¨ 利用反射推断模式 25 RD D ß à Da t a F r a m e ¨ 编程指定模式 26 1. 从原来的 RD D 创建一个行的 RD D ； 2. 创建由一个 St r u c t T yp e 表示 的模式与第一步创建的 RD D 的 行结构相匹配； 3. 在行 RD D 上通过 c r ea t eD a t a F r a m e 应用 Sc h em a RD D ß à Da t a F r a m e ¨ 编程指定模式 27 对比 28 编程模型 描述 优点 缺点 RD D • 针对自定义数据对象进行处理，可 以处理任意类型的对象； • 但是无法感知到数据的结构， 无法 针对数据结构进行编程 • 面向对象的操作方 式 • 可以处理任何类型 的数据 • 运行较慢，执行过程没有 优化 • A PI 僵硬，对结构化数据 的访问和操作没有优化 Da ta F r a m e • 保留数据的元数据，针对数据的结 构进行处理（例如可以针对具体某 一列进行处理） • 执行的时候会经过 C a t a l ys t 进行优化， 并且序列化更加高效，性能更好 • 只能处理结构化的数据，无法处理 非结构化的数据，因为其 内部都使 用 Ro w 对象保存数据 • 针对结构化数据高 度优化，通过列名 访问和转换数据 • 增加 C a t a l ys t 优化器， 优化执行过程 • 只能操作结构化数据 • 只有无类型的 A PI ， A PI 依 然僵硬 D a t a Set • 结合了 RD D 的优点 ( 强类型，能够使 用强大的 la m b d a 函数 ) 和 Sp a r k SQ L 优 化执行引擎的优点 • 可以处理结构化数 据和非结构化数据 • 可以进行优化 Sp a r k SQ L 数据源 ¨ Dat aF r am e 提供统一接口加载和保存数据源中的数据，包括：结 构化数据、 P a r q u et 文件 ( 默认 ) 、 J SO N 文件、 Hi v e 表，以及通过 J D BC 连接外部数据源。 29 加载 30 保存 ¨ 保存模式 Sa v eM od e 31 Sc a l a /J a v a An y La ng ua g e Me an i n g Sa v eM od e . E r r or I f E xi s t s ( d ef a u l t ) \" er r or \" or \" er r or i f e xi s t s \" ( d ef a u l t ) 如果保存数据已经存在，抛出异常 Sa v eM od e . A p p en d \" a p p en d \" 如果保存数据已经存在，追加 Da ta F r a m e 数据 Sa v eM od e . O v er w r i t e \" ov er w r i t e\" 如果保存数据已经存在，重写 Da ta F r a m e 数据 Sa v eM od e . I g n or e \" i g n or e\" 如果保存数据已经存在，忽略 Da ta F r a m e 数据 P a r q u et ¨ P a r q u et 是一种支持多种数据处理系统的存储格式， Sp a r k SQ L 提 供了读写 P a r q u et 文件，并且自动保存原始数据的模式，优点： ¤ 高效， P a r q u et 采取列式存储避免读入不需要的数据 ¤ 方便的压缩和解压缩 ¤ 可以直接固化为 P a r q u et 文件，也可以直接读取 P a r q u et 文件，具有比磁 盘更好的缓存效果 32 J SO N ¨ Sp a r k SQ L 可以自动推断出一个 J SO N 数据集的 Sc h em a 并作为一个 Da t a F r a m e 加载，通过 SQ L C on t e xt . r ea d . j s on () 方法使用 J SO N 文件创建 Da t a F r a m e ，或者通过转换一个 J SO N 对象的 RD D [ St r i n g ] 创建 Da t a F r a m e 。 33 Hi v e ¨ 若要把 Sp a r k SQ L 连接到一个部署好的 Hi v e 上，必须把 hi v e - s i t e . xm l 复制到 Sp a r k 的配置文件目录中 ( c on f /) 。 ¨ 如果没有部署好 Hi v e ， Sp a r k SQ L 会在当前的工作目录中创建出自 己的 Hi v e 元数据仓库，叫做 m et a s t or e_d b 。 ¨ 配置项 s p a r k . s q l . w a r eh ou s e . d i r ，默认的数据仓库地址。 34 Hi v e ¨ Sp a r k SQ L 支持任何 Hi v e 支持的数据格式 35 连接数据库 ¨ J D BC /O D BC 服务器作为一个独立的 Sp a r k 驱动程序运行，可以在 多用户之间共享。任意一个客户端都可以在内存中缓存数据表， 对表进行查询。集群的资源以及缓存数据都在所有用户之间共享。 ¤ 启动 T h r i f t s er v er n > sb in /s t a r t - t h r i f t s er v er . s h - m a s t er s p a r k M a s t er ¤ 连接 J D BC 服务器 n > b i n /b eel i n e - u j d b c : h i v e2 : //l oc a l h os t : 1 0 0 0 0 36 性能调优 ¨ 缓存数据 ¨ 调优参数 ¤ s p a r k . s q l . a u t oBr oa d c a s t J oi n T h r es h ol d ; s p a r k . s q l . t u n g s t en . en a b l ed ; s p a r k . s q l . s h u f f l e . p a r t i t i on s ; s p a r k . s q l . p l a n n er . e xt er n a l Sor t ; … ¨ 增加并行度 37 属性名称 默认值 含义 s p a r k . s q l . i n M em or yC ol u m n a r St or a g e . c om p r es s ed tr u e 当设置为 tr u e ， Sp a r k SQ L 将基于数据统计为每列自动选 择压缩编码 s p a r k . s q l . i n M em or yC ol u m n a r St or a g e . b a t c h Si z e 10000 控制列式缓存的批处理尺寸，大批量可以提升内存的使 用率和压缩率，但是缓存数据时会有内存溢出的风险 数据类型 ¨ or g . a p a c h e . s p a r k . s q l . t yp es ¨ 数值类型 ¤ 字节，短整型，整型，长整型，浮点型，双精度型，数值型 ¨ 字符串类型 ¨ 二进制类型 ¨ 布尔类型 ¨ 时间类型 ¤ 时间戳类型，日期类型 ¨ 复杂类型 ¤ 数组类型， Map 类型， St r u c t T yp e ， St r u c t F i el d 38 摘要 ¨ Sp a r k SQ L ¨ Sp a r k ML lib Sp a r k MLl i b 40 ML l i b is A p a ch e S p a r k’ s sca l a b l e m a ch i n e l e a r n i n g l i b r a r y . 架构 41 ¨ sp a r k . m l l i b .* // T h e ML lib RD D - b a s ed A PI i s n o w i n m a i n t en a n c e m od e . ¨ sp a r k . m l .* // ML lib Dat aF r am e - b a s ed A PI 架构 ML Op t i m i z e r ML I ML l i b Sp a r k ¨ ML lib 是常用机器学习算法的实现库 ¨ ML I 是进行特征抽取和高级 ML 编程抽 象的算法实现的 A PI ¨ ML O p t i m i z er 优化器会选择最合适的， 已经实现好了的机器学习算法和相 关参数 42 M L Ba s e 的分层结构 例子 ¨ 训练分类器 // 构造一个 10 行 10 列的数组 va l dat a = Ar r a y . o f Dim [ In t ](1 0 ,1 0 ) fo r ( i < - 0 unt i l 10) { fo r ( j < - 0 unt i l 10) { // 给数组赋值随机数 dat a( i )(j ) = sca l a . u t i l . R a n d o m . n e xt I n t (1 0 0 ) } // 取第 2 ～ 10 列数据（训练集的样本特征空间） x = d a t a [ , 2 t o 1 0 ] // 取第 1 列数据（样本相应的分类标签） y = d a t a [ , 1 ] // 调用分类算法进行分类（ M L B a se 自动选择优化方案） mo d e l = d o _ cl a ssi f y ( y, x ) 43 设计理念 ¨ ML lib ：把数据以 RD D 的形式表示，然后在分布式数据集上调用各种算法。引入 一些数据类型（比如点和向量），给出一系列可供调用的函数的集合。 ¨ ML lib 只包含能够在集群上运行良好的并行算法 ¤ 特征提取，例如 TF - ID F ¤ 统计 ¤ 分类与回归：线性回归，逻辑回归， SV M ，朴素贝叶斯，决策树与随机森林 ¤ 聚类 ¤ 协同过滤与推荐 ¤ 降维 ¤ 模型评估 44 MLl i b 数据类型 ¨ 本地向量 ¨ 标记点 ¨ 本地矩阵 ¨ 分布式矩阵 ¨ 行矩阵 ¨ 索引矩阵 ¨ 三元组矩阵 45 本地向量 ¨ 本地向量存储在单机上，由从 0 开始的 Int 型的索引和 D ou b l e 型的值组成，存储 在单机上。 ¨ ML lib 支持两种类型的本地向量：密集向量和稀疏向量。密集向量的值由 D ou b l e 型的数据表示，而稀疏向量由两个并列的索引和值表示。 // 导入 ML l i b im p o r t o r g . a p a ch e . sp a r k. m l l i b . l i n a l g . { V e ct o r , V e ct o r s} // 创建（ 1. 0, 0. 0, 3. 0 ）的密集向量 va l d v: V e ct o r = V e ct o r s. d e n se (1 .0 , 0 .0 , 3 .0 ) // 通过指定非零向量的索引和值，创建 (1 .0 , 0 .0 , 3 .0 ) 的数组类型的稀疏向量 va l sv1 : V e ct o r = V e ct o r s. sp a r se ( 3 , A r r a y( 0 , 2 ) , A r r a y( 1 . 0 , 3 . 0 ) ) // 通过指定非零向量的索引和值，创建 (1 .0 , 0 .0 , 3 .0 ) 的序列化的稀疏向量 va l sv2 : V e ct o r = V e ct o r s. sp a r se (3 , Se q ((0 , 1 .0 ), (2 , 3 .0 ))) 46 标记点 ¨ 标记点是由一个本地向量（密集或稀疏）和一个标签（ Int 型或 D ou b l e 型）组成。 在 ML lib 中，标记点主要被应用于回归和分类这样的监督学习算法中。标签通 常采用 Int 型或 D ou b l e 型的数据存储格式。 im p o r t o r g . a p a ch e . sp a r k. m l l i b . l i n a l g . V e ct o r s im p o r t o r g . a p a ch e . sp a r k. m l l i b . r e g r e ssi o n . L a b e l e d P o i n t // 通过一个正相关的标签和一个密集的特征向量创建一个标记点 va l pos = Label edP oi nt (1 .0 , V e ct o r s. d e n se (1 .0 , 0 .0 , 3 .0 )) // 通过一个负向标签和一个稀疏特征向量创建一个标记点 va l neg = Label edP oi nt (0 .0 , V e ct o r s. sp a r se ( 3 , A r r a y( 0 , 2 ) , A r r a y( 1 . 0 , 3 . 0 ) ) ) 47 稀疏数据 ¨ ML lib 可以读取存储为 L I BSV M 格式的数据，其每一行代表一个带有 标签的稀疏特征向量。格式如下： l a b el i n d e x1 : v a l u e1 i n d e x2 : v a l u e2 … ¨ 其中 l a b el 是标签值， in d e x 是索引，其值从 1 开始递增。加载完成 后，索引被转换为从 0 开始。 ¨ 接口： M L U t i l s . l oa d L i b SV M F i l e va l e xa m p l es : RD D [ L a b el ed P oi n t ] = M L U t i l s . l oa d L i b SV M F i l e ( sc , “ d a t a / ML l i b / s a m p l e_l i b s v m _d a t a . t xt ”) 48 本地矩阵 ¨ 本地矩阵是由（ Int 类型行索引， Int 类型列索引， D ou b l e 类型值）组成，存放在 单机中。 Mllib 支持密集矩阵，密集矩阵的值以列优先方式存储在一个 D ou b l e 类 型的数组中，矩阵如下： 1 . 0 2 . 0 3 . 0 5 . 0 4 . 0 6 . 0 9 . 0 0 . 0 0 . 0 0 . 0 8 . 0 6 . 0 ¨ 这个 3 行 2 列的矩阵存储在一个一维数组 [ 1 . 0 , 3 . 0 , 5 . 0 , 2 . 0 , 4 . 0 , 6 . 0 ] 中。 ¨ ML lib 实现： D en s eM a t r i x va l dm : M a t r i x = M a t r i c es . d en s e ( 3 , 2 , A r r a y( 1 . 0 , 3 . 0 , 5 . 0 , 2 . 0 , 4 . 0 , 6 . 0 ) ) va l sm : M a t r i x = M a t r i c es . s p a r s e ( 3 , 2 , A r r a y( 0 , 1 , 3 ) , A r r a y( 0 , 2 , 1 ) , A r r a y( 9 , 6 , 8 ) ) 49 分布式矩阵 ¨ 分布式矩阵由（ L on g 类型行索引， L on g 类型列索引， D ou b l e 类型值）组成，分 布存储在一个或多个 RD D 中。因为要缓存矩阵的大小，所以分布式矩阵底层的 RD D 必须是确定的，选择正确的格式来存储巨大的分布式矩阵是非常重要的， 否则会导致错误的出现。 ML lib 已实现了四种分布式矩阵： ¤ 行矩阵 Row M a t r i x ¤ 行索引矩阵 I n d e x ed R o w M a t r i x ¤ 三元组矩阵 C oor d i n a t eM a t r i x ¤ 块矩阵 Bl oc k M a t r i x 50 MLl i b 的算法库 ¨ 基本统计 ¤ 汇总统计，相关性统计，分层抽样，假设检验，随机数据生成，核密度估计 ¨ 分类和回归 ¤ 线性模型（支持向量机 SV M 、逻辑回归、线性回归） ¤ 朴素贝叶斯 ¤ 决策树，随机森林和梯度提升决策树（ G BT ） ¨ 协同过滤 ¤ 交替最小二乘法（ ALS ） ¨ 聚类 ¤ K - m ea n s ，高斯混合，快速迭代聚类，三层贝叶斯概率模型，流式 K - m ea n s 51 MLl i b 的算法库 ¨ 降维 ¤ 奇异值分解（ SV D ） ¤ 主成分分析（ PC A ） ¨ 频繁模式挖掘 ¤ FP - gr o w th ，关联规则， Pr ef i xSp a n ¨ 优化器 ¤ 随机梯度下降 ¤ 限制内存 BF G S （ L - BF G S ） ¨ 特征值提取和转换，评价指标， PM M L 模型输出等算法实现 52 常见步骤 ¨ 例如，如果要用 ML lib 来完成文本分类的任务，只需如下操作： ¤ 首先用字符串 RD D 来表示你的消息 ¤ 运行 ML l i b 的一个特征提取算法来把文本数据转换为数值特征，该操作 会返回一个向量 RD D ¤ 对向量 RD D 调用分类算法（比如逻辑回归），这步会返回一个模型对 象，可以使用该对象对新的数据点进行分类 ¤ 使用 ML l i b 的评估函数在测试数据集上评估模型 53 再看 K - M ea n s i m p or t or g . a p a c h e . s p a r k . m l l i b . c l u s t er i n g .{ K M ea n s , K M ea n s M od el } i m p or t or g . a p a c h e . s p a r k . m l l i b . l i n a l g . V ec t or s va l dat a = s c . t e xt F i l e (\" d a ta / ml l i b / k m ea n s _d a t a . t xt \") va l p a r s ed D a t a = dat a. m ap (s = > V ec t or s . d en s e ( s. s p l i t ( ' ' ) . m a p ( _. t oD ou b l e ) ) ) . c a c h e( ) // C l u s t er t h e d a t a i n t o t w o c l a s s es u s i n g K M ea n s va l n u m C l u s t er s = 2 va l n u m I t er a t i on s = 2 0 va l c l u s t er s = K M ea n s . t r a i n ( p a r s ed D a t a , n u m C l u s t er s , n u m I t er a t i on s ) // E v a l u a t e c l u s t er i n g b y c om p u t i n g Wi t h i n Set Su m of Sq u a r ed E r r or s va l WSSSE = c l u s t er s . c om p u t eC os t ( p a r s ed D a t a ) pr i n t l n ( \" Wi t h i n Set Su m of Sq u a r ed E r r or s = \" + WSSSE ) // Sa v e a n d l oa d m od el c l u s t er s . s a v e ( sc , \" t a r g et /or g /a p a c h e/s p a r k / K M ea n s E xa m p l e / K M ea n s M od el \") va l s a m eM od el = K M ea n s M od el . l oa d ( sc , \" t a r g et /or g /a p a c h e/s p a r k / K M ea n s E xa m p l e / K M ea n s M od el \") 54 Iris 数据集分类 55 Ir is 数据集是常用的分类实验数据集，由 F i s h er , 1936 收集整理。 Ir is 也称鸢尾花卉数据集，是一 类多重变量分析的数据集。数据集包含 150 个 数据，分为 3 类，每类 50 个数据，每个数据包 含 4 个属性。可通过花萼长度，花萼宽度，花 瓣长度，花瓣宽度 4 个属性预测鸢尾花卉属于 （ Set os a ， V er s i c ol ou r ， Vi r g i n i ca ） 三个种类中 的哪一类。 实验步骤：数据处理 ¨ 首先需要将 Ir is - s et os a ， Ir is - v er s i c ol ou r ， Ir is - vir g inic a 转化成 0 ， 1 ， 2 来表示。生成 L a b el ed P oi n t 类型 RD D ¤ 利用 l oadL i bSV M F i l e 接口从 L i b SV M 格式的文件读取数据。当然首先需要 把原始的数据文件转换成 L i b SV M 格式，然后调用 l oadL i bSV M F i l e 接口就 可以生成 L a b el ed P oi n t 类型的 RD D 。 ¤ 先用 t e xt F i l e 读取数据，然后对 st ri n g 类型的 RD D 调用 map 操作，转换成 L a b el ed P oi n t 类型的 RD D 。 56 实验步骤：数据处理 # 读取数据 va l rd d : RD D [ St r i n g ] = s c . t e xt F i l e (p a th) # 转换得到 L a b el ed P oi n t va r rd d L p : RD D [ L a b el ed P oi n t ] = rd d . m a p ( x = > { va l s t r i n g s : A r r a y[ St r i n g ] = x. s p l i t (\" , \" ) r eg r es s i on . L a b el ed P oi n t ( s t r i n g s ( 4 ) m a t c h { c a s e \" I r i s - s et os a \" = > 0 . 0 c a s e \" I r i s - v er s i c ol or \" = > 1 . 0 c a s e \" I r i s - vi r g i ni c a \" => 2 . 0 } , V ec t or s . d en s e ( s tr i ng s (0 ). t oD ou b l e , s t r in g s ( 1 ) . t oD ou b l e , s t r in g s ( 2 ) . t oD ou b l e , s t r in g s ( 3 ) . t oD ou b l e )) } ) # 分割 数据集为训练集和测试集 va l A r r a y( t r a i n D a t a , t es t D a t a ) : A r r a y[ RD D [ L a b el ed P oi n t ]] = r d d L p . r a n d om Sp l i t ( A r r a y( 0 . 8 , 0 . 2 ) ) 57 实验步骤：训练模型及模型评估 ¨ 选取朴素贝叶斯，决策树，随机森林，支持向量机，以及 l og i s t i c s 回归共 5 种分类算法。采用留出法对建模结果评估，留出 30% 数 据作为测试集，评估标准采用精度 ac c u r ac y 。 ¨ 支持向量机（ SV M ）， l og i s t i c s 回归是二分类的算法，由于本数据 集有多个类别，所以可以利用多个二分类分类器来实现多分类目 标。 58 参考代码：决策树 # 构建模型 va l d ec i s on M od el : D ec i s i on T r eeM od el = D ec i s i on T r ee . t r a i n C l a s s i f i er (tr ai n D ata, 3, Map[I n t, I n t](), \" gi n i \" , 8, 16) # 得到测试集预测的结果 va l r es u l t : RD D [ ( D ou b l e , D ou b l e) ] = t es t D a t a . m a p ( x= > { va l p r e: D ou b l e = d ec i s on M od el . p r ed i c t ( x. f ea t u r es ) ( x. l a b el , p r e ) } ) va l a c c : D ou b l e = r es u l t . f i l t er ( x= > x. _1 = = x. _2 ) . c ou n t ( ) . t oD ou b l e / r es u l t . c ou n t () 59 Sc a l a 参考代码：朴素贝叶斯 # 分割 数据集为训练集和测试集 t r a i n d a t a , t es t d a t a = d a t a . r a n d om Sp l i t ([0. 7, 0. 3]) # 朴素贝叶斯训练并评估 Ba y es m od el = N a i v eBa y es . t r a i n (tr ai n data, 1. 0) p r ed i c t i on A n d L a b el _Ba y es = t es t d a t a . m a p (l am bda p : ( Ba y es m od el . p r ed i c t ( p . f ea t u r es ), p . l a b el )) a c c u r a c y= 1 . 0 * p r ed i c t i on A n d L a b el _Ba y es . f i l t er (l am bda p1: p 1 [ 0 ] = = p 1 [ 1 ] ) . c ou n t ( ) / t es t d a t a . c ou n t () 60 Pyt h on 参考代码： SV M # 用多个 SV M 分类器实现多分类 m od el 1 = SV M Wi t h SG D . t r a i n ( t r a i n 0 _1 , i t er a t i on s = 1 0 0 0 ) m od el 2 = SV M Wi t h SG D . t r a i n ( t r a i n 0 _2 , i t er a t i on s = 1 0 0 0 ) m od el 3 = SV M Wi t h SG D . t r a i n ( t r a i n 1 _2 , i t er a t i on s = 1 0 0 0 ) p r ed i c t i on s 1 = m od el 1 . p r ed i c t ( t es t d a t a . m a p ( l a m b d a x : x. f ea t u r es )) p r ed i c t i on s 2 = m od el 2 . p r ed i c t ( t es t d a t a . m a p ( l a m b d a x : x. f ea t u r es )) p r ed i c t i on s 3 = m od el 3 . p r ed i c t ( t es t d a t a . m a p ( l a m b d a x : x. f ea t u r es )) t r u e_l a b el = t es t d a t a . m a p ( l a m b d a x : x. l a b el ) . c ol l ec t ( ) l a b el _l i s t 1 = p r ed i c t i on s 1 . c ol l ec t ( ) ; l a b el _l i s t 2 = p r ed i c t i on s 2 . c ol l ec t ( ) ; l a b el _l i s t 3 = p r ed i c t i on s 3 . c ol l ec t ( ) # 投票产生结果 p r ed i c t _l a b el =[ ] a c c ou n t = 0 61 Pyt h on 参考代码： SV M f or i n d e x i n r a n g e( l en ( t r u e_l a b el )): d i c t i on a r y = { 0 . 0 : 0 , 1 . 0 : 0 , 2 . 0 : 0 } i f l a b el _l i s t 1 [ i n d e x] = = 0 : d i c t i on a r y[ 0 . 0 ] + = 1 el s e: d i c t i on a r y[ 1 . 0 ] + = 1 i f l a b el _l i s t 2 [ i n d e x] = = 0 : d i c t i on a r y[ 0 . 0 ] + = 1 el s e: d i c t i on a r y[ 2 . 0 ] + = 1 i f l a b el _l i s t 3 [ i n d e x] = = 0 : d i c t i on a r y[ 2 . 0 ] + = 1 el s e: d i c t i on a r y[ 1 . 0 ] + = 1 m a xl a b el = 0 . 0 62 f or i t em i n d i c t i on a r y . k e ys (): i f d i c t i on a r y[ i t em ] > d i c t i on a r y[ m a xl a b el ]: m a xl a b el = i t em if m a xl a b el == t r u e_l a b el [ i n d e x] : a c c ou n t + = 1 p r ed i c t _l a b el . a p p en d ( m a xl a b el ) a c c u r a c y_SV M = 1 . 0 * a c c ou n t / l en ( t r u e_l a b el ) ML 库 ¨ Sp a r k 的 ML 库基于 DataF r am e 提供高性能的 A PI ，帮助用户创建和优化实用的机 器学习流水线（ Pi p el i n e ），包括特征转换独有的 Pi p el i n es A PI 。相比较 Mllib ， 变化主要体现在： ¤ 从机器学习的 lib r a r y 开始转向构建一个机器学习工作流的系统。 ML 把整个机器学习的过程 抽象成 Pi p el i n e ，一个 Pi p el i n e 由多个 St a g e 组成，每个 St a g e 由 T r a n s f or m er 或者 E s t i m a t or 组成。 ¤ ML 框架下所有的数据源都基于 Da t a F r a m e ，所有模型都基于 Sp a r k 的数据类型表示， ML 的 A PI 操作也从 RD D 向 Da t a F r a m e 全面转变。 63 ML 主要概念 ¨ DataF r am e ：将 Sp a r k SQ L 的 DataF r am e 作为一个 ML 数据集使用，支持多种数据 类型。一个 DataF r am e 可以有不同的列存储文本、特征向量、真实标签和预测。 ¨ T r a n s f or m er ：实现一个 DataF r am e 转换成另一个 DataF r am e 的算法。实现 t r a n s f or m ( ) 方法。 ¨ E s t i m a t or ：适配一个 DataF r am e ，产生另一个 T r a n s f or m er 的算法。实现 fi t ( ) 方法。 ¨ Pi p el i n e ：指定连接多个 T r a n s f or m er s 和 E s t i m a t or s 的 ML 工作流。 ¨ P a r a m et er ：全部的 T r a n s f or m er s 和 E s t i m a t or s 共享一个指定 P a r a m et er 的通用 A PI 。 64 Pi p el i n e ¨ 机器学习的流水线通常指运行一系列算法的过程，并从数据中学习。例如，一 个简单的文本文档处理工作流程可能包括以下几个阶段： ¤ 将每个文档的文本切分成单词； ¤ 将每个文档单词转换成一个数值特征向量； ¤ 使用特征向量和标签，学习一个预测模型。 ¨ Sp a r k ML 代表一个作为流水线的工作流，由一系列流水线阶段组成，并以一个特 定的顺序运行。 ¨ 一个流水线被指定为一系列由 T r a n s f or m er 或 E s t i m a t or 组成的阶段（ St a g e ）。这 些阶段按照顺序运行，输入的 DataF r am e 在运行的每个阶段进行转换。 65 Pi p el i n e 66 Tr a i n i n g Ti m e 的 Pi pel i ne 流水线是一个 E st i m a t o r ，因此，在一个流水线的 fi t( ) 方法运行之后， 生成一个 Pi p e l i n e M o d e l ，该模型是一个 T r a n sf o r m e r 。 Pi p el i n e 67 T e st Ti m e 的 Pi pel i ne Pi p e l i n e 和 Pi p e l i n e M o d e l 在实际运行 Pi p e l i n e 之前，使用 Da t a F r a m e 模 式（ sch e m a ）进行类型检查，该模式描述 Da t a F r a m e 中列的数据类型。 再看 K - M ea n s i m p or t or g . a p a c h e . s p a r k . m l . c l u s t er i n g . K m ea n s va l d a t a s et = s p a r k . r ea d . f or m a t (\" lib s v m \" ) . l oa d ( \" d a t a / ml l i b / s a m p l e_k m ea n s _d a t a . t xt \") // T r a i n s a k - m ea n s m od el . va l k m ea n s = ne w K M ea n s (). s et K (2 ). s et Seed (1 L ) va l m od el = k m ea n s . f i t ( d a t a s et ) // M a k e p r ed i c t i on s va l p r ed i c t i on s = m od el . t r a n s f or m ( d a t a s et ) // E v a l u a t e c l u s t er i n g b y c om p u t i n g Si l h ou et t e s c or e va l ev a l u a t or = n e w C l u s t er i n g E v a l u a t or () va l s i l h ou et t e = ev a l u a t or . ev a l u a t e ( p r ed i c t i on s ) // Sh o w s t h e r es u l t . pr i n t l n ( \" C l u s t er C en t er s : \" ) m od el . c l u s t er C en t er s . f or ea c h ( pr i n t l n ) 68 再看鸢尾花 va l df : Da ta F r a m e = s p a r k Ses s i on . r ea d . f or m a t ( \" c s v \" ) . op t i on ( \" i n f er Sc h em a \", \" t r u e\" ) . op t i on ( \" h ea d er \" , \" t r u e \" ) . op t i on ( \" s ep \" , \" , \" ) . l oa d ( p a t h ) // 特征工程 // 将 4 个特征整合为一个特征向量 va l a s s em b l er : V ec t or A s s em b l er = ne w V ec t or A s s em b l er (). s et I n p u t C ol s (Ar r a y ( “ s ep a l _l en g t h ” , “ s ep a l _w i d t h ” , “ p et a l _l en g t h ” , “ p et a l _w i d t h ”) ) . s et O u t p u t C ol ( “ f ea t u r es ” ) va l a s s m b l er D f : Da ta F r a m e = a s s em b l er . t r a n s f or m (d f ) // 将类别型 cl as s 转变为数值型 va l st ri n g I n d e x : St r i n g I n d e x er = ne w St r i n g I n d e x er (). s et I n p u t C ol (“ c l a s s ” ). s et O u t p u t C ol ( \" l a b el \" ) va l s t i n g I n d e xM od el : St r i n g I n d e x er M od el = s t r i n g I n d e x. f i t ( a s s m b l er D f ) va l i n d e xD f : Da ta F r a m e = s t i n g I n d e xM od el . t r a n s f or m ( a s s m b l er D f ) // 将数据切分成两部分，分别为训练数据集和测试数据集 va l A r r a y( t r a i n D a t a , t es t D a t a ) : A r r a y[ D a t a s et [ R o w ] ] = i n d e xD f . r a n d om Sp l i t ( A r r a y( 0 . 8 , 0 . 2 ) ) 69 再看鸢尾花 // 准备计算，设置特征列和标签列 va l c l a s s i f i er : D ec i s i on T r eeC l a s s i f i er = ne w D ec i s i on T r eeC l a s s i f i er (). s et F ea t u r es C ol ( \" f ea t u r es \" ) . s et M a xBi n s (1 6 ). s et I m p u r i t y (\" gi n i \") . s et Seed (1 0 ) va l d t c M od el : D ec i s i on T r eeC l a s s i f i c a t i on M od el = c l a s s i f i er . f i t ( tr a i nDa ta ) // 完成建模分析 va l t r a i n Pr e : Da ta F r a m e = d t c M od el . t r a n s f or m ( tr a i nDa ta ) // 预测分析 va l t es t Pr e : Da ta F r a m e = d t c M od el . t r a n s f or m ( t es t D a t a ) // 评估 va l a c c : D ou b l e = n e w M u l t i c l a s s C l a s s i f i c a t i on E v a l u a t or (). s et M et r i c N a m e ( \" a c c u r a c y\" ) . ev a l u a t e( t es t Pr e ) 70 一般步骤 ¨ Sp a r k ML l i b ： ¤ 加载数据 ¤ 把数据转换成所需的格式 ¤ 设置算法参数 ¤ 调用算法模型训练 ¤ 预测 ¤ 模型评估 ¨ Sp a r k ML ： ¤ 把整个机器学习过程抽象成 Pi p el i n e ¤ 通过 T r a n s f or m er 和 E s t i m a t or 构成的多个 St a g e 完成 Pi p el i n e 过程。 71 预测问题 ¨ 1. 导入需要的包 ¨ 2. 读取训练数据 ¨ 3. 构建模型 ¨ 4. 评估模型 72 TH A NK YO U","libVersion":"0.2.4","langs":""}