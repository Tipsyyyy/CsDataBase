{"path":"课程/金融大数据/课件/14 HBase基本原理与程序设计.pdf","text":"H Ba s e 基本原理与程序设计 摘要 p H Ba s e 基本工作原理 p H Ba s e 基本操作 p H Ba s e 编程方法示例 2 摘要 p H Ba s e 基本工作原理 p H Ba s e 基本操作 p H Ba s e 编程方法示例 3 H Ba s e ¨ H a d oop 可以很好地解决大规模数据的离线批量处理问题，但是，受限于 H a d oop M a p R ed u c e 编程框架的高延迟数据处理机制，使得 H a d oop 无法满足大 规模数据实时处理应用的需求。 ¨ HDF S 面向批量访问模式，不是随机访问模式。 ¨ 传统的通用关系型数据库无法应对在数据规模剧增时导致的系统扩展性和性能 问题（分库分表也不能很好解决）。 ¨ 传统关系数据库在数据结构变化时一般需要停机维护；空列浪费存储空间。 ¨ 因此，业界出现了一类面向半结构化数据存储和处理的高可扩展、低写入 / 查 询延迟的系统，例如，键值数据库、文档数据库和列族数据库（如 Bi g T a b l e 和 H Ba s e 等）。 4 H Ba s e ¨ H Ba s e 是一个高可靠、高性能、面向列、可伸缩的分布式数据库， 是谷歌 Bi g T a b l e 的开源实现，主要用来存储非结构化和半结构化 的松散数据。 H Ba s e 的目标是处理非常庞大的表，可以通过水平 扩展的方式，利用廉价计算机集群处理由超过 10 亿行数据和数百 万列元素组成的数据表。 5 H Ba s e 的设计目标 ¨ 针对 HDF S 缺少结构化半结构化数据存储访问能力的缺陷，提供一个 分布式数据管理系统，解决大规模的结构化和半结构化数据存储访 问问题 ¨ G oog l e Bi g T a b l e 的一个开源实现 ¨ 提供基于列存储模式的大数据表管理能力 ¨ 可存储管理数十亿以上的数据记录，每个记录可包含百万以上的数 据列 ¨ H Ba s e 试图提供随机和实时的数据读写访问能力 ¨ 具有高可扩展性、高可用性、容错处理能力、负载平衡能力、实时 数据查询能力 6 H Ba s e 的功能特点 ¨ 列式存储 ¨ 表数据是稀疏的多维映射表 ¨ 读写的严格一致性（区别于 Cassan dr a 的最终一致性） ¨ 提供很高的数据读写速度，为写数据进行了特别优化 ¨ 良好的线形可扩展性 ¨ 提供海量数据存储能力 ¨ 数据会自动分片 ¨ 具有自动的失效检测和恢复能力，保证数据不丢失 ¨ 提供了方便的与 HDF S 和 M a p R ed u c e 集成的能力 ¨ 提供 Ja v a A PI 作为编程接口 7 H Ba s e v s . RD BM S ¨ 数据类型： RD BM S 采用关系模型，具有丰富的数据类型和存储方式， H Ba s e 则采用了更加简单的数据模型，它把数据存储为未经解释的 字符串。 ¨ 数据操作： RD BM S 中包含了丰富的操作，其中会涉及复杂的多表连 接。 H Ba s e 操作则不存在复杂的表与表之间的关系，只有简单的插 入、查询、删除、清空等，因为 H Ba s e 在设计上就避免了复杂的表 和表之间的关系。 ¨ 存储模式： RD BM S 是基于行模式存储的。 H Ba s e 是基于列存储的， 每个列族都由几个文件保存，不同列族的文件是分离的。 8 H Ba s e v s . RD BM S ¨ 数据索引： RD BM S 通常可以针对不同列构建复杂的多个索引，以提高数据访 问性能。 H Ba s e 只有一个索引 —— 行键，通过巧妙的设计， H Ba s e 中的所有访问 方法，或者通过行键访问，或者通过行键扫描，从而使得整个系统不会慢下来。 ¨ 数据维护：在 RD BM S 中，更新操作会用最新的当前值去替换记录中原来的旧值， 旧值被覆盖后就不会存在。而在 H Ba s e 中执行更新操作时，并不会删除数据旧 的版本，而是生成一个新的版本，旧有的版本仍然保留。 ¨ 可伸缩性： RD BM S 很难实现横向扩展，纵向扩展的空间也比较有限。相反， H Ba s e 和 Bi g T a b l e 这些分布式数据库就是为了实现灵活的水平扩展而开发的，能 够轻易地通过在集群中增加或者减少硬件数量来实现性能的伸缩。 9 H Ba s e 访问接口 10 类型 特点 场合 N at i ve Java A P I 最常规和高效的访问方式 适合 H a doop M a pR e duc e 作业 并行批处理 HB ase 表数据 H B as e S h e l l HB ase 的命令行工具，最 简单的接口 适合 HB ase 管理使用 T h r i f t G at e w ay 利用 T hr i f t 序列化技术， 支持 C+ + 、 PH P 、 P yt hon 等多种语言 适合其他异构系统在线访问 HB ase 表数据 R E S T G at e w ay 解除了语言限制 支持 REST 风格的 H t t p A P I 访问 HB ase Pig 使用 P i g L a t i n 流式编程语 言来处理 HB ase 中的数据 适合做数据统计 H i ve 简单 当需要以类似 SQ L 语言方式来 访问 HB ase 的时候 H Ba s e 在 H a d oop 中的生态环境 ¨ 构建于分布式文件系统 HDF S 之上 ¨ 为上层应用提供结构化半结构化海量数据存储访问能力 11 H B a se 的运行依赖于 Ha d o o p HDF S 文件系统提供数据的持久化（支持 append 功能），依赖 Z o o ke e p e r 提供集群的同步和协调。 H Ba s e 在 H a d oop 中的生态环境 ¨ 分布式协调服务器 Zook eep er ¤ 保证任何时候，集群中只有一个 H Ba s e M a s t er ¤ 实时监控 R eg i on Ser v er 的状态，将 R eg i on Ser v er 的上线和下线信息实时 通知给 H Ba s e M a s t er ¤ 存储 H Ba s e 目录表的寻址入口 ¤ 存储 H Ba s e 的 s c h em a ，包括有哪些表，每个表有哪些列族等各种元信息 12 H Ba s e 在 H a d oop 中的生态环境 ¨ 可与 M a p R ed u c e 协同工作，为 M a p R ed u c e 提供数据输入输出，以 完成数据的并行化处理 13 H Ba s e 数据模型 ¨ H Ba s e 的数据模型 是一个 稀疏、多维度、排序的映射表 ，这张表的索引是 行键、列族、列限定 符和时间戳 。 ¨ 每个值是一个未经解释的字符串，没有数据类型。 ¨ 用户在表中存储数据，每一行都有一个 可排序的行键 和任意多的列。 ¨ 表在水平方向由一个或者多个列族组成，一个列族中可以包含任意多个列，同一个列族里面 的数据存储在一起。 ¨ 列族支持动态扩展，可以很轻松地添加一个列族或列，无需预先定义列的数量以及类型，所 有列均以字符串形式存储，用户需要自行进行数据类型转换。 ¨ H Ba s e 中执行更新操作时，并不会删除数据旧的版本，而是生成一个新的版本，旧有的版本仍 然保留（ 这是和 HDF S 只允许追加不允许修改的特性相关的 ）。 14 H Ba s e 数据模型 ¨ 表： H Ba s e 采用表来组织数据，表由行和列组成， 列划分为若干个列族 ¨ 行：每个 H Ba s e 表都由若干行组成，每个行由行 键（ ro w k e y ） 来标识。 ¨ 列族：一个 H Ba s e 表被分组成许多“列族” （ C ol u m n F a m i l y ） 的集合，它是基本的访问控制 单元 ¨ 列限定符：列族里的数据通过列限定符（或列） 来定位 ¨ 单元格：在 H Ba s e 表中，通过行、列族和列限定 符确定一个“单元格”（ c el l ）， 单元格中存储的 数据没有数据类型，总被视为字节数组 b yt e[ ] ¨ 时间戳：每个单元格都保存着同一份数据的多个 版本，这些版本采用时间戳进行索引 15 数据坐标 ¨ H Ba s e 中需要根据行键、列族、列限定符和时间戳来确定一个单元格，因此，可以视为一个 “四维坐标”，即 [ 行键 , 列族 , 列限定符 , 时间戳 ] 16 键 值 [ “ 201505003 ” , “ I nf o ” , “ em ai l ” , 1 174184619081] “ xi e @ qq.c om ” [ “ 201505003 ” , “ I nf o ” , “ em ai l ” , 1 174184620720] “ you@ 163.c om ” 概念视图 17 概念视图 18 H Ba s e 一定程度上又可以看成一个多维度的 Map 模型去理解它的数据模型。即以行键 ( R o w K e y) ，列标识 ( c ol u m n q u a l i f i er ) ，时间 戳 ( t i m es t a m p ) 标识的有序 Map 数据结构的数 据库，具有稀疏，分布式，持久化，多维 度等特点。 一个行键映射一个列族数组，列族数组 中的每个列族又映射一个列标识数组， 列标识数组中的每一个列标识又映射到 一个时间戳数组，里面是不同时间戳映 射下不同版本的值，但是默认取最近时 间的值，所以可以看成是列标识和它所 对应的值的映射。 概念视图 19 H Ba s e 一定程度上 也可以 看成是一个类似 R ed i s 那样 的 Ke y - Va l u e 数据库。当你 要查询某一行的所有数据 时， Row K e y 就相当于 Ke y ， 而 Va l u e 就是单元中的数 据 行主键 ¨ 行主键 r o w k e y 是用来检索记录的主键。这样的话，访问 H Ba s e table 中的行，有 三种方式： 1 通过单个 r o w k e y 访问； 2 通过 r o w k e y 的范围 ra n g e 来访问； 3 全 表扫描。 ¨ 行键（ R o w k e y ）可以是任意字符串（最大长度是 64KB ，实际应用中长度一般 为 10 - 1 0 0 b yt es ），在 H Ba s e 内部， r o w k e y 保存为字节数组。 ¨ 存储时，数据按照 R o w k e y 的字典序（ b yt e or d er ）排序存储。这样的话，设计 ke y 时，要充分利用排序存储这个特性，将经常一起读取的行存储放到一起。 （空间局部性） ¨ 行的一次读写是原子操作（不论一次读写多少列）。这样的设计兼顾了用户可 以理解在一行中的读写行为以及设计上的可扩展性。 20 列族 ¨ 列族的设计与传统数据库中的列不一致 ¨ 与 Bi g T a b l e 中的模式一样， H Ba s e 表中的每个列，都归属于某个列族。列族是表 的 s c h em a 的一部分，必须在使用表之前定义。列名都以列族作为前缀。例如 c ou r s es : h i s t or y ， c ou r s es : m a t h 都属于 c ou r s es 这个列族。 ¨ 访问控制、磁盘和内存的使用统计都是在列族层面进行的。实际应用中，列族 上的控制权限能帮助管理不同类型的应用：允许一些应用可以添加新的基本数 据、一些应用可以读取基本数据并创建继承的列族、一些应用则只允许浏览数 据（甚至可能因为隐私的原因不能浏览所有数据）。 ¤ 在具体实现上，一张表中的不同列族是分开独立存放的。就是说，如果有两个列族 f a m i l y1 和 f a m i l y2 ，那么在 HDF S 存储时， f a m i l y1 是一组文件， f a m i l y2 是另外一组文件， 两者绝不混合存储。 21 时间戳 t i m es t a m p ¨ H Ba s e 中通过 ro w 和 c ol u m n 确定的一个存贮单元称为单元格 c el l 。每个 c el l 都保存 着同一份数据的多个版本。版本通过时间戳来索引。时间戳的类型是 64 位整 型。时间戳可以由 H Ba s e （在数据写入时自动）赋值，此时时间戳是精确到毫 秒的当前系统时间。时间戳也可以由客户显式赋值。如果应用程序要避免数据 版本冲突，就必须自己生成具有唯一性的时间戳。每个 c el l 中，不同版本的数 据按照时间倒序排序，即最新的数据排在最前面。 ¨ 为了避免数据存在过多版本造成的管理（包括存贮和索引）负担， H Ba s e 提供 了两种数据版本回收方式。一是保存数据的最后 n 个版本，二是保存最近一段 时间内的版本（比如最近七天）。用户可以针对每个列族进行设置。 22 物理视图 l 按照列存储的稀疏行 / 列矩阵。物理存储格式上按逻辑模型中的行进行分 割，并按照列族存储。 l 值为空的列不予存储。 23 物理视图 24 列族 c ont e nt s 行键 时间 戳 列族 c ont e nt s \" c om .c nn.w w w \" t6 c ont e nt s : ht m l = \" < ht m l > ...\" t5 c ont e nt s : ht m l = \" < ht m l > ...\" t3 c ont e nt s : ht m l = \" < ht m l > ...\" 列族 a nc hor 行键 时间 戳 列族 a nc hor \" c om .c nn.w w w \" t9 a nc hor : c nns i .c om = ” CN N ” t8 a nc hor : m y .l ook.c a =\" C N N .c om \" 面向列的存储 vs 面向行的存储 25 行式数据库和列式数据库示意图 面向列的存储 vs 面向行的存储 26 行式数据库和列式数据库对比 行式更适合 OL T P ，比 如传统的基于增删改查 操作的应用 列式更适合 OL A P ，非 常适合于数据仓库领域， 比如数据分析、海量存 储和商业智能；涉及不 经常更新的数据 面向列的存储 vs 面向行的存储 27 SQ L 模式 acti on Logout New_tweet Logout Logout87.124.79 .252F58Li nda4 93.24.237 .12M38Tom3 122.158.1 30.90M18Bob2 55.237.10 4.36F34Marry1 i psexageuserLog_i d LogSQL 模 式 1 Marry 34 F 55.237.104.36 Logout行1 2 Bob 18 M122.158.130.90 New_tweet 3 Tom 38 M 93.24.237.12 Logout 行2 行3 55.237.104.36122.158.130.9093.24.237.1287.124.79.252 Marry Bob Tom Li nda 34 18 38 58 F M M F Logout New_tweet Logout Logout 列1:user 列2:age 列3:sex 列4:i p 列5:acti on 行 式 存 储 列 式 存 储 …… 采用面向行的存储 采用面向列的存储 面向列的存储 vs 面向行的存储 28 1 Marry 34 F 55.237.104.36 Logout行1 2 Bob 18 M122.158.130.90New_tweet 3 Tom 38 M 93.24.237.12 Logout 行2 行3 行 式 存 储 …… 面向列的存储 vs 面向行的存储 29 action Logout New_tweet Logout Logout87.124.79 .252F58Linda4 93.24.237 .12M38Tom3 122.158.1 30.90M18Bob2 55.237.10 4.36F34Marry1 ipsexageuserLog_id LogSQL 模 式 1 Marry 34 F 55.237.104.36 Logout行1 2 Bob 18 M122.158.130.90 New_tweet 3 Tom 38 M 93.24.237.12 Logout 行2 行3 55.237.104.36122.158.130.9093.24.237.1287.124.79.252 Marry Bob Tom Linda 34 18 38 58 F M M F Logout New_tweet Logout Logout 列1:user 列2:age 列3:sex 列4:ip 列5:action 行 式 存 储 列 式 存 储 …… 采用面向行的存储 采用面向列的存储 面向列的存储 vs 面向行的存储 30 列式数据库在并行查询处理和压缩上更有优势。而且数据是以列为单元存储，完全不用考虑 数据建模或者说建模更简单了。要查询计算哪些列上的数据，直接读取列就行。 H Ba s e 的查询模式 ¨ H Ba s e 通过行键、列族、列限定符和时间戳来确定一个存储单元，即： ¤ { r o w k e y , c ol u m n f a m i l y: c ol u m n n a m e , t i m es t a m p } à va l u e ¨ H Ba s e 可以支持的查询方式： ¤ 通过单个 ro w k e y 访问 ¤ 通过 ro w ke y 的范围来访问 ¤ 全表扫描 ¨ 合理设计 ro w ke y 31 H Ba s e 表设计 ¨ 表的规范化设计 ¤ 传统数据库：通常需要满足第三范式（ 3NF ） n 第三范式：指表中的所有数据元素不但要能唯一地被主关键字所标识，而且 它们之间还必须相互独立，不存在其他的函数关系。 ¤ N oSQ L 数据库：反规范化。应该将相关的数据都存放在一起，不担心 冗余。 32 H Ba s e 表设计 ¨ Row ke y 的设计要点 n 例 1 ：收集一个集群（ 4000 个节点）中的所有 l og 并在 H Ba s e 表 L O G _D A T A 中存 储。需要收集的字段有 ：（机器名，时间，事件，事件正文） n 插入操作：尽可能高效地插入 n 查询操作： n 需求一：对于某台机器，查询一个大的时间段（例如 1 个月）内的所有满足条件的记 录（单机查询） n 需求二：查询某个时间段内对所有机器满足条件的记录（全局查询） 33 H Ba s e 表设计 ¨ ro w ke y 设计 ¤ 方案一： [ 机器名 ][ 时间 ][ 事件 ] ¤ 方案二： [ 时间 ][ 机器名 ][ 事件 ] ¤ 方案一对单机查询友好，对插入友好（ R eg i on 分散，并发度高） ¤ 方案二对全局查询友好，对插入不友好（ R eg i on 集中，并发度低） ¨ ro w ke y 设计的弥补措施 ¤ s a l t ed （加盐）：对单调数据，通过计算盐值，放在单调数据前让其不单调。 例如： n 盐值 = 时间 % 桶个数 n ro w ke y ： [ 盐值 ] [ 时间 ][ 机器名 ][ 事件 ] n 副作用：查询变慢，降低了系统的吞吐量，桶个数不宜太大 34 H Ba s e 表设计 ¨ 表设计的选择 ¤ 一张大表 or 按时间进行分表？ —— 根据应用需求选择 ¤ 大表设计： n 优点：查询都在单张表完成 n 缺点：数据过期时需要依赖 m a j or c om p a c t i on 进行压缩，会造成大量的数据读 写；活跃 R eg i on 在 R eg i on Ser v er 间的分布可能不均匀。 ¤ 按时间分表设计： n 优点：数据过期可以通过简单删除整张表完成；活跃 R eg i on 可以得到分布均 匀。 n 缺点：需要跨表查询时，性能会比较差。 35 H Ba s e 表设计 ¨ Row ke y 的设计要点 n 例 2 ：设计一张表，用来保存微博上用户互粉的信息。 n 读场景业务要求 1. 每个用户都关注了谁 2. 用户 A 有没有关注用户 B 3. 谁关注了用户 A n 写场景业务要求 1. 用户关注了另一个用户 2. 用户取消关注某个用户 36 H Ba s e 表设计 ¨ 初始设计 37 H Ba s e 表设计 ¨ 改进列族序号方案 38 H Ba s e 表设计 ¨ 改进列族序号方案 39 H Ba s e 表设计 ¨ 改进列名方案 40 H Ba s e 表设计 ¨ 综合优化方案 41 H Ba s e 表设计 ¨ 综合优化方案 42 H Ba s e 表设计 ¨ Row Ke y 加密 43 H Ba s e 表设计 ¨ Row K e y 是 H Ba s e 表结构设计中很重要的一环，它设计的好坏直接 影响程序和 H Ba s e 交互的效率和数据存储的性能。 ¨ H Ba s e 的表结构比传统关系型数据库更灵活，能存储任何二进制 数据在表中，而且无关数据类型。 ¨ 在相同的列族中所有数据都具有相同的操作模式。 ¨ 主要是通过 Row K e y 来建立索引。 44 H Ba s e 表设计 ¨ 以纵向扩张为主设计的表结构能快速简单的获取数据，但牺牲了一定的原子性， 就比如上文中最后一种表结构；而以横向扩张为主设计的表结构，也就是列族 中有很多列，比如上文中第一种表结构，能在行里面保持一定的原子性。 ¨ H Ba s e 没有跨行事务，所有尽量在一次 A PI 请求操作中获取到结果。 ¨ 对 R o w K e y 的 Hash 优化能获得固定长度的 R o w K e y 并使数据分布更加均匀一些， 而不是集中在一台服务器上，但是也牺牲了一定的数据排序和读取性能。 ¨ 可以利用列标识来存储数据。 ¨ 列标识名字的长度和列族名字的长度都会影响 I /O 的读写性能和发送给客户端 的数据量，所以它们的命名应该简洁。 H Ba s e 表设计的经验法则 ¨ 把 r eg i on 的大小限制在 10 到 50 G B 之间。 ¨ 限制 c el l 的大小在 10 M B 之内，如果使用的是 MOB ( M ed i u m O b j ec t St or a g e ) 类 型，限制在 50 M B 之内。否则，考虑把 c el l 的数据存储在 H D F S 中，并在 H Ba s e 中存储指向该数据的指针。 ¨ 典型的 s c h em a 每张表包含 1 到 3 个列族。 H Ba s e 表设计不应当和 RD BM S 表设 计类似。 ¨ 对于拥有 1 或 2 个列族的表来说， 50 - 100 个 r eg i on 是比较合适的。请记住， r eg i on 是列族的连续段。 H Ba s e 表设计的经验法则 ¨ 保持列族名称尽可能短。每个值都会存储列族的名称 ( 忽略前缀编码 ) 。它们不 应该像典型 RD BM S 那样，是自文档化，描述性的名称。 ¨ 如果你正在存储基于时间的机器数据或者日志信息，并且 r o w k e y 是基于设备 ID 或者服务 I D + 时间，最终会出现这样一种情况，即更旧的数据 r eg i on 永远 不会有额外写入。在这种情况下，最终会存在少量的活动 r eg i on 和大量不会 再有新写入的 r eg i on 。 对于这种情况，可以接受更多的 r eg i on 数量，因为资源 的消耗只取决于活动 r eg i on 。 ¨ 如果只有一个列族会频繁写，那么只让这个列族占用内存。当分配资源的时候 注意写入模式。 47 H Ba s e 的运行组成 48 H Ba s e 的运行组成 ¨ 客户端 ¤ 客户端包含访问 H Ba s e 的接口，同时在缓存中维护着已经访问过的 R eg i on 位置信息，用来加快后续数据访问过程 ¨ Zook eep er 服务器 ¤ Zook eep er 可以帮助选举出一个 M a s t er 作为集群的总管，并保证在任何 时刻总有唯一一个 M a s t er 在运行，这就避免了 M a s t er 的“单点失效” 问题 49 H Ba s e 的运行组成 ¨ M a s t er ¤ 主服务器 M a s t er 主要负责表和 R eg i on 的管理工作： n 管理用户对表的增加、删除、修改、查询等操作 n 实现不同 R eg i on 服务器之间的负载均衡 n 在 R eg i on 分裂或合并后，负责重新调整 R eg i on 的分布 n 对发生故障失效的 R eg i on 服务器上的 R eg i on 进行迁移 ¨ R eg i on 服务器 ¤ R eg i on 服务器是 H Ba s e 中最核心的模块，负责维护分配给自己的 R eg i on ， 并响应用户的读写请求 50 H Ba s e 的基本构架 ¨ 由一个 M a s t er Ser v er 和由一组子表数据区服务器 R eg i on Ser v er 构成， 分别存储逻辑大表中的部分数据。大表中的底层数据存于 HDF S 中。 51 H Ba s e 数据存储管理方法 ¨ H Ba s e 子表数据存储与子表服务器 ¤ 与 Bi g T a b l e 类似，大表被分为很多个子表（ R eg i on ），每个子表存储在 一个子表服务器 R eg i on Ser v er 上 52 • 每个 R eg i on 由以下信息标识： < 表名，该 R eg i on 的起始 ro w ke y ，创建时间 > • 每个 R eg i on 的最佳大小取决于单台服务器 的有效处理能力 • 同一个 R eg i on 不会被分拆到多个 R eg i on 服 务器 • 每个 R eg i on 服务器存储 10 - 1000 个 R eg i on H Ba s e 数据存储管理方法 ¨ H Ba s e 子表数据存储与子表服务器 ¤ 每个子表中的数据区 R eg i on 由很多个数据存储块 St or e 构成，而每个 St or e 数据块又由存放在内存中的 m em St or e 和存放在文件中的 St or eF i l e 构成 53 H Ba s e 数据存储管理方法 ¨ H Ba s e 子表数据存储与子表服务器 54 H Ba s e 数据存储管理方法 ¨ H Ba s e 数据的访问 ¤ 当客户端需要进行数据更新时，先查到子表服务器，然后向子表提交 数据更新请求。提交的数据并不直接存储到磁盘上的数据文件中，而 是添加到一个基于内存的子表数据对象 m em St or e 中，当 m em St or e 中的 数据达到一定大小时，系统将自动将数据写入到文件数据块 St or eF i l e 中。 ¤ 每个文件数据块 St or eF i l e 最后都写入到底层基于 HDF S 的文件中。 55 H Ba s e 数据存储管理方法 ¨ H Ba s e 数据的访问 ¤ 需要查询数据时，子表先查 m em St or e 。如果没有，则再查磁盘上的 St or eF i l e 。每个 St or eF i l e 都有类似 B 树的结构，允许进行快速的数据查 询。 St or eF i l e 将定时压缩，多个压缩为一个。 ¤ 两个小的子表可以进行合并；子表大到超过某个指定值时，子表服务 器就需要调用 H R eg i on . c l os eA n d Sp l i t () ，把它分割为两个新的子表。 56 H Ba s e 数据存储管理方法 57 一个 HB a s e 表被划分成多个 R e gi on 一个 R e gi on 会分裂成多个新的 R e gi on按照行键字典序 表 Regi on Regi on Regi on . . . 表 Regi on Regi on Regi on . . . 表 Regi on Regi on Regi on Regi on . . . 分裂 • 开始只有一个 R eg i on ，后来不断分裂 • R eg i on 拆分操作非常快，接近瞬间，因为拆分之后的 R eg i on 读取的仍然是原存储文件，直到“合并”过程把存 储文件异步地写到独立的文件之后，才会读取新文件 H Ba s e 数据存储管理方法 ¨ H Ba s e 数据记录的查询定位 ¤ 描述所有子表和子表中数据块的元数据都存放在专门的元数据表中， 并存储在特殊的子表中。子表元数据会不断增长，因此会使用多个子 表来保存。而所有元数据子表的元数据都保存在根子表中。主服务器 会扫描根子表，从而得到所有的元数据子表位置，再进一步扫描这些 元数据子表即可获得所寻找子表的位置。 58 H Ba s e 数据存储管理方法 ¨ H Ba s e 使用三层类似 B+ 树的结构来保存 R eg i on 位置 ¤ 通过 Zook eep er 里的文件得到 - RO O T - 表的位置， - RO O T - 表永远不会被分割为 多个 R eg i on ¤ 通过 - RO O T - 表查找 .MET A . 表中相应 R eg i on 的位置，为了加快访问， .MET A . 表 的全部 R eg i on 的数据都会全部保存在内存中 ¤ 通过 .MET A . 表找到所要的用户表相应 R eg i on 的位置 59 .M ET A. 表中，每行的 ro w ke y 为： < 用户表名， re g io n 的起始 ro w ke y ，创建时间 > - ROOT - 表中，每行的 ro w ke y 为： <.M ET A., < 用户表名， re g io n 的起始 ro w ke y ，创建时间 > ，创建时间 > - r oot - H Ba s e 数据存储管理方法 ¨ H Ba s e 数据记录的查询定位 ¤ 元数据子表采用三级索引结构 n 根子表 à 用户表的元数据表 à 用户表 60 H Ba s e 数据存储管理方法 61 HB a s e 的三层结构中各层次的名称和作用 层次 名称 作用 第一层 Z ooke e pe r 文件 记录了 - RO O T - 表的位置信息 第二层 - RO O T - 表 记录了 .M E T A . 表的 R e gi on 位置信息 - RO O T - 表只能有一个 R e gi on 。通过 - RO O T - 表，就可以访问 .M E T A . 表中的数据 第三层 .M E T A . 表 记录了用户数据表的 R e gi on 位置信息， .M E T A . 表可以有多个 R e gi on ，保存了 HB a s e 中所有用户数据表的 R e gi on 位置信息 H Ba s e 数据存储管理方法 ¨ 为了加快访问速度， . ME T A . 表的全部 R eg i on 都会被保存在内存中 ¨ 假设 . ME T A . 表的每行（一个映射条目）在内存中大约占用 1 KB ， 并且每个 R eg i on 限制为 128 MB ， 那么，上面的三层结构可以保存的用户数据表的 R eg i on 数目的计算方法是： ¨ （ - RO O T - 表能够寻址的 . ME T A . 表的 R eg i on 个数） × （每个 . ME T A . 表的 R eg i on 可以寻址的用户数 据表的 R eg i on 个数） ¨ 一个 - RO O T - 表最多只能有一个 R eg i on ， 也就是最多只能有 128 MB ， 按照每行（一个映射条目） 占用 1 KB 内存计算， 128 MB 空间可以容纳 128 M B/1 K B= 2 17 行，也就是说，一个 - RO O T - 表可以寻 址 2 17 个 . ME T A . 表的 R eg i on 。 ¨ 同理，每个 . ME T A . 表的 R eg i on 可以寻址的用户数据表的 R eg i on 个数是 128 M B/1 K B= 2 17 。 ¨ 最终，三层结构可以保存的 R eg i on 数目是 (128 M B/1 K B) × ( 1 2 8 M B/1 K B) = 2 34 个 R eg i on 62 H Ba s e 数据存储管理方法 ¨ 客户端访问数据时的“三级寻址” ¤ 为了加速寻址，客户端会缓存位置信息，同时，需要解决缓存失效问题 ¤ 寻址过程客户端只需要询问 Zook eep er 服务器，不需要连接 M a s t er 服务器 63 ZooKeeper 文件 -ROOT-表 .META.表 . . . . . . . . . . . . . . . . . . 用户数据表 . . . . . . . . . 用户数据表 . . . . . . . . . R eg i on 服务器工作原理 ¨ 1. 用户读写数据过程 ¨ 2. 缓存的刷新 ¨ 3. St or eF i l e 的合并 64 R eg i on 服务器工作原理 ¨ 1. 用户读写数据过程 ¤ 用户写入数据时，被分配到相应 R eg i on 服务器去执行 ¤ 用户数据首先被写入到 M em St or e 和 H l og 中 ¤ 只有当操作写入 H l og 之后， c om m i t ( ) 调用才会将其返回给客户端 ¤ 当用户读取数据时， R eg i on 服务器会首先访问 M em St or e 缓存，如果找 不到，再去磁盘上面的 St or eF i l e 中寻找 65 R eg i on 服务器工作原理 ¨ 2. 缓存的刷新 ¤ 系统会周期性地把 M em St or e 缓存里的内容刷写到磁盘的 St or eF i l e 文件 中，清空缓存，并在 H l og 里面写入一个标记 ¤ 每次刷写都生成一个新的 St or eF i l e 文件，因此，每个 St or e 包含多个 St or eF i l e 文件 ¤ 每个 R eg i on 服务器都有一个自己的 H L og 文件，每次启动都检查该文件， 确认最近一次执行缓存刷新操作之后是否发生新的写入操作；如果发 现更新，则先写入 M em St or e ， 再刷写到 St or eF i l e ， 最后删除旧的 H l og 文 件，开始为用户提供服务 66 R eg i on 服务器工作原理 ¨ 3. St or eF i l e 的合并 ¤ 每次刷写都生成一个新的 St or eF i l e ， 数量太多，影响查找速度 ¤ 调用 St or e . c om p a c t () 把多个合并成一个 ¤ 合并操作比较耗费资源，只有数量达到一个阈值才启动合并 67 St or e 工作原理 ¨ St or e 是 R eg i on 服务器的核心 ¤ 多个 St or eF i l e 合并成一个 ¤ 单个 St or eF i l e 过大时，又触发分裂操作， 1 个父 R eg i on 被分裂成两个子 R eg i on 68 St oreFi l e1: 64M St oreFi l e2: 64M St oreFi l e3: 64M St oreFi l e4: 64M St oreFi l e5: 256M St oreFi l e5A: 128M St oreFi l e5B: 128M St oreFi l e6: 128M St oreFi l e7: 128M 合并 分裂 Stor eFi l e 的合并和分裂过程 H L og 工作原理 ¨ 分布式环境必须要考虑系统出错。 H Ba s e 采用 H L og 保证系统恢复 ¨ H Ba s e 系统为每个 R eg i on 服务器配置了一个 H L og 文件，它是一种 预写式日志（ W r i t e A h ea d L og ） ¨ 用户更新数据必须首先写入日志后，才能写入 M em St or e 缓存，并 且，直到 M em St or e 缓存内容对应的日志已经写入磁盘，该缓存内 容才能被刷写到磁盘 69 H L og 工作原理 70 H L og 工作原理 p Zook eep er 会实时监测每个 R eg i on 服务器的状态，当某个 R eg i on 服务器发生故障时， Zook eep er 会通知 M a s t er p M a s t er 首先会处理该故障 R eg i on 服务器上面遗留的 H L og 文件，这个遗留的 H L og 文件中包含了来 自多个 R eg i on 对象的日志记录 p 系统会根据每条日志记录所属的 R eg i on 对象对 H L og 数据进行拆分，分别放到相应 R eg i on 对象的 目录下，然后，再将失效的 R eg i on 重新分配到可用的 R eg i on 服务器中，并把与该 R eg i on 对象相 关的 H L og 日志记录也发送给相应的 R eg i on 服务器 p R eg i on 服务器领取到分配给自己的 R eg i on 对象以及与之相关的 H L og 日志记录以后，会重新做一 遍日志记录中的各种操作，把日志记录中的数据写入到 M em St or e 缓存中，然后，刷新到磁盘 的 St or eF i l e 文件中，完成数据恢复 p 共用日志优点：提高对表的写操作性能；缺点：恢复时需要分拆日志 71 H Ba s e 存储格式 ¨ H Ba s e 中的所有数据文件都存储在 H a d oop H D F S 文件系统上，主 要包括两种文件类型： ¤ HF ile ， H Ba s e 中 K e yV a l u e 数据的存储格式， HF ile 是 H a d oop 的二进制格 式文件，实际上 St or eF i l e 就是对 HF ile 做了轻量级包装，即 St or eF i l e 底层 就是 HF ile ¤ H L og F i l e ， H Ba s e 中 WA L （ W r i t e A h ea d L og ）的存储格式，物理上是 H a d oop 的 Seq u en c e F i l e 72 摘要 p H Ba s e 基本工作原理 p H Ba s e 基本操作 p H Ba s e 编程方法示例 73 H Ba s e ¨ 官网： ¤ h t t p : //h b a s e . a p a c h e . or g ¨ 最新版本： ¤ 3. 0. 0 - al ph a - 4 J u n 7, 2023 ¤ 2. 5. 6 Oc t 20, 2023 ¤ 2. 4. 17 Ap r 6, 2023 ¨ 参考指南： ¤ h t t p : //h b a s e . a p a c h e . or g /b ook . h t m l 74 H Ba s e ¨ 版本兼容问题 75 H Ba s e 配置和安装 ¨ hb a s e - en v . s h ¤ J A V A _H O M E ¤ H B A SE _M A N A G E S_ZK ( 默认为 tr u e ，可能需要取消注释，改成 fal se ) ¤ H B A SE _D I SA BL E _H A D O O P_C L A SSP A T H _L O O K U P ( 默认为 fal se ，可能需要取消注释，改成 tr u e ) ¨ hb a s e - s i t e . xm l ¤ St a n d a l on e 模式 ¤ D i s t r i b u t ed 模式 n 单机伪分布式模式 / 集群模式 ¨ We b I n t er f a c e ： ¤ h t t p : //l oc a l h os t : 1 6 0 1 0 76 H Ba s e 配置和安装 ¨ 前提 ¤ JDK ¤ H a d oop （单机模式不需要，伪分布模式和集群模式需要） ¤ SSH ¨ 启动关闭 H a d oop 和 H Ba s e 的顺序一定是： 启动 H a d oop à 启动 H Ba s e à 关闭 H Ba s e à 关闭 H a d oop ¨ H B A SE _M A N A G E S_ZK = t r u e ，则由 H Ba s e 自己管理 Zook eep er ， 否则，启动独立 的 Zook eep er ¨ 建议：单机版 H Ba s e ，使用自带 Zook eep er ；集群安装 H Ba s e 则采用单独 Zook eep er 集群 77 H Ba s e 基本操作与编程方法 ¨ H Ba s e Sh el l 操作 ¤ H Ba s e Sh el l 常用的操作命令有 c r ea t e , d es c r i b e , di s abl e , en a b l e , d r op , lis t , sc a n , pu t , g et , d el et e , d el et ea l l , c ou n t , st a t u s 等，通过 h el p 可以看到详细的 用法。 ¤ 在 H Ba s e Sh el l 语法中， 所有字符串参数都必须包含在单引号中，且区 分大小写。 78 H Ba s e Sh el l 操作 ¨ 表的管理 ¤ 查看有哪些表 n lis t ¤ 创建表 n c r ea t e < t a b l e> , { N A M E = > < f a m i l y> , V E RSI O N S = > < V E RSI O N S> } ¤ 删除表 n di sabl e < t a b l e> n d r op < t a b l e> ¤ 查看表结构 n d es c r i b e < t a b l e> ¤ 修改表结构 n a l t er ' t 1 ' , { N A M E = > ' f 1 ' } , { N A M E = > ' f 2 ' , M E T H O D = > ' d el et e' } 79 H Ba s e Sh el l 操作 ¨ 表数据的增删查改 ¤ 添加数据 n p u t < t a b l e> , < ro w k e y >, < f a m i l y: c ol u m n > , < v a l u e> , < t i m es t a m p > ¤ 查询数据 n 查询某行记录 n g et < t a b l e> , < ro w k e y >, [ < f a m i l y: c ol u m n >, . . . . ] n 扫描表 n s c a n < t a b l e> , { C O L U M N S = > [ < f a m i l y: c ol u m n >, . . . . ] , L I M I T => num } n 查询表中的数据行数 n c ou n t < t a b l e> , { I N T E R V A L = > i n t er v a l N u m , C A C H E = > c a c h eN u m } 80 H Ba s e Sh el l 操作 ¨ 表数据的增删查改 ¤ 删除数据 n 删除行中的某个列值 n d el et e < t a b l e> , < ro w k e y >, < f a m i l y: c ol u m n > , < t i m es t a m p > n 必须指定列名 n 删除行 n d el et ea l l < t a b l e> , < ro w k e y >, < f a m i l y: c ol u m n > , < t i m es t a m p > n 可以不指定列名，删除整行数据查询表中的数据行数 n 删除表中的所有数据 n t r u n c a t e < t a b l e> 81 H Ba s e Sh el l 操作 ¨ 我们建立如下的表以及数据 82 行键 列族 St u I n f o 列族 Gr ad e s Na me Ag e Se x Cl a ss Bi g D a t a C om p u t er Ma th 0001 T om G r een 18 Ma l e 80 90 85 0002 Am y 19 01 95 89 0003 A l l en 19 Ma l e 02 90 88 创建表 ¨ H Ba s e 使用 c r ea t e 命令创建表，创建表时需要指明表名和列族名 ¤ c r ea t e ' St u d en t ' , ' St u I n f o ' , ' G r a d es ’ ¨ 如果建表时要设置列族的参数，比如 ¤ c r ea t e ' St u d en t ' , { N A M E = > ' St u l n f o ', V E RSI O N S = > 3 } , { N A M E = > ' G r a d es ' , BL O C K C A C H E = > tr u e } n 大括号内是对列族的定义， NA ME 、 V E RSI O N 和 BL O C K C A C H E 是参数名，无须使用单引号，符号 => 表示将后面的值赋给指定参数。 ¨ 创建表结构以后，可以使用 e xi s t s 命令查看是否存在，或使用 lis t 命令查看数据 库中所有表，还可以使用 d es c r i b e 命令查看指定表的列族信息。 83 查看表 ¨ 创建表结构以后，可以使用 e xi s t s 命令查看是否存在，或使用 lis t 命令查看数据 库中所有表，还可以使用 d es c r i b e 命令查看指定表的列族信息。 84 修改表 85 ¨ 修改列族 ¤ a l t er ' St u d en t ' , { N A M E = > ' G r a d es ' , V E RSI O N S = > 3 } ¤ 注意： 修改 已有数据的列族属性时， H Ba s e 需要对列族里所有数据进行修改，如果数据量较 大，则修改可能要占用很长时间 ¨ 增加列族 ¤ a l t er ' St u d en t ' , ' h ob b y' ¨ 删除列族 ¤ a l t er ' St u d en t ' , { N A M E = > ' h ob b y' , M E T H O D = > ' d el et e' } ¤ a l t er ' St u d en t ' , ' d el et e' = > ' h ob b y' ¤ 注意 ： H Ba s e 表至少要包含一个列族，因此当表中只有一个列族时，无法将其删除。 删除表 86 ¨ H Ba s e 使用 d r op 命令删除表，但是在删除表之前需要先使用 di s abl e 命令禁用表。例如： ¤ d i s a b l e ' St u d en t ' ¤ d r op ' St u d en t ' ¨ 如果 只是想清空表中的所有数据，使用 t r u n c a t e 命令即可，此命 令相当于完成禁用表、删除表，并按原结构重新建立表操作 ¤ t r u n c a t e ' St u d en t ' 插入数据 ¨ H Ba s e 使用 pu t 命令向数据表中插入数据， pu t 向表中增加一个新 行数据，或覆盖指定行的数据。例如： ¤ p u t ' St u d en t ' , ' 0 0 0 1 ' , ' St u l n f o: N a m e ' , ' T om G r een ' , 1 n ‘ St u d en t ’ 为 表名； ‘0 0 0 1 ‘ 为 行键的名称，为字符串类型； ’ St u l n f o: N a m e ‘ 为 列族和列的名称， 中间用冒号隔开， 列族名必须是已经创建的 ，否则 H Ba s e 会报错，列名是临时定义的， 因此列族里的列可以随意扩展； ’ T om G r een ’ 为 单元格的值，所有数据都是字符串的形 式； ’1 ’ 为时间戳，如果不设置时间戳，则系统会自动插入当前时间为时间戳。 n 如果 pu t 语句中的单元格是已经存在的，即行键、列族及列名都已经存在，且不考虑时间戳的情 况下，执行 pu t 语句，则可对数据进行更新操作。例如： n p u t ' St u d en t ' , ' 0 0 0 1 ' , ' St u l n f o: N a m e ' , ' J i m G r een ‘ n 如果在初始创建表时，已经设定了列族 V E RSI O N S 参数值为 n ，则 pu t 可以保存 n 个版本的数据。 87 删除数据 ¨ H Ba s e 使用 d el et e 命令可以从表中删除一个单元格或一个行集， 语法和 pu t 类似，必须知名表名和列族名称，而列名和时间戳是 可选的。例如： ¤ d el et e ' St u d en t ' , ' 0 0 0 2 ' , ' G r a d es ' n 需要注意的是， d el et e 操作并不会马上删除数据，只会将对应的数据打上删除标记（ t om b s t on e ）， 只有在合并数据时，数据才会被删除。 ¤ d el et e 命令不能跨列族操作，如需删除表中所有列族在某一行上的数据，即 删除上表中一个逻辑行，则需要使用 d el et ea l l 命令，如下所示，不需要指 定列族和列的名称： n d el et ea l l ' St u d en t ' , ‘ 0 0 0 1 ' 88 获取数据和查询全表数据 ¨ H Ba s e 使用 g et 命令可以从数据表中获取某一行记录，类似于关 系型数据库中的 s el ec t 操作。 g et 命令必须设置表名和行键名， 同时可以选择指明列族名称、时间戳范围、数据版本等参数。例 如： ¤ g et ' St u d en t ' , ' 0 0 0 1 ' ¨ H Ba s e 使用 scan 命令用来查询全表数据，使用时只需要指定表名即可。例如： ¤ sc an ' St u d en t ' ¤ sc an 只从 条件输出时，需要使用大括号将参数包含起来，例如： n sc a n ' St u d en t ' , { C O L U M N S = > ' G r a d es ' } 89 H Ba s e 的过滤器 ¨ H Ba s e 提供了种类丰富的过滤器（ f i l t er ）来提高数据处理的效率，用户可以通 过内置或自定义的过滤器来对数据进行过滤，所有的过滤器都在服务端生效， 即谓词下推（ p r ed i c a t e p u s h d o w n ）。这样可以保证过滤掉的数据不会被传送 到客户端，从而减轻网络传输和客户端处理 的压力。 H Ba s e 的过滤器 ¨ 在 H Ba s e 中， g et 和 scan 操作都可以使用过滤器来设置输出的范围，类似 SQ L 里 的 w h er e 查询条件。 ¨ 使用 s h o w _f i l t er s 命令可以查看当前 H Ba s e 支持的过滤器类型。 91 H Ba s e 的过滤器 ¨ 在使用上述过滤器时，一般需要配合比较运算符或比较器使用。 ¨ 使用过滤器的语法格式： ¤ sc a n ‘ 表名 ’ , { F i l t er = > ” 过滤器 ( 比较运算符 , ‘ 比较器 ’) ” } ¤ Fil t e r = > 指明过滤的方法，整体可用大括号引用，也可以不用大括号。过滤的方法用双引号引用，而比较方式用 小括号引用。 92 比较运算符 比较器 比较运算符 描述 = 等于 > 大于 >= 大于等于 < 小于 <= 小于等于 != 不等于 比较器 描述 Bi n a r yC om p a r a t or 匹配完整字节数组 Bi n a r yPr ef i xC om p a r a t or 匹配字节数组前缀 Bi t C om p a r a t or 匹配比特位 N u l l C om p a r a t or 匹配空值 R eg e xSt r i n g C om p a r a t or 匹配正则表达式 Su b s t r i n g C om p a r a t or 匹配子字符串 H Ba s e 的常用过滤器 ¨ 行键过滤器 R o w F i l t er ¤ 可以配合比较器和运算符，实现行键字符串的比较和过滤。例如，匹配行键中大于 0001 的数据，可使用 b i n a r y 比较器；匹配以 0001 开头的行键，可使用 su b st ri n g 比较 器，注意 su b st ri n g 不支持大于或小于运算符。 93 H Ba s e 的过滤器 ¨ 针对行键进行匹配的过滤器还有 Pr ef i xF i l t er 、 K e yO n l yF i l t er 、 F i r s t K e yO n l yF i l t er 和 I n c l u s i v eSt op F i l t er 。 94 行键过滤器 描述 示例 Pr ef i xF i l t er 行键前缀比较器，比较行键前缀 s c a n ' St u d en t ' , F I L T E R = > \" Pr ef i xF i l t er (' 0 0 0 1 ' )\" s c a n ' St u d en t ' , F I L T E R = > \" R o w F i l t er (=, ' s ub s tr i ng : 0 0 0 1 ' )\" K e yO n l yF i l t er 只对单元格的键进行过滤和显示， 不显示值 s c a n ' St u d en t ' , F I L T E R = > \" K e yO n l yF i l t er ()\" F i r s t K e yO n l yF i l t er 只扫描显示相同键的第一个单元 格，其键值对会显示出来 s c a n ' St u d en t ' , F I L T E R = > \" F i r s t K e yO n l yF i l t er ()\" I n c l u s i v eSt op F i l t er 替代 E N D RO W 返回终止条件行 s c a n ' St u d en t ' , { ST A RT RO W = > ' 0 0 0 1 ' , F I I L T E R = > \" I n c l u s i v eSt op F i l t er ( ' b i n a r y: 0 0 0 2 ' ) \" } s c a n ' St u d en t ' , { ST A RT RO W = > ' 0 0 0 1 ' , E N D RO W = > '0003' } H Ba s e 的过滤器 ¨ 列族与列过滤器 ¤ 针对列族进行过滤的过滤器为 F a m i l yF I i t er ，其语法结构与 R o w F i l t er 类似，不同之处在 于 F a m i l yF i l t er 是对列族名称进行过滤的。例如： n s c a n ' St u d en t ' , F I L T E R= > \" F a m i l yF i l t er (= , ' s u b s t r i n g : G r a d es ') \" ¤ 针对列的过滤器如下，这些过滤器也需要结合比较运算符和比较器进行列族或列的扫 描过滤。 95 列过滤器 描述 示例 Q u a l i f i er F i l t er 列标识过滤器，只显示对应列名的 数据 s c a n ' St u d en t ' , F I L T E R = > \" Q u a l i f i er F i l t er (=, ' su b st ri n g : M a t h ') \" C ol u m n Pr ef i xF i l t er 对列名称的前缀进行过滤 s c a n ' St u d en t ' , F I L T E R = > \" C ol u m n Pr ef i xF i l t er (' Ma ' )\" M u l t i p l eC ol u m n Pr ef i xF i l t er 可以指定多个前缀对列名称过滤 s c a n ' St u d en t ' , F I L T E R = > \" M u l t i p l eC ol u m n Pr ef i xF i l t er (' Ma ' , ' Ag ') \" C ol u m n R a n g eF i l t er 过滤列名称的范围 s c a n ' St u d en t ' , F I L T E R = > \" C ol u m n R a n g eF i l t er (' Bi g ' , t r u e , ' M a t h ' , f a l s e ') \" H Ba s e 的过滤器 ¨ 值过滤器：针对单元格进行扫描的过滤器 ¤ V a l u eF i l t er 过滤器可以利用 g et 和 sc a n 方法对单元格进行过滤，但是使用 g et 方法时， 需要指定行键。 Si n g l eC ol u m n V a l u eF i l t er 和 Si n g l eC ol u m n V a l u eE x c l u d eF i l t er 过滤器扫描的 结果是相反的， 都需要在过滤条件中指定列族和列的名称。 96 值过滤器 描述 示例 V a l u eF i l t er 值过滤器，找到符合 值条件的键值对 s c a n ' St u d en t ' , F I L T E R = > \" V a l u eF i l t er (=, ' su b st ri n g : c u rry ') \" g et ' St u d en t ' , ' 0 0 0 1 ' , F I L T E R = > \" V a l u eF i l t er (=, ' su b st ri n g : c u rry ') \" Si n g l eC ol u m n V a l u eF i l t er 在指定的列族和列中 进行比较的值过滤器 s c a n ' St u d en t ' , F i l t er = > \" Si n g l eC ol u m n V a l u eF i l t er (' St u I n f o ', ' N a m e' , = , ' b i n a r y: c u r r y ') \" Si n g l eC ol u m n V a l u eE x c l u d eF i l t er S 排除匹配成功的值 s c a n ' St u d en t ' , F i l t er = > \" Si n g l eC ol u m n V a l u eE x c l u d eF i l t er (' St u I n f o ', ' N a m e' , = , ' b i n a r y: c u r r y ') \" H Ba s e 的过滤器 ¨ 其他过滤器 97 值过滤器 描述 示例 C ol u m n C ou n t G et F i l t er 限制每个逻辑行返回键值对的 个数，在 g et 方法中使用 g et ' St u d en t ' , ' 0 0 0 1 ' , F I L T E R = > \" C ol u m n C ou n t G et F i l t er ( 3 ) \" T i m es t a m p s F i l t er 时间戳过滤，支持等值，可以 设置多个时间戳 s c a n ' St u d en t ' , F i l t er = > \" T i m es t a m p s F i l t er ( 1 , 4 ) \" I n c l u s i v eSt op F i l t er 设置停止行 s c a n ' St u d en t ' , { ST A RT RO W = > ' 0 0 0 1 ' , E N D RO W = > ' 0 0 0 5 ' , F I L T E R = > \" I n c l u s i v eSt op F i l t er (' 0 0 0 3 ' )\" } P a g eF i l t er 对显示结果按行进行分页显示 s c a n ' St u d en t ' , { ST A RT RO W = > ' 0 0 0 1 ' , E N D RO W = > ' 0 0 0 5 ' , F I L T E R = > \" P a g eF i l t er ( 3 ) \" } C ol u m n P a g i n a t i on F i l t er 对一行的所有列分页，只返回 [ of f s et , of f s et + l i m i t ] 范围内的列 s c a n ' St u d en t ' , { ST A RT RO W = > ' 0 0 0 1 ' , E N D RO W = > ' 0 0 0 5 ' , F I L T E R = > \" C ol u m n P a g i n a t i on F i l t er (2 , 1 )\" } H Ba s e 中的 di sabl e 和 en a b l e ¨ disable 和 en a b l e 都是 H Ba s e 中比较常见的操作，很多对 table 的修改都需要表在 disable 的状态下才能进行 ¨ disable ′ s t u d en t s ′ 将表 s t u d en t s 的状态更改为 disable 的时候， H Ba s e 会在 z ook eep er 中的 table 结点下做记录 ¨ 在 z ook eep er 记录下该表的同时，还会将表的 r eg i on 全部下线， r eg i on 为 of f l i n e 状 态 ¨ en a b l e 的过程和 disable 相反，会把表的所有 r eg i on 上线，并删除 z ook eep er 下的 标志。如果在 en a b l e 前， MET A 中有 r eg i on 的 s er v er 信息，那么此时会在该 s er v er 上将该 r eg i on 上线；如果没有 s er v er 的信息，那么此时还要随机选择一台机器 作为该 r eg i on 的 s er v er 98 摘要 p H Ba s e 基本工作原理 p H Ba s e 基本操作 p H Ba s e 编程方法示例 99 H Ba s e 的 A PI 接口 ¨ H Ba s e 提供了丰富的 A PI 接口让用户去操作这些数据。主要的 A PI 接 口有 3 个， Pu t ， G et ， Sc a n 。 Pu t 和 G et 是操作指定行的数据的，所 以需要提供行键来进行操作。 Sc a n 是操作一定范围内的数据，通 过指定开始行键和结束行键来获取范围，如果没有指定开始行键 和结束行键，则默认获取所有行数据。 100 H Ba s e 的 Ja v a 编程 ¨ H Ba s e Ja v a 编程接口概述 H Ba s eC on f i g u r a t i on ¤ H Ba s eC on f i g u r a t i on 是每一个 H Ba s e c l i en t 都会使用到的对象，它代表的 是 H Ba s e 配置信息。 ¤ 默认的构造方式会尝试从 hb a s e - d ef a u l t . xm l 和 hb a s e - s i t e . xm l 中读取配置。 如果 cl a s s p a t h 没有这两个文件，就需要你自己设置配置。 ¤ 配置 Ja v a 代码示例： C on f i g u r a t i on H B A SE _C O N F I G = n e w C on f i g u r a t i on ( ) ; H B A SE _C O N F I G . s et (“ h b a s e . z ook eep er . q u or u m ”, “ z k Ser v er ”) ; H B A SE _C O N F I G . s et (“ h b a s e . z ook eep er . p r op er t y . c l i en t P or t ”, “2181 ″ ); H Ba s eC on f i g u r a t i on cf g = n e w Ba s eC on f i g u r a t i on ( H B A SE _C O N F I G ) ; 101 H Ba s e 的 Ja v a 编程：创建表 ¨ 创建表是通过 Adm i n 对象来操作的。 Adm i n 负责表的 ME T A 信息处 理。 Adm i n 提供了 c r ea t eT a b l e 这个方法： ¤ p u b l i c v oi d c r ea t eT a b l e ( H T a b l eD es c r i p t or d es c ) ¨ H T a b l eD es c r i p t or 代表的是表 s c h em a ¨ H C ol u m n D es c r i p t or 代表的是 c ol u m n 的 s c h em a 102 H Ba s e 的 Ja v a 编程：创建表 ¨ Ja v a 代码示例： C on n ec t i on c on n = C on n ec t i on F a c t or y . c r ea t eC on n ec t i on ( c on f i g ); Ad m i n adm in = c on n . g et A d m i n (); H T a b l eD es c r i p t or t = ne w H T a b l eD es c r i p t or ( t a b l eN a m e ); t. a d d F a m i l y (ne w H C ol u m n D es c r i p t or (“ f 1 ″ )); t. a d d F a m i l y (ne w H C ol u m n D es c r i p t or (“ f 2 ″ )); t. a d d F a m i l y (ne w H C ol u m n D es c r i p t or (“ f 3 ″ )); t. a d d F a m i l y (ne w H C ol u m n D es c r i p t or (“ f 4 ″ )); a d m i n . c r ea t eT a b l e (t); 103 H Ba s e 的 Ja v a 编程：插入数据 ¨ Ta b l e 通过 pu t 方法来插入数据，可以传递单个批 Pu t 对象或者 Li s t p u t 对象来分别实现单条插入和批量插入。 Pu t 对象的常用方法： publ i c s t a t i c v oi d addD ata ( St r i n g t a b l eN a m e , St r i n g ro w K e y , St r i n g f a m i l y , St r i n g q u a l i f i er , St r i n g v a l u e) th r o w s E x c ep t i on { tr y { C on n ec t i on c on n = C on n ec t i on F a c t or y . c r ea t eC on n ec t i on ( c on f i g ); Ta b l e t a b l e = c on n . g et T a b l e ( t a b l eN a m e ); Pu t p u t = ne w Pu t ( Byt es . t oBy t e s ( ro w K e y )); pu t. add ( Byt es . t oBy t e s ( f a m i l y) , Byt es . t oBy t e s ( q u a l i f i er ) , Byt es . t oBy t e s ( v a l u e) ) ; tabl e . pu t (pu t); Sys t em . ou t .p r int ln ( “ i n s er t r ec or d s u c c es s ! \" ) ; } ca t ch ( I O E x c ep t i on e) { e . p r i n t St a c k T r a c e (); } } 104 H Ba s e 的 Ja v a 编程：删除表 ¨ 删除表也通过 Adm i n 来操作，删除表之前首先要 di s abl e 表。这是 一个非常耗时的操作，所以不建议频繁删除表。 d i s a b l eT a b l e 和 d el et eT a b l e 分别用来 di s abl e 和 d el et e 表 ¨ Ja v a 代码示例： if ( a d m i n . t a b l eE xi s t s ( t a b l eN a m e )){ a d m i n . d i s a b l eT a b l e ( t a b l eN a m e ); a d m i n . d el et eT a b l e ( t a b l eN a m e ); } 105 H Ba s e 的 Ja v a 编程：查询数据 ¨ 查询分为单条随机查询和批量查询 ¤ 单条查询是通过 ro w ke y 在 ta b l e 中查询某一行的数据。 Ta b l e 提供了 g et 方法来完成单条查询。 ¤ 批量查询是通过制定一段 ro w ke y 的范围来查询。 Ta b l e 提供了个 g et Sc a n n er 方法来完成批量查询。 ¨ Ja v a 代码示例： Sc a n s = n e w Sc a n ( ) ; s . s et M a xV er s i on s (); R es u l t Sc a n n er ss = t a b l e . g et Sc a n n er (s ); f or ( R es u l t r: ss ){ Sys t em . ou t . p r i n t l n (ne w St r i n g ( r . g et R o w ())); f or ( K e yV a l u ek v : r . r a w ()){ Sys t em . ou t . p r i n t l n ( n e w St r i n g ( k v . g et C ol u m n ()));} } 106 H Ba s e 的 Ja v a 编程：删除数据 ¨ Ta b l e 通过 d el et e 方法来删除数据： d el et e( f i n a l D el et e d el et e) ¨ D el et e 常用方法： ¤ d el et eF a m i l y 或 d el et eC ol u m n s ： ¤ 指定要删除的 fa m i l y 或者 c ol u m n 的数据。如果不调用任何这样的方法， 将会删除整行 T a b l e t a b l e = c on n . g et T a b l e (“ m yt es t ”); D el et e d = n e w D el et e( “ r o w 1 ″ . g et Byt es ( ) ) ; t a b l e . d el et e (d ) 107 H Ba s e 的 Ja v a 编程：切分表 ¨ 参数 h b a s e . h r eg i on . m a x. f i l es i z e 指示在当前 R ei g on Ser v er 上单个 R ei g on 的最大存储空间，单个 R eg i on 超过该值时，这个 R eg i on 会被 自动 sp l i t 成更小的 r eg i on 。 ¤ Adm i n 提供 spl i t 方法来将 table 进行手工 spl i t 。 n pu bl i c v oi d sp l i t ( T a b l eN a m e t a b l eN a m e ) ¤ Adm i n 提供 s p l i t R eg i on 方法来将 r eg i on 进行手工 spl i t 。 n pu bl i c v oi d s p l i t R eg i on ( b yt e[ ] r eg i on N a m e ) ¤ 由于 spl i t 是一个异步操作，并不能确切地控制 r eg i on 的个数。 108 H Ba s e 的 Ja v a 编程：程序的编写与运行 p 官网教程： l h t t p s : //h b a s e . a p a c h e . or g /b ook . h t m l # _e xa m p l es p 与 H a d oop 编程类似，在进行 H Ba s e J a v a 编程的时候也需要配置相关的类 包文件 ja r 文件，在程序执行的时候，还需要给出类库的目录。 ¤ 在开发环境中准备导入 jar 包： ¤ 将 H Ba s e 目录中的 jar 包以及 lib 中的所有 jar 包都加入 ¨ 或者使用 m a v en 构建，参考代码： ¤ h t t p s : //g i t h u b . c om /yu p i n g - n j u /b d k i t - d em o/b l ob /m a s t er /h b a s e - jav a - d em o 109 TH A NK YO U","libVersion":"0.2.4","langs":""}