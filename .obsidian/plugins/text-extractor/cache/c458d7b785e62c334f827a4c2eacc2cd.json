{"path":"课程/大数据/课件/20 Spark Advanced Programming (II).pdf","text":"Sp a r k 高级编程 (I I ) 摘要 ¨ Sp a r k St r ea m i n g ¨ Sp a r k St r u c t u r ed St r ea m i n g ¨ Gr a p h X 摘要 ¨ Sp a r k St r ea m i n g ¨ Sp a r k St r u c t u r ed St r ea m i n g ¨ Gr a p h X Sp a r k St r ea m i n g 4 Spa r k St r e a m i ng m a ke s i t e a sy t o b u i l d sca l a b l e f a u l t - t o l e r a n t st r e a m i n g a p p l i ca t i o n s. 架构 5 工作原理 ¨ Sp a r k St r ea m i n g 将流式计算分解成一系列短小的批处理作业，具 有如下特性： ¤ 能线性扩展至超过数百个节点； ¤ 实现亚秒级延迟处理； ¤ 可与 Sp a r k 批处理和交互式处理无缝集成； ¤ 提供了一个简单的 A PI 实现复杂的算法； ¤ 更多的网络流方式支持，包括 Ka f k a 、 Fl um e 、 K i n es i s 、 T w i t t er 、 Zer oM Q 等。 6 D St r ea m 抽象 ¨ D St r ea m ( D i s c r et i z ed St r ea m , 离散流 ) ：连续的数据流，由一系列 RD D s 组成。 7 D St r ea m 抽象 ¨ D St r ea m 的核心思想是将计算作为一系列较小时间间隔的、状态 无关的、确定批次的任务，每个时间间隔内接收到的输入数据被 可靠地存储在集群中，作为它的一个输入数据集。当某个时间间 隔完成，将对相应的数据集并行地进行 Ma p 、 R ed u c e 和 g r ou p By 等 操作，产生中间数据或输出新的数据集，并存储在 RD D 中。任务 间的状态可以通过 RD D 重新计算，得益于计算任务被分解成一系 列 的小任务， 用户可以在合适的粒度上呈现任务间的依赖关系。 8 D St r ea m 抽象 ¨ 两类操作： ¤ 转换操作：生成一个新的 D St r ea m ¤ 输出操作：把数据写入外部系统中 ¨ 增加了与时间相关的新操作，比如滑动窗口 9 简单的例子 ¨ 例：从监听 TC P 套接字的数据服务器获取文本数据，然后计算文本中包含的单 词数。 10 简单的例子 ¨ 例：从监听 TC P 套接字的数据服务器获取文本数据，然后计算文本中包含的单 词数。 11 抽象 ¨ D St r ea m 抽象 12 输入源 ¨ 每一个输入流 D St r ea m 和一个 R ec ei v er 对象关联，这个 R ec ei v er 从源中获取数据， 并将数据存入内存中进行处理。 ¨ 输入源 ¤ 基本源：在 St r ea m i n g C on t e xt A PI 中直接使用，例如文件系统、套接字连接、 Ak k a 的 a c t or 等。 ¤ 高级源：包括 Ka f k a ， Flum e ， T w i t t er 等，需要通过额外的类来使用。 ¨ 多个数据流 à 多个 R ec ei v er ，要分配足够的核（如果是本地运行，那么是线程） 用以处理接收的数据并且运行 r ec ei v er 是非常重要的 13 D St r ea m 操作 ¨ 转换操作：允许在 D St r ea m 运行任何 RD D - to - RD D 函数，比如 ma p , fl a t M a p , f i l t er , r ed u c e , j oi n 等 ¨ 状态操作 ¤ u p d a t eSt a t eByK e y ：不断用新信息更新它的同时保持任意状态 ¤ 窗口操作：允许在一个滑动窗口数据上应用 t r a n s f or m a t i on 算子，需制定两个 参数：窗口长度（窗口的持续时间）和滑动的时间间隔（窗口操作执行的 时间间隔） 14 D St r ea m 操作 15 D St r ea m 操作 16 D St r ea m 操作 ¨ 输出操作 17 D St r ea m 操作 ¨ 缓存及持久化 ¤ p er s i s t ( ) ¤ D St r ea m 的持久化策略是将数据序列化在内存中。 ¤ 基于窗口或状态的操作，如 r ed u c eByWi n d o w 、 r ed u c eByK e yA n d Wi n d o w 和 u p d a t eSt a t eByK e y ， D s t r ea m 都会自动持久化在内存中，无须显式调 用 p er s i s t ( ) 方法。 ¤ 通过网络接收的流数据默认采取保存两份序列化后的数据在两个不同 的节点上的持久化策略，从而实现容错。 18 C h ec k p oi n t i n g 机制 ¨ M et a d a t a c h ec k p oi n t i n g ：保存流计算的定义信息到容错存储系统如 HDF S 中。这用来恢复应用程序中运行 w or k er 的节点的故障。元数据 包括： ¤ C on f i g u r a t i on ¤ D St r ea m op er a t i on s ¤ I n c om p l et e b a t c h es ¨ Da t a c h ec k p oi n t i n g ：保存生成的 RD D 到可靠的存储系统中，这在有 状态 t r a n s f or m a t i on （如结合跨多个批次的数据）中是必须的。有状 态的 t r a n s f or m a t i on 的中间 RD D 会定时存储到可靠存储系统中。 19 C h ec k p oi n t i n g 配置 ¨ 在容错、可靠的文件系统（ HDF S 、 S3 等）中设置一个目录用于保存 c h ec k p oi n t 信息。 ¤ s t r ea m i n g C on t e xt . c h ec k p oi n t ( c h ec k p oi n t D i r ec t or y ) 20 Sp a r k St r ea m i n g 编程 ¨ 首先创建 St r ea m i n g C on t e xt ： # 方法一： va l c on f = n e w Sp a r k C on f (). s et A p p N a m e ( appN am e ). s et M a s t er ( m a s t er ) ; va l ssc = ne w St r ea m i n g C on t e xt ( c on f , Sec on d s ( 1 ) ) ; # 方法二：可以使用已有的 Sp a r k C on t e xt 来创建 va l sc = ne w Sp a r k C on t e xt ( c on f ) ; va l ssc = ne w St r ea m i n g C on t e xt ( sc , Sec on d s ( 1 ) ) ; ¨ 注： appName ，是用来在 Sp a r k U I 上显示的应用名称； m a s t er ，是一个 Sp a r k 、 M es os 或者 Ya r n 集群的 U RL ，或者是 l oc a l [ * ] ； batc h i n t er v a l 可以根据你的应用程序的延迟要求以及可用的集群资源情况来设置。 21 Sp a r k St r ea m i n g 编程 ¨ 接下来的流程： 1. 通过创建输入 D St r ea m 来创建输入数据源。 2. 通过对 D St r ea m 定义 t r a n s f or m a t i on 和 ou t p u t 算子操作，来定义实时计算 逻辑。 3. 调用 St r ea m i n g C on t e xt 的 st a r t ( ) 方法，来开始实时处理数据。 4. 调用 St r ea m i n g C on t e xt 的 a w a i t T er m i n a t i on () 方法，来等待应用程序的终 止。可以使用 C T RL + C 手动停止，或者就是让它持续不断的运行进行 计算。 5. 也可以通过调用 St r ea m i n g C on t e xt 的 s t op ( ) 方法，来停止应用程序。 22 Sp a r k St r ea m i n g 编程 ¨ 注意事项： 1. 只要一个 St r ea m i n g C on t e xt 启动之后，就不能再往其中添加任何计算逻辑了。比如执行 st ar t ( ) 方法之后，还给某个 D St r ea m 执行一个算子。 2. 一个 St r ea m i n g C on t e xt 停止之后，是肯定不能够重启的， 调用 s t op ( ) 之后，不能再调用 st ar t ( ) 。 3. 一个 JVM 同时只能有一个 St r ea m i n g C on t e xt 启动，在你的应用程序中，不能创建两个 St r ea m i n g C on t e xt 。 4. 调用 s t op ( ) 方法时，会同时停止内部的 Sp a r k C on t e xt ，如果不希望如此，还希望后面继续使 用 Sp a r k C on t e xt 创建其他类型的 C on t e xt ，比如 SQ L C on t e xt ，那么就用 s t op ( f a l s e) 。 5. 一个 Sp a r k C on t e xt 可以创建多个 St r ea m i n g C on t e xt ，只要上一个先用 s t op ( f a l s e) 停止，再创建 下一个即可。 23 输入源 ¨ 套接字 va l l i n es = s s c . s oc k et T e xt St r ea m ( \" l oc a l h os t \" , 9 9 9 9 ) ¨ 文件流 va l l og D a t a = s s c . t e xt F i l eSt r ea m ( l og D i r ec t or y ) va l data = s s c . f i l eSt r ea m [ K e yC l a s s , V a l u eC l a s s , I n p u t F or m a t C l a s s ] ( d a t a D i r ec t or y ) ¨ 附加数据源 ¤ Ap a c h e Ka f k a ¤ T w i t t er ¤ A m a z on K i n es i s ¤ Ap a c h e Fl um e 24 A p a c h e K a f k a ¨ A p a c h e K a f k a 是一个分布式流处理平台。用于构建实时的数据管 道和流式的 app 。它可以水平扩展，高可用，速度快，并且已经 运行在数千家公司的生产环境。 ¨ 流处理平台的三种特性 ¤ 可以让你发布和订阅流式的记录。这一方面与消息队列或者企业消息 系统类似。 ¤ 可以储存流式的记录，并且有较好的容错性。 ¤ 可以在流式记录产生时就进行处理。 25 A p a c h e K a f k a 26 A p a c h e K a f k a ¨ Ka f k a 维护按类区分的消息，称为主题（ t op i c ） ¨ 生产者（ p r od u c er ）向 Ka f k a 的主题发布消息 ¨ 消费者（ c on s u m er ）向主题注册，并且接收发布到这些主题的消 息 ¨ Ka f k a 以一个拥有一台或多台服务器的集群运行着，每一台服务 器称为 b r ok er ¨ 从高层来说，生产者（ p r od u c er ）通过网络发消息到 Ka f k a 集群， 而 Ka f k a 集群则以下面这种方式对消费者进行服务。 27 A p a c h e K a f k a ¨ 步骤 1. 运行 z ook eep er 服务器 2. 运行 ka f ka 服务器 3. 创建 t op i c 4. 查看 t op i c 是否存在 5. 创建 p r od u c er 6. 创建 c on s u m er （测试） 7. 提交 Sp a r k St r ea m i n g 作业 28 Sp a r k St r ea m i n g + K a f k a 29 Sp a r k St r ea m i n g + K a f k a ¨ Li n k i n g ¤ g r ou p I d = or g . a p a c h e . s p a r k ¤ ar tifactId = s p a r k - s t r ea m i n g - ka f ka - 0 - 1 0 _2 . 1 2 ¤ v er s i on = 3 . 0 . 1 ¨ 编程 ¤ 通过 Ka f k a U t i l s 对象创建出 D s t r ea m ； ¤ 由于 Ka f k a U t i l s 可以订阅多个主题，因此它创建出的 D s t r ea m 由成对的主题和消息组成； ¤ 要创建一个流数据，需要使用 St r ea m i n g C on t e xt 实例，一个由逗号隔开的 Zook eep er 主机列表 字符串、消费者组的名字（唯一名字），以及一个从主题到针对这个主题的接收器线程数 的映射表来调用 c r ea t eSt r ea m () 方法。 30 Sp a r k St r ea m i n g + K a f k a … M a p < St r i n g , I n t eg er > t op i c M a p = n e w Ha s h M a p <>( ) ; St r i n g [ ] t op i c s = args [2]. spl i t(\" , \" ); f or ( St r i n g t op i c : t op i c s ) { t op i c M a p . p u t ( t op i c , n u m T h r ea d s ); } J a v a P a i r R ec ei v er I n p u t D St r ea m < St r i n g , St r i n g > m es s a g es = K a f k a U t i l s . c r ea t eSt r ea m ( js s c , args [0], args [1], t op i c M a p ); J a v a D St r ea m < St r i n g > l i n es = m es s a g es . m a p ( T u p l e2 : : _2 ) ; J a v a D St r ea m < St r i n g > w or d s = l i n es . f l a t M a p ( x - > A r r a ys . a s L i s t ( SP A C E . s p l i t ( x) ) . i t er a t or ( ) ) ; J a v a P a i r D St r ea m < St r i n g , I n t eg er > w or d C ou n t s = w or d s . m a p T oP a i r (s - > n e w T u p l e2 < > ( s , 1)). r ed u c eByK e y ((i 1, i 2) - > i 1 + i 2 ) ; 31 Sp a r k St r ea m i n g + K a f k a ¨ U s a g e: J a v a K a f k a W or d C ou n t < z k Q u or u m > < g r ou p > < t op i c s > < n u m T h r ea d s > ¤ < z k Q u or u m > i s a l i s t of on e or m or e z ook eep er s er v er s t h a t m a k e q u or u m ¤ < g r ou p > i s t h e n a m e of ka f ka c on s u m er g r ou p ¤ < t op i c s > i s a l i s t of on e or m or e ka f ka t op i c s t o c on s u m e f r om ¤ < n u m T h r ea d s > i s t h e n u m b er of t h r ea d s t h e ka f ka c on s u m er s h ou l d u s e ¨ $ b i n /r u n - e xa m p l e or g . a p a c h e . s p a r k . e xa m p l es . s t r ea m i n g . J a v a K a f k a W or d C ou n t z oo0 1 , z oo0 2 , z oo0 3 m y - c on s u m er - g r ou p t op i c 1 , t op i c 2 1 32 批量计算 vs 流式计算 ¨ 批量和流式处理数据粒度不一样，批量每次处理一定大小的数据块（输入一般 采用文件系统），一个 tas k 处理完一个数据块之后，才将处理好的中间数据发 送给下游。流式计算则是以 r ec or d 为单位， tas k 在处理完一条记录之后，立马 发送给下游。 33 批量计算 vs 流式计算 ¨ 区别 ¤ 数据处理单位 n 批量计算按数据块来处理数据，每一个 task 接收一定大小的数据块 n 流式计算的上游算子处理完一条数据后，会立马发送给下游算子，所以一条数据从进入 流式系统到输出结果的时间间隔较短 ¤ 数据源 n 批量计算通常处理的是有限数据（ b ou n d d a t a ），数据源一般采用文件系统，而流式计 算通常处理无限数据（ u n b ou n d d a t a ），一般采用消息队列作为数据源。 ¤ 任务类型 n 批量计算中的每个任务都是短任务，任务在处理完其负责的数据后关闭，而流式计算往 往是长任务，每个 w or k er 一直运行，持续接受数据源传过来的数据。 34 批量计算 vs 流式计算 ¨ 离线 = 批量？实时 = 流式？ ¤ 离线和实时应该指的是：数据处理的延迟；批量和流式指的是：数据 处理的方式。 两者并没有必然的关系。事实上 Sp a r k s t r ea m i n g 就是采 用小批量（ bat c h ）的方式来实现实时计算。 35 流式计算框架 ¨ Apac h e St or m ¨ Apac h e Sp a r k St r ea m i n g ¨ Apac h e Fl i nk 36 流式计算框架 ¨ Apac h e St or m 37 流式计算框架 ¨ Apac h e Sp a r k St r ea m i n g 38 流式计算框架 ¨ Apac h e Fl i nk 39 C om p a r i s on 40 摘要 ¨ Sp a r k St r ea m i n g ¨ Sp a r k St r u c t u r ed St r ea m i n g ¨ Gr a p h X Sp a r k St r u c t u r ed St r ea m i n g 42 Spa r k St r uc t ur e d St r e a m i ng m a ke s i t e a sy t o b u i l d st r e a m i n g a p p l i ca t i o n s a n d p i p e l i n e s w i t h t h e sa m e a n d f a m i l i a r S p a r k A P I s. Sp a r k St r u c t u r ed St r ea m i n g 43 Sp a r k St r ea m i n g v s . St r u c t u r ed St r ea m i n g ¨ Sp a r k St r ea m i n g ¤ Sp a r k St r ea m i n g 是 Sp a r k 最初的流处理框架，使用了微批的形式来进行 流处理。 ¤ 提供了基于 RD D s 的 D s t r ea m A PI ，每个时间间隔内的数据为一个 RD D ， 源源不断对 RD D 进行处理来实现流计算 . ¨ Sp a r k St r u c t u r ed St r ea m i n g ¤ Sp a r k 2 . X 出来的流框架，采用了无界表的概念，流数据相当于往一个 表上不断追加行。 ¤ 基于 Sp a r k SQ L 引擎实现，可以使用大多数 Sp a r k SQ L 的 f u n c t i on 44 区别 ¨ 流模型 ¤ Sp a r k St r ea m i n g 采用微批的处理方法。每一个批处理间隔的为一个批，也就 是一个 RD D ，我们对 RD D 进行操作就可以源源不断的接收、处理数据。 ¤ St r u c t u r ed St r ea m i n g 将实时数据当做被连续追加的表。流上的每一条数据都 类似于将一行新数据添加到表中。 45 每隔 1 秒从输入源 获取数据到 In p u t Ta b l e ， 并触发 Qu e r y 计算，然后 将结果写入 Re s u l t Ta b l e ， 之后根据 指定的 Ou t p u t 模式 进行写出。 区别 ¨ RD D 、 Dat aF r am e 、 D a t a Set ¤ Sp a r k St r ea m i n g 的 D St r ea m 编程接口是 RD D 。 ¤ St r u c t u r ed St r ea m i n g 使用 DataF r am e 、 D a t a Set 的编程接口，处理数据时可以 使用 Sp a r k SQ L 中提供的方法，数据的转换和输出会变得更加简单。 46 区别 ¨ Pr oc es s Ti m e v s . E v en t Ri m e ¤ Pr oc es s T i m e ：流处理引擎接收到数据的时间 ¤ E v en t T i m e ：事件真正发生的时间 ¤ Sp a r k St r ea m i n g 由于其微批的概念，会将一段时间内接收的数据放入一个批 内，进而对数据进行处理。划分批的时间是 Pr oc es s T i m e ，而不是 E v en t T i m e ， Sp a r k St r ea m i n g 没有提供对 E v en t T i m e 的支持。 ¤ St r u c t u r ed St r ea m i n g 提供了基于事件时间处理数据的功能，如果数据包含事 件的时间戳，就可以基于事件时间进行处理。 ¨ St r u c t u r ed St r ea m i n g 的 c on t i n u ou s m od e 是实时处理的，只要一有数 据就会进行处理，时延基本在毫秒级别。 47 区别 48 Sp a r k St r ea m i n g St r u c t u r ed St r ea m i n g 区别 ¨ 可靠性保障 ¤ 两者在可靠性保证方面都是使用了 c h ec k p oi n t 机制。 c h ec k p oi n t 通过设置检查 点，将数据保存到文件系统，在出现故障的时候进行数据恢复。 ¤ 在 Sp a r k St r ea m i n g 中，如果我们需要修改流程序的代码，在修改代码重新提 交任务时，是不能从 c h ec k p oi n t 中恢复数据的（程序就跑不起来），是因为 Sp a r k 不认识修改后的程序了。 ¤ 在 St r u c t u r ed St r ea m i n g 中，对于指定的代码修改操作，是不影响修改后从 c h ec k p oi n t 中恢复数据的。 49 区别 ¨ Si n k ：输出数据写入下游 ¤ Sp a r k St r ea m i n g 中提供了 f or ea c h RD D () 方法，通过自己编程实现将每个批的 数据写出。 stream.foreachRDD ( rdd => { save( rdd ) }) ¤ St r u c t u r ed St r ea m i n g 自身提供了一些 s i n k ( C on s ol e Si n k 、 F i l e Si n k 、 K a f k a Si n k 等 ) ， 只要通过 op t i on 配置就可以使用；对于需要自定义的 Si n k ，提供了 F or ea c h W r i t er 的编程接口，实现相关方法就可以完成。 // console sink val query = res.writeStream.outputMode ( \"append\" ).format( \"console\" ).start() ¨ 总结： St r u c t u r ed St r ea m i n g 有更简洁的 A PI 、更完善的流功能、更 适用于流处理。而 Sp a r k St r ea m i n g 更适用于偏批处理的场景。 50 N ot e ¨ Sp a r k St r ea m i n g 已成为 l eg a c y p r oj ec t ，不再更新，推荐使用 Sp a r k St r u c t u r ed St r ea m i n g 51 摘要 ¨ Sp a r k St r ea m i n g ¨ Sp a r k St r u c t u r ed St r ea m i n g ¨ Gr a p h X Gr aph X 53 Gr a phX i s A p a ch e S p a r k' s A P I f o r g r a p h s a n d g r a p h - p a r a l l e l co m p u t a t i o n . Gr aph X 54 Gr aph X ¨ Gr aph X 是 Sp a r k 中用于图和图并行计算的组件。 ¨ Gr aph X 通过扩展 Sp a r k RD D 引入一个新的图抽象，一个将有效信息 放在顶点和边的有向多重图。 ¨ Gr aph X 公开了一系列基本运算，以及一个优化后的 Pr eg el A PI 的变 形。包括越来越多的图形计算和 b u i l d er 构造器，以简化图形分析任 务。 ¨ 在 Sp a r k 之上提供了一站式解决方案，可以方便且高效地完成图计 算的一整套流水作业。 55 Gr aph X 核心抽象 ¨ 弹性分布式属性图（ R es i l i en t D i s t r i b u t ed Pr op er t y G r a p h ），一种点和边都带属 性的有向多重图。它扩展了 Sp a r k RD D 的抽象，有 Ta b l e 和 Gr aph 两种视图，而 只需要一份物理存储。两种视图都有自己独有的操作符，从而获得了灵活操作 和执行效率。 56 Gr aph X 框架 57 图处理流水线 58 Pr epr o c essi n g Co mp u te Po s t P r o c . < / > < / > < / > XM L Ra w Da t a ET L Slic e Co mp u te Rep ea t Su b g r a p h Pa g e R a n k In i ti al Gr a p h An a l yz e To p User s 图处理流水线 59 图处理流水线 60 两种视图 ¨ 对 Gr aph 视图的所有操作，最终都会转换成其关联的 Ta b l e 视图的 RD D 操作来完成。这样对一个 图的计算，最终在逻辑上，等价于一系列 RD D 的转换过程。因此， Gr aph 最终具备了 RD D 的 3 个 关键特性： Im m ut a b le 、 D i s t r i b u t ed 和 Fa u l t - T ol er a n t ， 其中最关键的是 Im m ut a b le （ 不变性）。逻 辑上，所有图的转换和操作都产生了一个新图；物理上， Gr aph X 会有一定程度的不变顶点和 边的复用优化，对用户透明。 ¨ 两种视图底层共用的物理数据，由 RD D [ V er t e xP a r t i t i on ] 和 RD D [ E d g eP a r t i t i on ] 这两个 RD D 组成。点 和边实际都不是以表 C ol l ec t i on [ t u p l e] 的形式存储的，而是由 V er t e xP a r t i t i on / E d g eP a r t i t i on 在内部 存储一个带索引结构的分片数据块，以加速不同视图下的遍历速度。不变的索引结构在 RD D 转 换过程中是共用的，降低了计算和存储开销。 61 两种视图 62 • Ta b l e 视图将图看成 V e r t e x P r o p e r t y T a b l e 和 E d g e P r o p e r t y T a b l e 等的组合，这些 Ta b l e 继承了 S p a r k R D D 的 API ( fi l te r , ma p 等 ) 。 • Gr a p h 视图上包括 r e ve r se / su b g r a p h / ma p V (E )/ jo in V (E )/ mrT ri p l e t s 等操作。 Gr aph X 编程 ¨ 属性图是一个用户定义顶点和边的有向多重图。 ¨ 有向多重图是一个有向图，它可能有多个平行边共享相同的源顶点 和目标顶点。 ¨ 多重图支持并行边的能力简化了有多重关系的建模场景。每个顶点 是由具有 64 位长度的唯一标识符（ V er t e xI D ）作为主键。 Gr aph X 没 有对顶点添加任何顺序的约束。同样，每条边具有相应的源顶点和 目标顶点的标识符。 ¨ 属性表的参数由顶点（ VD ）和边（ ED ）的类型决定。 63 Gr aph X 编程 64 Gr aph X 的图操作 ¨ 构造图 ¤ 通过 Gr a p h O b j ec t 构造 ¤ 通过 Gr a p h Bu i l d er 构造 65 Gr aph X 的图操作 ¨ G r a p h L oa d er . ed g eL i s t F i l e 提供了一种从磁盘上边的列表载入图的 方式。 66 Gr aph X 的图操作 67 Gr aph X 的图操作 ¨ 属性操作 ¨ 转换操作 ¨ 结构操作 ¨ 关联操作 ¨ 聚合操作 ¨ 缓存操作 68 T a b l e O p er a t or s ¨ T a b l e ( RD D ) op er a t or s a r e i n h er i t ed f r om Sp a r k : 69 map filter groupBy sort union join leftOuterJoin rightOuterJoin reduce count fold reduceByKey groupByKey cogroup cross zip sample take first partitionBy mapWith pipe save ... G r a p h O p er a t or s 70 G r a p h O p er a t or s 71 G r a p h O p er a t or s 72 T r i p l et s J oi n V er t i c es a n d E d g es ¨ T h e tr i p l e ts op er a t or j oi n s v er t i c es a n d ed g es : 73 Tr i p l e t sVe r t i c e s Ed g e s B A C D A B A C B C C D A B A B A C B C C D A BA B 常用图算法 ¨ P a g eR a n k 算法 ¨ 三角形计数算法 ¨ 连接分量算法 74 ¨ Gr aphX 自带 P a g eR a n k 的静态和动态实现，放在 P a g eR a n k 对象中。静态的 P a g eR a n k 运行固定数量的迭代，而动态的 P a g eR a n k 运行直到排名收敛。 P a g eR a n k 算法 75 三角形计数算法 ¨ 计算通过各顶点的三角形数目，从而提供集群的度。 T r i a n g l eC ou n t 要求边的指 向（ srcI d < dstId ），并使用 G r a p h . p a r t i t i on By 分割图形。 76 连接分量算法 ¨ 连接分量算法标出了图中编号最低的顶点所连接的子集。 77 应用场景 ¨ 图谱体检平台 ¨ 多图合并工具 ¨ 能量传播模型 ¨ …… 78 推荐 h t t p s: / / g i t h u b . co m / sr yza / aas TH A NK YO U","libVersion":"0.2.4","langs":""}