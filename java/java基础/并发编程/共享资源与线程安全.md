#### 共享资源

- 资源竞争：正在运行的任务不止有一个时，任何任务都可能**同时对一个共享资源进行读或写**操作
- 守护进程
  - 一个定时运行的进程或线程，它监**控应用程序的执行时间**，如果某个任务或整个应用程序运行时间超过预定阈值，它将执行中止操作。
- 解决资源竞争
  - 第一个访问资源的任务**对资源上锁**，其它任务将无法使用资源直到锁被解除，使用资源的新的任务会再次对资源上锁。即共享资源的访问操作**串行化**，被称为**互斥锁**。
#### 锁

 使用显式lock对象
  - 显式创建加锁解锁
    - `Lock lock = new ReentrantLock();`
    - `lock.lock();`
    - `lock.unlock();`
  - lock语句应该与try-finally配合确保锁一定会被释放
``` java
//尝试获取锁
boolean captured = lock.tryLock();
try {
    System.out.println("tryLock(): " + captured);
} finally {
    if(captured)
        lock.unlock();
}
//有最大时间限制
try {
    captured = lock.tryLock(2, TimeUnit.SECONDS);
} catch(InterruptedException e) {
    throw new RuntimeException(e);
}
try {
    System.out.println(
        "tryLock(2, TimeUnit.SECONDS): " + captured);
} finally {
    if(captured)
        lock.unlock();
}
```
- 更加灵活，可以实现不同种类的锁

- 更高级的锁``ReentrantLock``
  - 如果一个线程已经持有了锁，**它可以再次请求并获得锁而不会被阻塞**。`ReentrantLock` 会维护一个持有锁的计数器来跟踪锁的重入**次数**，线程每请求一次锁，计数器就增加一，每释放一次锁，计数器就减一。当计数器归零时，锁被释放。
#### synchronized
- 一个任务想要执行由synchronized保护的代码断时，编译器会检查所是否可用，如果可用，该任务便会获得锁，执行代码然后释放锁。
- 声明在普通方法上时：锁定的是包含该方法的对象实例
  - 声明在静态方法上：锁定的是该类的**Class对象**。
  - `public synchronized void synchronizedMethod()`
- 如果在对一个**接下来**会被另一个线程**读取**的变量进行写操作或者操作一个可能**刚被**另一个线程**写完**操作的变量，就必须使用同步
- 比如一个变量有自增以及获取值得方法，那这两个方法都应该被synchronized修饰

- 指向防止多个线程同时访问方法中的部分代码，而不是整个方法，要隔离的代码区域就是**临界区**。
``` java
synchronized(this) {
       // 同步代码块
}//参数表示要锁定的对象
```

- 必须先获得被锁定对象的锁才能进入代码块
- 使用临界区主要是为了提升性能，即不锁定不需要锁定但是耗时的部分
- 在其它对象上进行同步
  - 通过传入其他对象作为参数，可以实现在其他对象而不是对象自身上操作锁