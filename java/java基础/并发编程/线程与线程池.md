
### 基本概念

#### 线程

- Java使用Thread管理线程，创建Thread时JVM会在专门保留的内存区域中分配一大块空间。包含许多内容
  - 程序计数器，指示要执行的下一条字节码
  - 支持Java代码执行的栈，包含线程到达当前执行结点**前所调用过的方法的相关信息**以及正在执行的方法的本地变量（基本类型和对象引用）
    - 堆由所有线程共享
  - 本地代码栈
  - 本地线程变量存储
  - 用于控制线程的状态维护变

- 获取机器上的处理器数量`Runtime.getRuntime().availableProcessors();`
  - 通常来说**线程的最佳数目就是可用处理器的数量**
  - 由于超线程只是会大幅加快上下文切换的速度，而并不会增加实际的计算吞吐量。因此设置计算密集型程序时不应该考虑超线程
  - 大部分情况由JVM决定即可

#### 死锁

- 循环等待造成无限循环
- 死锁发生的条件
  - 互斥：任务使用的**至少一项资源不是共享的**（即同一时间只能被一个对象使用，其他对象必须等待）
  - 至少一个任务必须**持有**一项资源，并且**等待**正在被另一个任务持有的资源。
  - 不能从一个任务中夺走一项资源。
  - 会发生循环等待。

#### 线程池

- 线程池类型
  - FixedThreadPool：创建一个**固定大小**的线程池。每提交一个任务就创建一个线程，直到线程达到线程池的最大大小。
    - `ExecutorService executor = Executors.newFixedThreadPool(int nThreads);`
    - 当所有线程都在忙时，新提交的任务不会立即执行，而是会放入线程池的工作队列中等待。
  - CachedThreadPool：创建一个可缓存的线程池。如果线程池长度超过处理需求，可灵活回收空闲线程，若无可回收，则新建线程。（无数目限制，除非超过内存）
    - `ExecutorService executor = Executors.newCachedThreadPool();`
  - SingleThreadExecutor：创建一个单线程的Executor。如果这个线程因异常而结束，会创建一个新线程来继续执行后续的任务。
    - `ExecutorService executor = Executors.newSingleThreadExecutor(); `
  - ScheduledThreadPool：创建一个大小无限制的线程池。支持定时以及周期性执行任务的需求。
``` java
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(int corePoolSize);
scheduler.schedule(Callable <V> callable, long delay, TimeUnit unit);
```
- WorkStealingPool：基于工作窃取的线程池。适用于大量的短任务，使用多个队列减少竞争。(使用双端队列为每个线程维护任务，如果一个线程没有任务会从别的线程“窃取”任务)
  - `ExecutorService executor = Executors.newWorkStealingPool(int parallelism);`

- 基本使用方法
  - `execute(Runnable command)`: 提交不需要返回值的任务。
  - `submit(Runnable task)`: 提交需要返回值的任务，并返回 `Future` 对象。
  - `submit(Callable<T> task)`: 提交有返回值的任务，返回 `Future<T>`。
  - `executor.shutdown();`关闭线程池，仍然会执行完已经提交的任务，但是不接受新任务。

### 具体操作

#### 线程的创建与运行

- 使用线程运行对象的**函数式接口**
```java
class LiftOff implements Runnable {
    protected int countDown = 10; // Default
    private static int taskCount = 0;
    private final int id = taskCount++;
    public LiftOff(int countDown) { this.countDown = countDown; }
    public String status() {
        return "#" + id + "(" + (countDown > 0 ? countDown : "Liftoff!") + "), ";
    }
    public void run() {
        while (countDown-- > 0) {
            System.out.print(status()); 
            Thread.yield(); //后面解释
        }
    }
}

public class BasicThreads {
    public static void main(String[] args) {
        //把任务装进线程里
        Thread t = new Thread(new LiftOff(10));
        t.start();
        System.out.println("Waiting for LiftOff");
    }
}
```
- Runnable的内容就是线程的载荷

- 或者直接为线程添加run方法
```java
ublic class SimpleThread extends Thread {
    private int countDown = 5;  private static int threadCount = 0;
    public SimpleThread() {
        super(Integer.toString(++threadCount));  start();
    }
    public String toString() {
        return "#" + getName() + "(" + countDown + "), ";
    }
    public void run() {
        while (true) { System.out.print(this);  if (--countDown == 0) return; }
    }
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) { new SimpleThread(); }
    }
}
//更简洁的写法
public class MoreBasicThreads {
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++)
            new Thread(new LiftOff(10)).start();
        System.out.println("Waiting for LiftOff");
    }
} 
```

- 使用线程池
```java
//结合线程池
public class CachedThreadPool {
    public static void main(String[] args) {
        ExecutorService exec = Executors.newCachedThreadPool();
        for (int i = 0; i < 5; i++)
            exec.execute(new LiftOff(10));
        exec.shutdown();
    }
}
```

- 睡眠`TimeUnit.MILLISECONDS.sleep(100);`

- 让位`Yield`
  - 向调度程序**提示当前线程愿意放弃其当前对处理器的使用**。(只是一种启发性质的建议)
  - yield会**临时暂停当前线程**，让有**同样优先级**的正在等待的线程有机会执行
  - 若没有正在等待的线程或者所有正在等待的线程的**优先级都较低，则继续运行**
  - yield方法**不保证当前的线程会暂停或者停止**，但是可以保证当前线程在调用yield方法时会放弃CPU

- 线程优先级
  - `Thread.currentThread().setPriority(priority);`
  - 常量`Thread.MIN_PRIORITY Thread.MAX_PRIORITY `
  - **尽量不要做**

- 守护(Daemon)进程
  - 守护程序线程是一种线程，它**不会阻止 JVM 在程序完成**但**线程仍在运行时退出**。
```java
Thread daemon = new Thread(new SimpleDaemons());
daemon.setDaemon(true); // Must call before start()
daemon.start();
```
