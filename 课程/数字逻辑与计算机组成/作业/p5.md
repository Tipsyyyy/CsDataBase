##### 3

- func1：对8位数进行**无符号**扩展到32位
- func2：对8位数进行**有符号**扩展到32位
- 两个函数的差别主要由转化位int类型的时机相关，func1中最终结果才转化为int，因此过程中进行的都是逻辑移动；func2中最开始就转化为了int，因此进行的都是数字移动

| W                                                   |      | func1(W)                                            |      | func2(W)                                            |      |
| --------------------------------------------------- | ---- | --------------------------------------------------- | ---- | --------------------------------------------------- | ---- |
| 机器数                                              | 值   | 机器数                                              | 值   | 机器数                                              | 值   |
| 0000 0000<br>0000 0000<br>0000 0000<br>0111 1111    | 127  | 0000 0000<br/>0000 0000<br/>0000 0000<br/>0111 1111 | 127  | 0000 0000<br/>0000 0000<br/>0000 0000<br/>0111 1111 | 127  |
| 0000 0000<br/>0000 0000<br/>0000 0000<br/>1000 0000 | 128  | 0000 0000<br/>0000 0000<br/>0000 0000<br/>1000 0000 | 128  | 1111 1111<br/>1111 1111<br/>1111 1111<br/>1000 0000 | -128 |
| 0000 0000<br/>0000 0000<br/>0000 0000<br/>1111 1111 | 255  | 0000 0000<br/>0000 0000<br/>0000 0000<br/>1111 1111 | 255  | 1111 1111<br/>1111 1111<br/>1111 1111<br/>1111 1111 | -1   |
| 0000 0000<br/>0000 0000<br/>0000 0001<br/>0000 0000 | 256  | 0000 0000<br/>0000 0000<br/>0000 0000<br/>0000 0000 | 0    | 0000 0000<br/>0000 0000<br/>0000 0000<br/>0000 0000 | 0    |

##### 4

| 模式       | x      |      | y      |      |
| ---------- | ------ | ---- | ------ | ---- |
|            | 机器数 | 值   | 机器数 | 值   |
| 无符号数   | 110    | 6    | 010    | 2    |
| 二进制补码 | 110    | -2   | 010    | 2    |
| 无符号数   | 001    | 1    | 111    | 7    |
| 二进制补码 | 001    | 1    | 111    | -1   |
| 无符号数   | 111    | 7    | 111    | 7    |
| 二进制补码 | 111    | -1   | 111    | -1   |

| x*y(截断前) |      | x*y(截断后) |      |
| ----------- | ---- | ----------- | ---- |
| 机器数      | 值   | 机器数      | 值   |
| 001100      | 12   | 100         | 4    |
| 111100      | -4   | 100         | -4   |
| 000111      | 7    | 111         | 7    |
| 111111      | -1   | 111         | -1   |
| 110001      | 49   | 001         | 1    |
| 000001      | 1    | 001         | 1    |

##### 5

- 对optarith的代码进行分析
  - $x<<4 -x$等价于$x*16-x$即$x*15$
  - `if(y<0)y+=3`是为了保证负数也能向零舍入而进行的纠偏
  - $y>>2$等价于$y/4$
- 由此：
  - $M=15$
  - $N=4$

##### 6

- 串行进位
  - $C_1=(C_0\cdot A_1)+(C_0\cdot B_1)+(A_1\cdot B_1)$
  - $C_2=(C_1\cdot A_2)+(C_1\cdot B_2)+(A_2\cdot B_2)$
  - $C_3=(C_2\cdot A_3)+(C_2\cdot B_3)+(A_3\cdot B_3)$
  - $C_4=(C_3\cdot A_4)+(C_3\cdot B_4)+(A_4\cdot B_4)$
- 并行进位
  - $G_i=A_iB_i$
  - $P_i=A_i+B_i$
  - $C_i=G_i+P_iC_{i-1}$
  - $C_1=G_1+P_1C_0$
  - $C_2=G_2+P_2C_1=G_2+P_2G_1+P_2P_1C_0$
  - $C_3=G_3+P_3C_2=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1C_0$
  - $C_4=G_4+P_4C_3=G_4+P_4G_3+P_4P_3G_2+P_4P_3P_2G_1+P_4P_3P_2P_1C_0$

##### 7

1. 

   - $[x+y]_补=0101+1101=0010=2$（未发生溢出）
   - $[x-y]_补=0101+0011=1000=-8$（发生溢出）

2. 

   - $X=0:101 \ Y=1:101$

   - 首先计算符号位$0\oplus1=1$

   - ```assembly
     x=101 y=101
     C P   Y
     0 000 101+101
     0 101 101->
     0 010 110->
     0 001 011+101
     0 110 011->
     0 011 001
     ```

   - 得到结果$1:011001=-25$

   - 截断后为$1:001=-1$发生溢出

3. 

   - ```assembly
     x=0101 y=1101 -x=1011
     P    Y    y-1
     0000 1101 0-x
     1011 1101 0->
     1101 1110 1+x
     0010 1110 1->
     0001 0111 0-x
     1100 0111 0->
     1110 0011 1->
     1111 0001 1
     ```

   - 得到结果$11110001=-15$

   - 截断后为$0001=1$发生溢出

4. 

   - $X=0:101 \ Y=1:101$

   - 商的符号位：$0\oplus 1=1$

   - 余数的符号位：$0$

   - ```assembly
     x=0101 y=0101 -y=1011
     R    Q
     0000 0101-y
     1011 0101<-
     0110 1010+y
     1011 1010<-
     0111 0100+y
     1100 0100<-
     1000 1000+y
     1101 1000<-
     1011 0000+y
     0000 0000<-
     0000 0001
     ```

   - 得到结果$商=-0001=-1 \  余数=000=0$（未发生溢出）

5. 

   - ```assembly
     x=0101 y=1101 -y=0011
     R    Q   
     0000 0101+y
     1101 0101<-
     1010 1011-y
     1101 1011<-
     1011 0111-y
     1110 0111<-
     1100 1111-y
     1111 1111<-
     1111 1111-y
     0010 1111<-
     0101 1110
     由于xy符号相反，商末尾加以即1111
     余数010与x符号相同无需修正
     ```

   - 得到结果$商=1111=-1 \  余数=010=2$（未发生溢出）
