##### 2（4）

- 操作数在寄存器：立即数；寄存器直接。
- 操作数在存储器：直接；间接；寄存器间接；偏移；栈。

##### 2（9）

- 区别：
  - 转移指令永远改变程序的执行顺序，跳转时不会保存当前地址作为返回地址。
  - 过程调用则是为了调用一个程序，会保存当前地址作为返回地址，程序结束后会返回调用之前保存的地址继续执行。
- 返回指令是否需要地址码：
  - 不一定：如果返回地址保存在栈中，程序不需要地址吗参数就能从栈中获取返回地址；但是如果不知道返回地址存储的位置或者没有存储返回地址，就需要附件地址码字进行返回操作。

##### 3

- $220-(258+2)=-40$这就是第二个字节的内容
- 转化为补码表示
  - $40=00101000$
  - $-40=11011000=D8$

##### 6

- 由于单个操作数的长度为6位，那么二地址指令的操作码为$16-2*6=4$位；单地址操作码为$16-6=10$位；零地址为$16$位。
- 前$4$位最多$2^4=16$种，除去二地址剩余$16-k_2$，即单地址最大可选数目为$(16-k_2)2^6$
- 零地址操作占用中间六位的数目$\lceil k_0/2^6\rceil$
- 故单地址指令数目最大为$(16-k_2)2^6-\lceil k_0/2^6\rceil$

##### 7

- 分析

  - 由于要支持64种指令，因此opcode的长度应该**为6位**

  - 由于每种操作还需要支持**4种读取方式**，并且有两个操作数，因此需要额外的4位标识类型
    - 不妨令IRSX分别对应：00 01 10 11

  - 由于寄存器有8个，因此应该使**用3位**表示**寄存器**

  - **立即数和地址**都是**用16位**表示

- RR：`OP(6)|0101|R1(3)|R2(3)`
  - 存储器访问次数：取指令1+执行0=1
- RI：`OP(6)|0100|R1(3)|000|Imm(16)`
  - 存储器访问次数：取指令2+执行0=2
- RS：`OP(6)|0110|R1(3)|R2(3)`
  - 存储器访问次数：取指令1+执行1=2
- RX：`OP(6)|0111|R1(3)|R2(3)|offset(16)`
  - 存储器访问次数：取指令2+执行1=3
- XI：`OP(6)|1100|R1(3)|000|offset(16)|Imm(16)`
  - 存储器访问次数：取指令3+执行2=5
- SI：`OP(6)|1000|R1(3)|000|Imm(16)`
  - 存储器访问次数：取指令2+执行2=4
- SS：`OP(6)|1010|R1(3)|R2(3)`
  - 存储器访问次数： 取指令1+执行3=4

##### 8

1. 

   - OP有4位，因此最多可以有$2^4=16$条指令

   - 由于使用3位表示寄存器，因此最多8个

   - 主存空间128KB即$2^{17}$字，即需要用17位表示地址，即MAR应该有17位
   - 字长为16位，因此MDR为16位

2. 

   - 由于计算机的字长为16位，那么寄存器的大小也为16位，用补码存储时的数据范围为$-2^{15}\to2^{15}-1$
   - 故转移指令的地址范围为$PC-2^{15}\to PC+2^{15}-1$

3. 

   - 机器码：`0010 001 100 010 101`
   - 寄存器R5发生自增，改变后的内容为5679H
   - 寄存器R5自增之后作为目的操作数，即地址5679H发生变化，存储结果$1234H+5678H=68acH$

##### 10

- 这里加offset[11]主要是为了抵消后面对offset[11:0]进行位扩展造成的影响
- 如果offset[11]=0，则不会产生任何影响
- 如果offset[11]=1，则jalr中扩展后的高20位均为1，加上第一次的1正好全部变成零，从而抵消了符号扩展造成的影响，使得x1==offset

##### 11

- ```assembly
  add t1, t0, t0
  add t0, t0, t1
  add t1, t1, t1
  add t0, t0, t1
  ```

##### 13

- ```assembly
         add  t0, zero, zero   //将t0初始化为0
  loop:  beq  a1, zero, finish //如果a1==0就跳转到finish
  	   add  t0, t0, a0       //t0=t0+a0
  	   addi a1, a1, -1       //a1=a1-1
  	   j    loop			 //回到loop标签位置继续执行
  finish:addi t0, t0, 100		 //t0=t0+100
   	   add  a0, t0, zero     //a0=t0
  ```

- 功能：计算`a=a*b+100`

##### 15

- b=21&a

  - ```assembly
    andi t1, t0, 31
    ```

- b=65535&a

  - 由于RV32I中立即数长度为12，因此不能直接使用andi计算

  - 65535=1111 111111111111即拆分为15和4095

  - ```assembly
    lui t3, 15
    addi t3, t3, 4095
    and t1, t1, t3
    ```

##### 17

- 由于立即数只有12位，因此能跳转的范围尽在当前PC的附近，是很受限的，如果there地址距离here较远，就无法进行跳转

- ```assembly
  here:beq, t0, t2, jmp
  jmp: jal, x0, there
     ......
  there:...
  ```

  - 由于jal接受20位立即数，可跳转的范围要大的多，可以考虑使用