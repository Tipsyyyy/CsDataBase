## 非流水线CPU

### 中央处理器概述

- CPU执行一条指令的过程
  - 取指令
  - PC+“1”送PC
  - 指令译码
  - 进行主存地址运算
  - 取操作数
  - 进行算术 / 逻辑运算
  - 存结果

- CPU 由 执行部件（**数据通路**） 和 **控制部件**（控制器）组成
  - 执行部件：操作元件（ALU）、状态存储元件
  - 控制部件：译码部件、控制信号生成部件、状态存储元件
    - 控制器负责对执行部件（数据通路）发出控制信号

#### 数据通路基本结构

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231212224759534.png" alt="image-20231212224759534" style="zoom:33%;" />
- 数据通路由**操作元件**（组合原逻辑元件, 如加法器、多路选择器、译码器等）和**存储元件**（时序逻辑元件）通过总线或分散方式连接而成的进行数据存储处理和传送的路径、

- 存储元件
  - 寄存器（组）
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231212230811294.png" alt="image-20231212230811294" style="zoom:33%;" />
    - 两个读口（**组合逻辑**操作）：busA和busB分别由RA和RB给出地址。地址RA或RB有效后，经一个“取数时间(AccessTime)”，busA和busB有效。
    - 一个写口（**时序逻辑**操作）：写使能为1的情况下，时钟边沿到来时，busW 传来的值开始被写入 RW 指定的寄存器中。
  - 理想寄存器
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231212231059218.png" alt="image-20231212231059218" style="zoom:33%;" />
    - 为简化数据通路操作说明，把存储器简化为带时钟信号Clk的理想模型。并非真实存在于CPU中！
    - 读操作（组合逻辑操作）：地址Address有效后，经一个“取数时间AccessTime”，Data Out上数据有效。
    - 写操作（时序逻辑操作） ：写使能为1的情况下，时钟Clk边沿到来时，Data In传来的值开始被写入Address指定的存储单元中。

#### CPU的性能评估

- 时钟周期：Cycle Time = Latch Prop + Longest Delay Path + Setup + Clock Skew
  - 约束条件：(Latch Prop + Shortest Delay Path - Clock Skew)  >  Hold Time
  - **Latch Propagation Delay**: 从锁存器捕获数据到数据**稳定输出**所需要的时间。
  - **Longest Delay Path**: 在触发器或锁存器输出数据后，数据在电路中传输所遇到的**最长延迟**。
  - **Setup Time**: 下一个触发器或锁存器在时钟沿到来之前，数据必须稳定的时间。
  - **Clock Skew**: 时钟在分布到不同触发器或锁存器时的最大时间差异。

- 性能的衡量
  - 响应时间/时延
  - 吞吐率、带宽

- CPI
  - CPU 执行时间=CPU 时钟周期数/程序\*时钟周期=指令条数/程序\***CPI**\*时钟周期
  - 对于某一条特定的指令而言，其CPI是一个确定值——与CPU设计有关。
  - 但是，对于某一个程序或一台机器而言，其CPI是一个平均值，表示该程序或该机器指令集中的1条指令执行时**平均**需要多少时钟周期。
  - 平均CPI的计算：
    - $CPI_i$表示第$i$类指令的$CPI$，$C_i$表示该指令的指令条数
    - 总时钟数$\sum^n_{i=1}CPI_i\cdot C_i$
    - CPU时间就是 时钟周期乘以总时钟数
    - 综合$CPI=总时间周期数/指令条数$
    - 用$F_i$表示指令出现得概率，$CPI=\sum^n_{i=1}CPI_i\cdot F_i$

- 指令数目、CPI、时钟周期
  - 指令数目由编译器和ISA决定 
  - CPI由ISA和CPU的实现来决定
  - 时钟周期由CPU的实现来决定

- **产品宣称指标**（每秒运算次数）
  - $MIPS= Clock Rate / CPI *x* 1/10^6$
    - 表示定点指令的执行速度
  - $MFLOPS   = FP Operations / Second *x* 1/10^6$
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231212234746745.png" alt="image-20231212234746745" style="zoom:33%;" />
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231212234845212.png" alt="image-20231212234845212" style="zoom:33%;" />
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231212234923625.png" alt="image-20231212234923625" style="zoom:33%;" />
  - **算术平均**：求和后除n
    - 根据算术平均执行时间能得到**总平均执行时间**
  - **几何平均**：求积后开根号n
    - 根据几何平均执行时间不能得到程序总的执行时间

  - 执行时间的规格化（测试机器相对于参考机器的性能）：参考机器上执行时间÷ 待测机器上执行时间
    - 对于同一个机器上跑的多个程序应该使用几何平均
    - 如：程序1  从2秒变成1秒  ， 程序2  从2000秒变成1000秒
      - 算术平均提升 = (1+1000)/2=500.5(1+1000)/2=500.5 秒
      - 这个结果看起来像是一个巨大的性能差异，但实际上每个程序的性能提升都是100%。算术平均没有考虑到每个程序性能提升的相对比例。
      - 几何平均提升 = 1×1000=31.621×1000=31.62 秒
      - 这个结果更好地反映了每个程序相对于其自身的性能提升。几何平均通过考虑每个比率的相对大小，提供了一个更准确和公平的性能提升衡量方式。

### 单周期数据通路的设计

#### RISC-V指令格式

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213005255595.png" alt="image-20231213005255595" style="zoom:33%;" />
  - 寄存器有32个32位寄存器（0号始终为0），寄存器编号占5位
  - 存储器只能通过load及store指令访问
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213005508087.png" alt="image-20231213005508087" style="zoom:33%;" />
  - **每条指令的第一步都是取指令并PC加4，使PC指向下条指令**
  - 注意内存对齐，RESIC-V中的地址都是偶数，因此**关于PC的地址对立即数乘以2**
    - **数据不要求**按边界对齐，执行到一条不按边界对齐的访存指令时，硬件抛出异常，由软件进行处理
- 由此分析数据通路需要的组件：
  - 立即数扩展器
  - ALU
  - 取指令部件
  - 完整数据通路

#### 扩展器部件

- 根据指令格式对指令中的**立即数进行拼接和扩展**，形成32位立即数
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213010712530.png" alt="image-20231213010712530" style="zoom:33%;" />
  - ExtOp：控制选择和输入指令相匹配的立即操作数输出
    - **通过指令译码器得到**
  - assign immI = {20{Instr\[31]}, Instr\[31:20]};
  - assign immU = {Instr\[31:12], 12'b0};
  - assign immS = {20{Instr\[31]}, Instr\[31:25], Instr\[11:7]};
  - ssign immB = {20{Instr\[31]}, Instr\[7], Instr\[30:25], Instr\[11:8], 1'b0};
  - assign immJ = {12{Instr\[31]}, Instr\[19:12], Instr\[20], Instr\[30:21], 1'b0};

#### 算数逻辑部件

- 使用**OPctr**和一些标志位（如符号标志位，减法标志位）来表示运算的类型
- 由指令得到ALUctr，再进一步解析得到OPctr和标志位
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213011259166.png" style="zoom:33%;" />
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213011335362.png" alt="image-20231213011335362" style="zoom:33%;" />

#### 取指令部件

- 每条指令的公共指令
  - 取指令： M\[PC]
  - 更新PC：PC ← PC + 4 
- **先取指令，再改PC的值**
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213011848543.png" alt="image-20231213011848543" style="zoom:33%;" />

#### 数据通路

- R-型指令的数据通路
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213103350394.png" alt="image-20231213103350394" style="zoom: 50%;" />
- I-型运算指令ori的数据通路
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213103530713.png" style="zoom: 50%;" />
- U-型指令的数据通路
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213103757884.png" alt="image-20231213103757884" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213103850252.png" alt="image-20231213103850252" style="zoom:50%;" />
- Load指令的数据通路
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213103917668.png" alt="image-20231213103917668" style="zoom:50%;" />
- Store指令的数据通路
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213103929543.png" alt="image-20231213103929543" style="zoom:50%;" />
- B-型指令的数据通路
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213104515994.png" alt="image-20231213104515994" style="zoom:50%;" />
  - 下地址逻辑
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213104859158.png" alt="image-20231213104859158" style="zoom:50%;" />
- J-型指令的数据通路
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213104911869.png" alt="image-20231213104911869" style="zoom: 50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213105150643.png" alt="image-20231213105150643" style="zoom:50%;" />
- 完整数据通路
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213104932986.png" alt="image-20231213104932986" style="zoom:50%;" />

### 单周期控制器的设计

#### 控制通路

- 所有指令开始时的动作：**取指令**: Instruction ← M\[PC]
- R指令的操作流程
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213110022410.png" alt="image-20231213110022410" style="zoom: 50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213110042313.png" alt="image-20231213110042313" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213110124357.png" alt="image-20231213110124357" style="zoom:33%;" />
- I指令操作过程
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213110505331.png" alt="image-20231213110505331" style="zoom:50%;" />
- U型指令
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213110546109.png" alt="image-20231213110546109" style="zoom:50%;" />
- Load
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213110700580.png" alt="image-20231213110700580" style="zoom:50%;" />
- Save
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213110710231.png" alt="image-20231213110710231" style="zoom:50%;" />
- B指令
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213110840453.png" alt="image-20231213110840453" style="zoom:50%;" />

- J指令
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213111125933.png" alt="image-20231213111125933" style="zoom:50%;" />

- lw指令的执行时间最长, 它所花时间作为时钟周期
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231213111900026.png" alt="image-20231213111900026" style="zoom:50%;" />
- 单周期处理器的CPI为**1**，但是由于**以最复杂的指令的执行时间作为时钟周期**，频率比较低（很多指令本来可以以更短的时间完成，这造成了浪费）

### 多周期处理器的设计

- 单周期与多周期的比较
  - 成本比较
    - 单周期下功能部件不能重复使用；而**多周期下可重复使用**，比单周期省
    - 单周期指令执行结果直接保存在PC、Regfile和Memory；而**多周期下需加一些临时寄存器**保存中间结果，比单周期费
  - 性能比较
    - 单周期CPU的CPI为1，但时钟周期为最长的load指令执行时间
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216220323498.png" alt="image-20231216220323498" style="zoom:50%;" />
    - 要注意：多周期的性能**不一定比单周期好**！关键就在于划分阶段**是否均匀**。

- 把指令的执行**分成多个阶段**，每个阶段在一个时钟周期内完成
  - 时钟周期以**最复杂阶段**所花时间为准
  - 尽量分成**大致相等的若干阶段**
  - 规定每个阶段最多只**能完成1次访存 或 寄存器堆读/写 或 ALU运算**
- 优点
  - 时钟周期短（不同指令所用周期数可以不同）
  - 允许功能部件在一条指令执行过程中被重复使用
- 指令执行阶段划分（前两个阶段所有指令固定相同）
  - 取指令阶段
    - 执行一次存储器读操作
    - 读出的内容（指令）保存到**寄存器IR**（指令寄存器）中
    - IR的内容不是每个时钟都更新，所以IR必须加一个“**写使能”控制**
    - 在取指令阶段结束时，ALU的输出为PC+4，并送到PC的输入端，但不能在每个时钟到来时就更新PC，所以PC也要有“**写使能”控制**
  - 译码/读寄存器堆阶段
    - 经过控制逻辑延迟后，**控制信号更新**为新值
    - 执行一次寄存器读操作，并同时进行译码
    - 期间ALU空闲，可以考虑“投机计算”地址
  - ALU运算阶段
    - ALU运算，输出结果一定要在下个时钟到达之前稳定
  - 读存储器阶段
    - 由ALU运算结果作为地址访问存储器，读出数据
  - 写结果到寄存器
    - 把之前的运算结果或读存储器结果写到寄存器堆中
- *多周期处理器的设计
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216203324935.png" alt="image-20231216203324935" style="zoom:33%;" />

#### 各类指令执行过程分析

- （公共操作）取指令并计算下条指令地址（IFetch）

  - 根据PC**读指令**并**保存到IR**，**PC+4**
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216203659123.png" alt="image-20231216203659123" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216203814529.png" alt="image-20231216203814529" style="zoom: 50%;" />

- （公共操作）译码并取数（Rfetch/ID）

  - IR的OP及CC送控制器译码，并根据Rs和Rt读取寄存器中数据
  - 加法器空闲，投机计算主存地址（但是只会在对主存操作时才用的上）
    - 若译码发现是Load/Store指令则投机成功，使得Load/Store指令减少一个时钟周期；若不是，则只要保证MAR不送总线即可（MARout=0）
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216204252691.png" alt="image-20231216204252691" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216204304046.png" alt="image-20231216204304046" style="zoom:50%;" />

- R型指令

  - R-型指令的执行，需要**两个时钟周期**，记为 RExec、RFinish状态
    - 进行ALU运算并将结果存入ALUout
    - 将相应结果分别写入Rt和CC寄存器
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216205145500.png" alt="image-20231216205145500" style="zoom:50%;" />

  - 为什么要拆分为两个阶段并且使用ALUout寄存器
    - 如果两个周期合并，可能**来不及把异常结果转去进行异常处理**，就可能把错误结果写入寄存器了

- I型指令

  - I-型运算指令的执行，需要两个时钟周期，记为 IExec、IFinish状态
  - 与R型类似，进行ALU运算并将结果存入ALUout，再将相应结果分别写入Rt和CC寄存器。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216205646464.png" alt="image-20231216205646464" style="zoom:50%;" />

- Load指令

  - **地址已投机计算**，还需两个时钟周期，记为 lwExec、lwFinish状态
    - 根据投机计算好的地址（MAR中）到主存中取数，送MDR
    - 将MDR内容写入Rt。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216205933792.png" alt="image-20231216205933792" style="zoom:50%;" />
  - 两个阶段可以合并，但是会导致时钟周期变长

- Store指令

  - 地址已投机计算，还需两个时钟周期，记为 swExec、swFinish状态
    - 将Rt的内容写入MDR
    - 将MDR的内容写入投机计算好的主存单元中（地址在MAR中）。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216210302794.png" alt="image-20231216210302794" style="zoom:50%;" />

- Jump指令

  - 计算转移目标地址（PC+SEXT（imm6））并送PC，需一个时钟周期，记为 JFinish状态
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216210514213.png" alt="image-20231216210514213" style="zoom:50%;" />

- 时序图

  - 状态元件内容和控制信号取值的改变（蓝色线）：在时钟到来后的一定**延时后发生**
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216210849074.png" alt="image-20231216210849074" style="zoom:50%;" />

#### 多周期控制器

- 本质上一个阶段对应的就是一组控制信号

- 状态转化图
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216211132211.png" alt="image-20231216211132211" style="zoom:50%;" />
- 单周期CPU中，控制信号在整个指令执行过程中不变，用真值表能反映指令和控制信号的关系。根据真值表就能实现控制器！但是多周期中不同阶段的控制信号不是固定的。
- 多周期控制器功能描述方式：
  - 有限状态机：用硬连线路(PLA)实现
  - 微程序：用ROM存放微程序实现

##### 有限状态机PLA实现

- 由时钟、当前状态和操作码确定下一状态。不同状态输出不同控制信号值
  - 状态转换图中，共10个状态，分别为0~9，故状态寄存器至少需4位
  - 下一状态是当前状态和操作码的函数。每来一个时钟，当前状态变到下一个状态
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216211751280.png" alt="image-20231216211751280" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216211803499.png" alt="image-20231216211803499" style="zoom:50%;" />
- 硬布线方式实现
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216211916664.png" alt="image-20231216211916664" style="zoom:50%;" />
  - 优点：速度快，适合于简单或规整的指令系统
  - 缺点：它是一个多输入/多输出的巨大逻辑网络。对于复杂指令系统来说，结构庞杂，实现困难；修改、维护不易；灵活性差。甚至无法用有限状态机描述！

##### 微程序实现

- 思想：仿照程序设计的方法，编制**每个指令**对应的**微程序**
  - 每个**微程序由若干条微指令构成**，分别和各状态对应
  - **每条微指令**包**含若干条微命令**，分别和状态中的**控制信号对应**
  - 所有微程序放在**只读存储器中**（称为控制存储器Control  Storage，简称控存CS  ），都是0/1序列
- 特点：具有规整性、可维性和灵活性，但速度慢。
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216212722468.png" alt="image-20231216212722468" style="zoom:33%;" />
- 机器指令的执行过程
  - 从CS中**取出**对应**微程序**
  - 执行微程序，就是**执行其中的各条微指令**
    - 对微指令译码就是产生对应的**微命令**——**控制信号**
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216213251185.png" alt="image-20231216213251185" style="zoom:50%;" />
- 微指令格式的设计
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216213628919.png" alt="image-20231216213628919" style="zoom:25%;" />
  - µOP: 微操作码字段，产生微命令（控制信号） ； 
  - µAddr（配合常数）：微地址码字段，产生下条微指令地址。
  - 编码方式
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216213729833.png" alt="image-20231216213729833" style="zoom:33%;" />、
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216213906912.png" alt="image-20231216213906912" style="zoom:33%;" />
- 下条微地址的确定方式
  - 微指令**地址的产生方法**有两种
    - 增量(计数器)法：下条微指令地址隐含在微程序**计数器μPC中**。
    - 断定(下址字段)法：**在本条微指令中明显指定**下条微指令地址。
  - 选择**下条要执行的微指令**有以下四种情况
    - 取指微程序首址：每条指令执行前，CPU先执行取指微程序。
    - 第一条微指令：每条指令取出后，必须转移到该指令对应的第一条微指令执行。
    - 顺序执行时：微程序执行过程中顺序取出下条微指令执行。
    - 分支执行时：在遇到按条件转移到不同微指令执行时，需要根据控制单元的输入来选择下条微指令。

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216214407432.png" alt="image-20231216214407432" style="zoom:33%;" />

#### 多周期中的异常处理机制

- 异常基本处理
  - 关中断
  - 保护断点和程序流程
  - 识别异常事件
- 软件识别异常事件（RISC-V、MIPS等采用）
  - 设置**一个异常原因寄存器**（如RISC-V和MIPS中的Cause寄存器），用于记录异常原因。操作系统**使用一个统一的异常处理程序**，该程序按优先级顺序**查询异常状态寄存器**，识别出异常事件。
- 硬件识别：每个异常和中断都有一个异常/中断号，根据此号，到中断向量表（中断描述符表）中读取对应的具体的中断服务程序的入口地址。（特定程序处理特定异常）

##### 带异常处理的多周期数据通路设计

- 寄存器

  - EPC：32位，用于**存放断点**（异常处理后返回到的指令的地址）。

  - Cause：32位（有些位还没有用到），记录**异常原因**。
    - 常见异常原因：未定义指令（Cause=1）、溢出（Cause=2） 

- “写使能”控制信号
  - EPCWr：在**保存断点**时该信号有效，使断点PC写入EPC。
  - CauseWr：在处理器发现异常（如：非法指令、溢出）时，该信号有效，**使异常类型被写到Cause寄存器。**
    - 需要一个控制信号CauseMUX来选择正确的值写入到Cause中
    - 需要将**异常查询程序的入口地址**（假设为0x10000）写入PC，可以在PC输入端增加一个MUX（控制信号PCMUX），其中一个输入为0x10000
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216215640165.png" alt="image-20231216215640165" style="zoom:50%;" />
  - 假设只要处理两种故障类异常：未定义指令（Cause=1）、溢出（Cause=2） 
  - 故障类异常的断点为：PC减4。因为状态0（IFetch）时，已执行PC加4
  - Cause寄存器的两个输入端，分别是 1（未定义指令时）和 2（溢出时）
  - PC中将设置**异常处理程序的首地址**（假设为0x10000）
  - 若发生异常，则Add1MUX=0， Add2MUX=10，EPCWr=1, CauseWr=1, PCMUX=0, PCWr=1，其他写使能信号都为0，
  - 发生未定义指令时CauseMUX=0，发生溢出时CauseMUX=1。

- 带异常处理的控制器设计
  - 在有限状态机中增加异常处理的状态，**每种异常占一个状态**
  - 每个异常处理状态中，需考虑以下基本控制
    - Cause寄存器的设置
    - 计算断点处的PC值（PC-4），并送EPC
    - 将异常查询程序的入口地址送PC
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216220010189.png" style="zoom:50%;" />
  - 如何**检测**是否发生了这两种异常？
    - 未定义指令（非法操作码）：当指令译码器发现**op字段是一个未定义的编码时**
    - 溢出：当R-型或I-型**运算类指令在ALU中执行后**，在条件码寄存器CC中的标志O为1时
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216220129934.png" alt="image-20231216220129934" style="zoom:33%;" />

## 流水线CPU

### 流水线处理器设计

- 指令的阶段划分
  - Ifetch (取指) : 取指令并计算PC+4 
    - 指令存储器、Adder
  - Reg/Dec (取数和译码) : 取数同时译码
    - 寄存器堆读口、指令译码器
  - Exec (执行) : 计算内存单元地址 
    - 扩展器、ALU
  - Mem (读/写存储器) : 从数据存储器中读写
    - 数据存储器
  - Wr(写寄存器): 将数据写到寄存器中 
    - 寄存器堆写口
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231221220609182.png" style="zoom:33%;" />
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231221220747428.png" alt="image-20231221220747428" style="zoom:33%;" />
  - 每个周期有五个功能部件同时在工作
  - 后面指令在前面完成取指后马上开始，吞吐率提高许多，理想情况下：每个周期有一条指令**进入**流水线，有一条指令完成，即CPI为1

#### 流水线指令集的设计

- 对指令集的**特征**要求：**规整、简单和一致**
  - **指令长度尽量一致**，有利于简化取指令和指令译码操作
  - 格式少，且源**寄存器位置相同**，有利于在指令未知时就可取操作数
  - load / Store指令才能访存，有利于减少操作步骤，规整流水线
  - 内存中”对齐”存放，有利于减少访存次数和流水线的规整
- Load 
  - ifetch、Reg/Dec、Exec、Mem、Wr
- R-type`add  rd, rs1, rs2`
  - Ifetch:   **取指令**并计算PC+4（写入PC）
  - Reg/Dec:  从寄存器（rs1和rs2）**取数**，同时指令在译码器进行译码
  - Exec:   在ALU中对操作数进行**计算**
  - Mem：Nop（填充空指令）
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231221231359031.png" alt="image-20231221231359031" style="zoom:33%;" />
    - 如果不使用控制零作为占位，虽然指令执行更快，但是可能出现资源冲突（两条指令试图同时写寄存器）
    - 一个功能部件被多条指令同时使用称为**结构冒险**
    - 因此要填充指令为相同阶段数目，并且保证**每个功能部件每条指令只能用一次**、**每个功能部件必须在相同的阶段被使用**
    - 把所有指令**都按照**最复杂的“load”指令所需**的五个阶段来划分**，不需要的阶段加一个“NOP”操作
  - Wr:   ALU计算的结果**写到**寄存器（rd）
- Store`sw rs2, rs1(imm12)`
  - Ifetch：取指令并计算PC+4 （写入PC）
  - Reg/Dec： 从寄存器（rs1）取数，同时指令在译码器进行译码
  - Exec：12位立即数（imm12）符号扩展后与寄存器值（ rs1 ）相加，**计算主存地址**
  - Mem：将寄存器（rs2）读出的数据写到主存
  - Wr:  Nop
-  I-type`ori rd, rs1,imm12`
  - Ifetch：取指令并计算PC+4 （写入PC）
  - Reg/Dec： 从寄存器（rs1）取数，同时指令在译码器进行译码
  - Exec：使用ALU完成12位立即数（imm12）符号扩展后与寄存器值（ rs1 ）的**运算**（or）
  - Mem：Nop
  - Wr:  ALU计算的结果写到寄存器（rd）
-  U-type`lui rd, imm20`
  - Ifetch：取指令并计算PC+4 （写入PC）
  - Reg/Dec： 指令在译码器进行译码
  - Exec：将20位立即数（imm20）末尾补0后形成32位数据直接送到ALU输出端
  - Mem：Nop
  - Wr:  ALU输出端的结果写到寄存器（rd）
- Beq`beq  rs1, rs2, imm12`
  - Ifetch: 取指令并计算PC+4 （写入PC，但后续可能需要修改PC）
  - Reg/Dec:从寄存器（rs1，rs2）取数，同时指令在译码器进行译码
  - Exec:  执行阶段，ALU中**比较**两个寄存器（rs1，rs2）的大小（做减法）/Adder中**计算转移**地址（PC+SEXT（imm12）<<1）(使用两个加法器)
  - Mem: 如果比较相等, 则：转移目标地址写到PC
    - 为什么写入Mem要放在Mem阶段：`beq` 是一种**分支指令**，它的作用是根据两个寄存器的值是否相等来决定程序的执行流程**是否跳转到另一个地址**。这个决策需要在**流水线的早期阶段做出**，以**避免执行不必要的指令**。
    - 如果等到写回（WB）阶段才决定是否跳转，那么在此之前的**所有阶段都可能已经加载了一些不必要的指令**。这将导致效率低下，因为流水线可能需要**清空并重新从新**的地址开始加载指令。
  - Wr:  Nop
- J-type`jal r, imm20`
  - Ifetch: 取指令并计算PC+4 （写入PC ，但后续肯定需要修改PC ）
  - Reg/Dec:从寄存器取数，同时指令在译码器进行译码
  - Exec:  执行阶段ALU中计算PC+4（准备写入rd）/Adder中计算转移地址（PC+SEXT（imm20）<<1）
  - Mem:把转移地址写入PC
  - Wr: 把ALU运算结果（PC+4）写入rd

#### 五阶段流水线数据通路

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231221233856817.png" alt="image-20231221233856817" style="zoom: 50%;" />
  - 红色流水段寄存器：保存**每个周期执行的结果!**属于内部寄存器，对程序员透明，无需作为现场保存！
    - 使用处于的两个阶段命名
  
- 以load为例，介绍指令的具体执行过程

- 取指令IF

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231222002959558.png" alt="image-20231222002959558" style="zoom:33%;" />
    - 流水段寄存器**IF/ID**存储PC和IR
  - 开始时和过程中
    - ![image-20231222003343845](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231222003343845.png)
    - **不需控制信号**，因为每条指令执行功能一样，是确定的，无需根据指令的不同来控制执行不同的操作！

  - 执行结束时
    - 流水段寄存器用来存放各阶段的执行结果总是在**下个时钟到来后的Clock-to-Q**更新，保存**后面阶段用到的**指令和旧PC的值！
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231222003436467.png" alt="image-20231222003436467" style="zoom:50%;" />

- 译码/取数（Reg/Dec）阶段

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231222003711725.png" alt="image-20231222003711725" style="zoom:33%;" />
    - 流水段寄存器**ID/EX**存储寄存器读取结果R[Rs1]、R[Rs2],目的寄存器编号Rd，IMM和PC
    - 需要使用**ExtOP**信号

- Exec计算阶段

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231222004746622.png" alt="image-20231222004746622" style="zoom:33%;" />
    - 流水段寄存器**EX/M**存储PC跳转地址、zero标志、运算结果、R[Rs2]\(busB)、Rd
    - 控制信号：ALUASrc，ALUBSrc，ALUctr

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231222005528337.png" alt="image-20231222005528337" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231222005609951.png" alt="image-20231222005609951" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231222005623776.png" alt="image-20231222005623776" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231222005634212.png" alt="image-20231222005634212" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231222005644214.png" alt="image-20231222005644214" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231222005654916.png" alt="image-20231222005654916" style="zoom:50%;" />

- Mem存储器读

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231222005816453.png" alt="image-20231222005816453" style="zoom:50%;" />
    - 流水段寄存器**M/WB**存储存储器读取结果，ALU运算结果，Rd
    - 控制信号：Branch，jump，memwr


  - B指令（冒险）
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231222010201865.png" alt="image-20231222010201865" style="zoom:33%;" />

- WB回写（冒险）

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231222010337212.png" alt="image-20231222010337212" style="zoom:33%;" />
    - 传递数据和Rd
    - 控制信号：MemtoReg


### 流水线冒险及其处理

- 
