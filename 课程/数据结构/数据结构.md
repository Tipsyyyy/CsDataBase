##     概述

- 数据结构由某一**数据对象**及该对象中所有数据成员之间的**关系**组成。涉及：**逻辑结构**（如线性表）；**物理结构**（如顺序表）；**操作**；

- 关系的映象：顺序映象、链式映象、索引存储方法、散列存储方法

- 分类
  - **线性**结构：表、栈、队列
  - 非线性结构：
    - **层次**结构： 树，二叉树，堆
    - **网状**结构： 图 
    - 其它：集合

- 算法的效率包括时间代价和空间代价，前者指的是算法执行时间；后者指的是算法执行过程中所需的**最大**存储空间。
- 算法效率：
  - 后期测试（计时）
  - 事前估计

### 数据结构的形式定义

- 由数据对象和关系组成 Data_Structure = {D, R}
- 由数据集合、关系集合、关系组成
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230912205130886.png" alt="image-20230912205130886" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230912205142916.png" alt="image-20230912205142916" style="zoom:33%;" />

#难点 
### 序步衡量时间复杂度

- 注释：程序步数为0  
- 声明语句：程序步数为0  
- 表达式、赋值语句：程序步数为1 
- 循环语句：**循环控制语句**每次执行的程序步数为1（尤其注意）
```c++
float sum ( float a[ ], const int n )	{
    float s = 0.0;
    count++;	//count统计执行语句条数
    for ( int i = 0; i < n; i++ ) {
        count+=2;	//针对for语句（i++及比较）
        s += a[i];
        count++; //针对赋值语句
    }	
    count+=2;	//针对for的最后一次
    count++;	//针对return语句
    return s;
}       //执行结束得 程序步数 count =3 * n + 4

void d(ArrayElement x[],int n){
    int i=0;
    count++;
    do{
        x[i]+=2;i+=2;
        count+=3;
    }while(i<n);
    i=0;
    count++;
    while(i<(n/2)){
        x[i]+=x[i+1];i++;
        count+=3;
    }
    count++;
}
```
- `x = sum (R, n);`则为$1+3*n+4=3*n+5$

## [[线性数据结构]]

## [[搜索结构]]

## [[图]]

## [[排序]]

## [[课程/数据结构/笔记/文件系统|文件系统]]


- 适应矩阵操作时（+-\*）时矩阵非零元素的动态变化
- 稀疏矩阵表示为行链表与列链表的**十字交叉**，即正交链表（十字链表）
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024010900136.png" alt="image-20231024010900136" style="zoom:33%;" />
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024010908055.png" alt="image-20231024010908055" style="zoom:33%;" />

## 字符串

- 空白串`" "`，空串`""`
```c++
#ifndef ASTRING_H	//定义在文件“Astring.h”中
#define ASTRING_H
#define defaultSize = 128;     //字符串的最大长度
class AString {
    //对象: 零个或多个字符组成的一个有限序列。
    private:
    char *ch;			      //串存放数组
    int curLength;		      //串的实际长度
    int maxSize;		      //存放数组的最大长度
    public:    
    AString(int sz = defaultSize);      //构造函数 	
    AString(const char *init );          //构造函数
    AString(const AString& ob);      //复制构造函数
    ～AString() {delete [ ]ch; }	      //析构函数
    int Length() const { return curLength; }	 //求长度
    Astring& operator() (int pos, int len);   //求子串
    bool operator == (AString& ob) const 
    { return strcmp (ch, ob.ch) == 0; }
    //判串相等. 若串相等, 则函数返回true
    bool operator != (AString& ob) const 
    { return strcmp (ch, ob.ch) != 0; }
    //判串不等. 若串不相等, 则函数返回true  
    bool operator ! () const { return curLength == 0; } 
    //判串空否。若串空, 则函数返回true
    AString& operator = (AString& ob);      //串赋值
    AString& operator += (AString& ob);	//串连接
    char& operator [ ] (int i);		//取第 i 个字符
    int Find (AString& pat, int start) const;    //串匹配
};
//构造函数
AString::AString(int sz) {
//构造函数：创建一个空串
     maxSize = sz;
     ch = new char[maxSize+1];        //创建串数组
     if (ch == NULL) 
         { cerr << “存储分配错!\n”;  exit(1); }
     curLength = 0;       
     ch[0] = ‘\0’;
};
AString::AString(const char *init) {
//复制构造函数: 从已有字符数组*init复制
     int len = strlen(init);
     maxSize = (len > defaultSize) ? len : defaultSize;
     ch = new char[maxSize+1];     //创建串数组
     if (ch == NULL)
        { cerr << “存储分配错 ! \n”;  exit(1); }
     curLength = len;	 	   //复制串长度
     strcpy(ch, init);		             //复制串值	
 }；
    
AString :: AString(const AString& ob) {
 //复制构造函数：从已有串ob复制
     maxSize = ob.maxSize;               //复制串最大长度
     ch = new char[maxSize +1];     //创建串数组
     if (ch == NULL) 
         { cerr << “存储分配错! \n”;  exit(1); }
     curLength = ob.curLength;          //复制串长度
     strcpy(ch, ob.ch);                         //复制串值
 };	

AString  AString::operator () (int pos, int len) {
//从串中第 pos 个位置起连续提取 len 个字符形成
//子串返回 	
     AString  temp;                           //建立空串对象
     if (pos >= 0 && pos+len-1 < maxSize && len > 0)
     {                                                  //提取子串
	      if (pos+len-1 >= curLength)  
               len = curLength - pos;     //调整提取字符数
          temp.curLength = len;           //子串长度
for (int i = 0, j = pos; i < len; i++, j++) 
	           temp.ch[i] = ch[j];        //传送串数组
	      temp.ch[len] = ‘\0’;           //子串结束
     }
     return  temp;
};	

AString& AString::operator = (const AString& ob) {
     if (&ob != this) {	//若两个串相等为自我赋值
          	delete []ch; 
		ch = new char[maxSize+1];	//重新分配 
	     	if (ch == NULL) 
              { cerr << “存储分配失败!\n ”;  exit(1); }
		curLength = ob.curLength;  strcpy(ch,ob.ch);
     }
	 else cout << “字符串自身赋值出错!\n”;	
	 return this;
}; 

char AString::operator [ ] (int i) {
//串重载操作：取当前串*this的第i个字符
     if (i < 0 || i >= curLength) 
         { cout << “字符串下标超界!\n ”; exit(1); } 
	 return ch[i];
};

AString& AString::operator += (const AString& ob)
{
     char *temp = ch;		//暂存原串数组
	 int n = curLength + ob.curLength;	      //串长度累加
	 int m = (maxSize >= n) ? maxSize : n; //新空间大小
	 ch = new char[m];
     if (ch == NULL) 
         { cerr << “存储分配错!\n ”;  exit(1); }
	 maxSize = m;  curLength = n;
	 strcpy(ch, temp);        	         //拷贝原串数组
	 strcat(ch, ob.ch);	         //连接ob串数组  	
         delete []temp;  
     return this;
};

```

### 串模式匹配

- 在主串中寻找子串（第一个字符）在串中的位置

- 在模式匹配中，子串称为模式，主串称为目标。

- 朴素实现：复杂度$O(n*m)$


```c++
int AString::Find(AString& pat, int start) const {
//在当前串中从第 start 个字符开始寻找模式 pat 在当
//前串中匹配的位置。若匹配成功, 则函数返回首
//次匹配的位置, 否则返回-1。
     int i, j, n = curLength, m = pat.curLength;
     if (m == 0) return -1;    //pat为空
     for (i = start; i <= n-m; i++) { 
          	for (j = 0; j < m; j++){
               if (ch[i+j] != pat.ch[j]) break;   //本次失配
           }
           if (j == m) return i;   //pat扫描完, 匹配成功
	  }
   return -1;	 //在*this中找不到子串
};	
```

#### KMP

##### next数组

- 复杂度$O(n)$
- 由模式串计算，$next[i]$表示$pat[0,i-1]$的最长共同前后缀的长度
- 书上定义（注意书上定义实际上是**之前版本的next[i-1]**）
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024083510277.png" alt="image-20231024083510277" style="zoom:33%;" />如果 j > 0，那么在下一趟比较时模式串 P的起始比较位置是 pnext(j)，目标串 T 的指针不回溯，仍指向上一趟失配的字符；
- 匹配时
  - 如果 j > 0，那么在下一趟比较时模式串 P的起始比较位置是 pnext(j)，目标串 T 的指针不回溯，仍指向上一趟失配的字符；
  - 如果 j = 0，则目标串指针 T 进一，模式串指针 P 回到 p0，继续进行下一趟匹配比较
##### 代码
```c++
vector<int> build_next(string s)//构建next数组
{
    vector<int>next{-1};//第一位一定为零（因为规定前后缀不能为自身）
    int i=1,len=0;//len记录当前位置最大重合长度
    while(i<s.size())
    {
        if(s[len]==s[i-1]&&len!=i-1)
        {
            len++;
            next.push_back(len);
            i++;
        }
        else
        {
            if(len==0)
            {
                next.push_back(0);
                i++;
            }
            else
                len=next[len];//找到对应的前缀的末尾位置（一种递归思想，长的匹配不上则逐渐缩短去找）
        }
    }
    return next;
}
    int kmp(string fs,string ss)//ss为待匹配的子串
    {
        vector<int>next=build_next(ss);
        int i=0,j=0;
        while(i<fs.size())
        {
            if(fs[i]==ss[j])
            {
                i++;
                j++;
            }
            else if(j>0)
                j=next[j];//前next[j-1]位仍相同，在这之后继续匹配
            else
                i++;
            if(j==ss.size())
                return i-j;
        }
        return -1;
    }
```

## 广义表

- 广义表是n个元素组成的有限序列$LS(a_1,\dots,a_n)$
  - **LS是表名**，$a_i$是元素（子表或数据元素）
  - n 表示表的长度，$n=0$ 的表为空表

- n > 0时，表的**第一个表元素**称为广义表 的**表头**（head），除此之外，**其它表元素组成的表**称为广义表的**表尾**（tail）。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024085427224.png" alt="image-20231024085427224" style="zoom:33%;" />
  - 长度与深度
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231108171244013.png" alt="image-20231108171244013" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024085833176.png" alt="image-20231024085833176" style="zoom:33%;" />
    - 注意:ta返回的**尾元素的元组**,即要**在外面加一组括号**,而head返回表头(单个元素)**不会加上一组额外括号**
    - 表头是一个结点，而表尾是一个广义表
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231108103418890.png" alt="image-20231108103418890" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024090115417.png" alt="image-20231024090115417" style="zoom:33%;" />

- 特性：有次序性、有深度、可递归、有长度、可共享

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024085916942.png" alt="image-20231024085916942" style="zoom:33%;" />

- 广义表结点的定义
  - `utype | info | tlink`
    - 节点类型utype：广义表专用的附加头节点0（**并不是广义表的第一个元素表头，而是一个附加的头节点**，类似于表的标识符ABCD（**表名**））；原子数据1；子表2；
    - 信息info：utype=0时存储引用计数；等于1时存储数据值；等于2时存储子表表头指针
    - 尾指针tlink：utype=0时指向第一个节点；utype!=0时指向同一层下一个节点
  - 存储表示
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231108171439237.png" alt="image-20231108171439237" style="zoom:50%;" />


```c++
template <class T>
    struct GenListNode {	          //广义表结点类定义
        int utype;			//＝0 / 1 / 2
        GenListNode<T> *tlink;	//同层下一结点指针
        union {				//等价变量
            int ref;	                     //存放引用计数
            T value;			//存放数值
            GenListNode<T> *hlink;	  //存放子表指针	
        } info;
        GenListNode()                          //构造函数
            : utype(0), tlink(NULL), info.ref(0) {}
        GenListNode(GenListNode<T>& R) {
            //复制构造函数
            utype = R.utype;   tlink = R.tlink; 
            info = R.info;
        }
    };
template <class T>
    class GenList {			  //广义表类定义
        public:
        Genlist();			          //构造函数
        ～GenList();			//析构函数 
        bool Head (GenListNode<T>& x);   //x 返回表头
        bool Tail (GenList<T>& lt);	   //lt 返回表尾
        GenListNode<T> *First();	   //返回第一个元素地址(尾元素中)
        GenListNode<T> *Next (GenListNode<T> *elem);
        //返回表元素elem的直接后继元素
        void Copy ( const GenList<T>& R);
        //广义表的复制
        int Length();    		          //计算广义表长度
        int Depth();		
        private:
        GenListNode<T> *first;	//广义表头指针
        GenListNode<T> *Copy (GenListNode<T> *ls);
        //复制一个ls指示的无共享非递归表
        int Length (GenListNode<T> *ls);
        //求由ls指示的广义表的长度
        int Depth (GenListNode<T> *ls);		
        //计算由ls指示的非递归表的深度
        bool Equal (GenListNode<T> *s, 
                    GenListNode<T> *t);
        //判以s和t为表头的两个表是否相等
        void Remove (GenListNode<T> *ls);
        //释放以ls为附加头结点的广义表
        void CreateList (istream &in,  GenListNode<T> *&    ls, SeqList<T>& L1,  SeqList <GenListNode<T> *>& L2);
        //从输入流对象输入广义表的字符串描述, 
        //建立一个带头结点的广义表结构

        friend istream& operator >> (istream& in, 
                                     GenList<T>& L);           
    };

template <class T>
    Genlist<T>::GenList() {		//构造函数
        GenListNode<T> * first = new GenListNode;
        if (first == NULL)   { cerr << “存储分配失败！\n”;  exit(1); }
    };

template <class T>
    bool GenList<T>::Head (GenListNode <T>& x) {
        //若广义表非空，则通过x返回其第一个元素的值
        //否则函数没有定义	
        if (first->tlink == NULL) return false;	//空表
        else {						//非空表
            x.utype = first->tlink->utype;
            x.info = first->tlink->info;
            return true;		                 //x返回表头的值
        }
    };	
template <class T>
    bool GenList<T>::Tail(GenList<T>& lt) {
        //若广义表非空，则通过lt返回广义表除表头元素
        //以外其他元素组成的表，否则函数没有定义
        if (first->tlink == NULL) return false;	    //空表
        else { 				//非空表
            lt.first->utype = 0;		//设置头结点
            lt.first->info.ref = 0;
            lt.first->tlink = Copy(first->tlink->tlink);
            return true; 
        }
    };
template <class T>
    GenListNode<T> *GenList<T>::First() {
        //返回广义表的第一个元素（若表空，则返回一个
        //特定的空值NULL）	
        if (first->tlink == NULL) return NULL;    //空表      
        else return first->tlink;	 	 //非空表
    };
template <class T>
    GenListNode<T> *GenList<T>::Next(GenListNode<T> *elem) {
    //返回表元素elem的直接后继元素
    if (elem->tlink == NULL) return NULL;
    else return elem->tlink;
};
```

#### 递归算法

- 复制
```c++
template <class T>                 //公有函数
void GenList<T>::Copy(const GenList<T>& R) 
     first = Copy(R.first);          //调用私有函数
};
template <class T>                 //私有函数
GenListNode<T>* GenList<T>::Copy(GenListNode <T> *ls) {//复制一个 ls 指示的无共享子表的非递归表
     GenListNode<T> *q = NULL;
     if (ls != NULL) {
          q = new GenListNode<T>;  //处理当前的结点q
          q->utype = ls->utype;	  //复制结点类型
	      	switch (ls->utype) {	  //根据utype传送信息
              case 0: q->info.ref = ls->info.ref;  break;	        	  
              case 1: q->info.value = ls->info.value;  break;
              case 2: q->info.hlink = Copy(ls->info.hlink);   
                           break;
             }
          q->tlink = Copy(ls->tlink);  //处理同层下一结点
    }
     return q;
};
```

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024093048284.png" alt="image-20231024093048284" style="zoom: 50%;" />

- 长度：
  - 求广义表的长度就是**求同一层**次中tlink连接起来的单链表的长度
```c++
template<class T>
    int GenList<T>::Length(){
      return Length(first);  
    };
template<class T>
    int GenList<T>::Length(GenListNode<T>*ls){
        if(ls!=NULL)return 1+Length(ls->tlink);
        else return 0;
    }
```

- 深度：

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024093712174.png" alt="image-20231024093712174" style="zoom:33%;" />
```c++
template <class T>
    int GenList<T>::Depth() {             //公有函数
        //计算一个非递归表的深度
        return Depth(first);
    };

template <class T>                      //私有函数
    int GenList<T>::Depth(GenListNode<T> *ls) {
        if (ls->tlink == NULL) return 1;		
        // ls->tlink ==NULL, 空表，深度为1
        GenListNode<T> *temp = ls->tlink;  
        int m = 0, n;
        while (temp != NULL) {	//在广义表顶层横扫
            if (temp->utype == 2) {	   //扫描到表结点 
                n = Depth(temp->info.hlink);	
                //递归计算以子表深度
                if (m < n) m = n;	   //取最大深度
            }
            temp = temp->tlink;
        }
        return m+1;			  //返回深度
    };
```

- 比较相等
```c++
template<class T>
    bool equal(GenList<T>*s,GenListNode<T>*t){
    int x;
    if(s->tlink==NULL&&t->tlink==NULL)return true;
    if(s->tlink!=NULL&&t->tlink!=NULL&&s->tlink->utype==t->tlink->utype){
        if(s->tlink->utype==1){
            x=(s->tlink->info.value==t->tlink->info.value)?1:0;
        }
        else if(s->tlink->utype==2){
            x=equal(s->tlink->info.hlink,t->tlink->info.hlink);
        }
        if(x==1)return equals(s->tlink,t->tlink);
    }
    return false;
}
```

- 删除元素
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024094015893.png" alt="image-20231024094015893" style="zoom:33%;" />
```c++
template <class T>
void delvalue(GenListNode<T> *ls, T x) {
     if (ls->tlink != NULL) {		     //非空表 
	      GenListNode<T> * p = ls->tlink;  //第一个结点
	      while (p != NULL && (p->utype == 1 &&
               p->info.value == x)) {
               ls->tlink = p->tlink;  delete p;  
               p = ls->tlink;               //p指向同层下一结点
 	     }					
         if (p != NULL) {//遇到表元素
              if (p->utype == 2)        
                   delvalue(p->info.hlink, x);//递归在子表中删除
              delvalue(p, x);	//在该表行中继续删除
          }
     }
};	
```

- 对于共享表来说，如果一个表元素有多个地方使用它，贸然删去它会造成其他地方使用出错。因此，当要做删除时，**先把该表的头结点中的引用计数 ref 减1，当引用计数减到 0 时才能执行结点的真正释放。**
```c++
template <class T>
GenList<T>::～GenList() {
//广义表的析构函数, 每个头结点都有引用计数
     Remove(first);
    if(first.info.ref<=0)
         delete first; //first要额外处理
};
template <class T>
void GenList<T>::Remove(GenListNode<T> *ls) {
//私有函数：释放以ls为表头指针的广义表 
     ls->info.ref--;	     	//头结点的引用计数减1
     if (ls->info.ref <= 0) {		//如果减到0
   	      GenListNode<T> *q;	
          while (ls->tlink != NULL) {	//横扫表顶层
               q = ls->tlink;			//到第一个结点
               if (q->utype == 2) {		//递归删除子表
                    Remove(q->info.hlink);
                    if (q->info.hlink->info.ref <= 0)
                        delete q->info.hlink;   //删子表头结点
 		    }
 		    ls->tlink = q->tlink;  delete q;
   	      }
     }
};
```

- 由字符串建立广义表
  - 字符串描述`S(A ( ‘b’, ‘c’ ), B(‘#’), ‘d’ )；`
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024130516374.png" alt="image-20231024130516374" style="zoom:50%;" />
  - 检测从输入流对象输入的一个字符，如果遇到表名（用大写字母表示），首先检查这个**表名是否已经存在**，如果是，说明该表是**共享表**，只要将相应头结点的引用计数加一即可；如果不是，保存该表名并建立相应广义表。表名后面一定是左括号‘(’，不是则输入错，是则递归建立广义表结构。
    - **注意：ABCD是表的标识符（指向表的外部指针），与表头区分**
  - 如果遇到用小写字母表示的原子，则建立原子结点；如果遇到右括号‘)’，子表链收尾并退出递归。
  - 空表情形括号里应夹入**一个非英文字母**，如字符'#'，不能一个字符也没有。整个广义表描述字符串以';'结束
```c++
template<class T>
    void Genlist<T>::CreateList(istream &in,GenListNode<T>*&ls,SeqList<T>&L1,SeqList<GenListNode<T>*>&L2)//L1存储大写字母的表名，L2存储表名对应子表节点的地址
    {
        T chr;
        in>>chr;
        if(isalpha(chr)&&isupper(chr)||chr=='(')//大写字母或(
        {
            ls=new GenListNode<T>;
            ls->utype=2;
            if(isalpha(chr)&&isupper(chr)){
                int n=L1.Length();
                int m=L1.Search(chr);
                if(m!=0){//表已经建立
                    GenListNode<T>*p=L2.Locate(m);
                    p->ref++;
                    ls->info.hlink=p;//可以直接使用
                    return;
                }
                else{
                    ls->info.hlink=new GenListNode<T>;//新的外头界点
                    ls->info.hlink->utype=0;
                    ls->info.hlink->ref=1;
                    L1.insert(n,chr);
                    L2.insert(n,ls->hlink);
                }
                in>>chr;
                if(chr!='(')
                    exit(-1);
            }
            CreateList(in,ls->info.hlink->tlink,L1,L2);//继续处理子表
            CreateList(in,ls,L1,L2);//子表处理完成，继续处理
        }
        else if(isalpha(chr)&&islower(chr)){
            ls=new GenListNode<T>;
            ls->utype=1;
            ls->info.value=chr;
            CreateList(in,ls,L1,L2);
        }
        else if(chr==',')
            CreateList(in,ls->tlink,L1,L2);
        else if (chr == ')') 
            ls->tlink = NULL;
        else if (chr == '#') 
            ls = NULL;
    }

template <class T>
    istream& operator >> (istream& in, GenList<T>& L)
{
    int n;
    cout << “输入广义表串的字符个数：”<< endl;
    in >> n;
    SeqList<T> Ls1(n); 	
    SeqList <GenListNode<T> *> Ls2 (n);
    CreateList (in, L.first, Ls1, Ls2);	//建立存储结构
}; 
```

## 树

- 有根树T是n>=0个点的有限集合（n=0时为空树）
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102102434551.png" alt="image-20231102102434551" style="zoom:50%;" />
  - r是根（无前驱），$T_i$是根的子树
  - 每棵子树的根结点有且仅有一个直接前驱，但可以有0个或多个直接后继

- 基本概念
  - 度：节点的子树数目就是节点的度，**数中度的最大值是树的度**
  - 分支结点：度不为0的结点即为分支结点，亦称为非终端结点。
  - 叶结点：度为0的结点即为叶结点，亦称为终端结点。
  - 祖先：**根结点到该结点**的路径上的**各个结点**都是该结点的祖先。
  - 子孙：某结点的**所有下属结点**，都是该结点的子孙。
  - 结点的**层次**：规定**根结点在第一层**，其子女结点的层次等于它的层次加一。
  - 结点的深度：结点的**深度即为结点的层次**；离根**最远**结点的**层次即为树的深度**。
  - 结点的**高度**：规定**叶结点的高度为1**，其双亲结点的高度等于它的高度加一。**树的高度等于根节点的高度**
  - 有序树：节点的各棵子树有次序
  - 无序树：节点的各棵子树可以互换位置
  - 同一**结点**的子女互称兄弟
  - 森林：森林是m（m≥0）棵树的集合

### 二叉树

- 结点的一个有限集合，或者为空；或者由一个根结点加上两棵分别称为左子树右子树的互不相交的二叉树组成
- 性质
  - 第i层最多$2^{i-1}$结点（跟位于第一层）
  - 深度为k的二叉树最少$k$个结点，最多$2^k-1$个（满二叉树）；n个节点的**完全二叉树**深度$\lceil\log_2(n+1)\rceil$
  - 设叶节点$n_0$个，非叶节点$n_2$个，则$n_0=n_2+1$
- 满二叉树：有$2^k-1$个结点的二叉树
- 完全二叉树：除第k层外 全满（堆的要求）
- 二叉树的顺序表示：
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102104712509.png" alt="image-20231102104712509" style="zoom:50%;" />

#### 二叉树的链表表示

- 二叉链表表示，三叉链表表示（增加**指向父节点**）
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102151721048.png" alt="image-20231102151721048" style="zoom:33%;" />

#### 二叉树遍历

##### 利用前序遍历建立二叉树

- 使用@表示空结点（否则不能只通过前序遍历创建）

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102152852580.png" alt="image-20231102152852580" style="zoom:33%;" />


```c++
template<class T> 
    void BinaryTree<T>::CreateBinTree (ifstream& in, BinTreeNode<T> *& subTree) {
        //私有函数: 以递归方式建立二叉树。
        T item;
        if ( !in.eof () ) {	    	//未读完, 读入并建树	
            in >> item;  		//读入根结点的值
            if (item != RefValue) {//不是表示空结点的@
                subTree = new BinTreeNode<T>(item);
                //建立根结点
                if (subTree == NULL) 
                {cerr << “存储分配错!” << endl;  exit (1);}
                CreateBinTree (in, subTree->leftChild);
                //递归建立左子树
                CreateBinTree (in, subTree->rightChild);
                //递归建立右子树
            }
            else subTree = NULL;						    //封闭指向空子树的指针
        }
    };
```

##### 非递归的遍历

- 前序遍历

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102153554354.png" alt="image-20231102153554354" style="zoom: 33%;" />


```c++
template <class T> 
void BinaryTree<T>::
PreOrder (void (*visit) (BinTreeNode<T> *t) ) {
     stack<BinTreeNode<T>*> S;
     BinTreeNode<T> *p = t; 
     S.Push (NULL);
	 while (p != NULL) {
          visit(p);			   //访问结点
 	      if (p->rightChild != NULL)
               S.Push (p->rightChild);  //预留右指针在栈中
          if (p->leftChild != NULL) 
               p = p->leftChild;	//进左子树
 	      else S.Pop(p);		//左子树为空
     }
};
```

- 中序遍历

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102155003400.png" alt="image-20231102155003400" style="zoom: 33%;" />


```c++
template <class T> 
void BinaryTree<T>::
InOrder (void (*visit) (BinTreeNode<T> *t)) {
     stack<BinTreeNode<T>*> S;    
      BinTreeNode<T> *p = t; 
    do {
          while (p != NULL) {	//遍历指针向左下移动
               S.Push (p); 		//该子树沿途结点进栈
               p = p->leftChild;
          }
          if (!S.IsEmpty()) {		//栈不空时退栈
               S.Pop (p);  visit (p);	//退栈, 访问
               p = p->rightChild;	//遍历指针进到右子女
          }
     } while (p != NULL || !S.IsEmpty ());
};
```

- 后序遍历

  - 定义栈的结点

    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102155436923.png" alt="image-20231102155436923" style="zoom:33%;" />

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102155556809.png" alt="image-20231102155556809" style="zoom:50%;" />


```c++
template <class T>
    void BinaryTree<T>::
PostOrder (void (*visit) (BinTreeNode<T> *t) {
    Stack<stkNode<T>> S;   stkNode<T> w; 
    BinTreeNode<T> * p = t;     //p是遍历指针
    do {
        while (p != NULL) {	
            w.ptr = p;  w.tag = L;  S.Push (w);   
            p = p->leftChild;					}
        int continue1 = 1;	    //继续循环标记, 用于R
        while (continue1 && !S.IsEmpty ()) {
            S.Pop (w);  p = w.ptr;
            switch (w.tag) {   	//判断栈顶的tag标记
                case L:  w.tag = R;  S.Push (w); 
                    continue1 = 0;  
                    p = p->rightChild;  break;
                case R:  visit (p);   break;	
            }
        }
    } while (!S.IsEmpty ());	//继续遍历其他结点
    cout << endl;
};
```

#### 层次遍历

- 使用一个先进先出队列，在处理上一层时，将其下一层的结点直接进到队列（的队尾）。在上一层结点遍历完后，下一层结点正好处于队列的队头，可以继续访问它们。
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102160454567.png" alt="image-20231102160454567" style="zoom: 33%;" />

#### 线索化二叉树

- 穿线树，通过遍历二叉树可以将二叉树中所有节点的数据排列在一个线性序列中，可以找到前驱和后继
- 法一：直接添加pred指针和succ指针
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102161258892.png" alt="image-20231102161258892" style="zoom:33%;" />
  - 问题：占用空间大，原先的left和right指针有2n个但是只有n-1个非空，没有得到充分利用
- 方法二：利用空余的left和right指针存储前后继，使用标志位ltag、rtag指明指针是指示子女还是前驱后继（线索），一般用left存前驱，right存后继
  - 标志位=0表示存储的是子女结点，=1表示存储线索
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102162242680.png" alt="image-20231102162242680" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102162305362.png" alt="image-20231102162305362" style="zoom:50%;" />
  - 实际上对于原始存在的左右节点，其tag均为0，对于新创建的为1.

##### 中序线索化二叉树

- 寻找后继

  - | rightChild\rtag | ==0                                              | ==1            |
    | :-------------- | ------------------------------------------------ | -------------- |
    | ==NULL          | 无此情况                                         | 无后继         |
    | !=NULL          | 后继为当前结点**右子树**的中序下的**第一个结点** | 后继为子女结点 |

    

- 寻找前驱

  - | leftChild\ltag | ==0                                              | ==1              |
    | -------------- | ------------------------------------------------ | ---------------- |
    | ==NULL         | 无此情况                                         | 无前驱           |
    | !=NULL         | 前驱为当前结点**左子树**中序下的**最后一个结点** | 前驱为左子女结点 |


```c++
template<T>
TreadNode<T>*ThreadTree<T>::First(ThreadNode<T>*current){
    //返回以current为根的中序线索二叉树中中序序列下的第一个结点
    ThreadNode<T>*p=current;
    while(p->ltag==0)p=p->leftChild;
    return p;
}
template<T>
TreadNode<T>*ThreadTree<T>::Next(ThreadNode<T>*current){
    ThreadNode<T>*p=current->rightChild;
    if(current->rtag==0)return First(p);
    else return p;
}
template<T>
TreadNode<T>*ThreadTree<T>::Last(ThreadNode<T>*current){
    //返回以current为根的中序线索二叉树中中序序列下的最后一个结点
    ThreadNode<T>*p=current;
    while(p->rtag==0)p=p->rightChild;
    return p;
}
template<T>
TreadNode<T>*ThreadTree<T>::Prior(ThreadNode<T>*current){
    ThreadNode<T>*p=current->leftChild;
    if(current->ltag==0)return Last(p);
    else return p;
}
```

- 中序遍历建立线索化二叉树


```c++
template <class T>
struct ThreadNode {	      //线索二叉树的结点类
     int ltag, rtag;		      //线索标志
     ThreadNode<T> *leftChild, *rightChild;//线索或子女指针
     T data;			      //结点数据
     ThreadNode ( const T item)             //构造函数
          : data(item), leftChild (NULL),
            rightChild (NULL), ltag(0), rtag(0) {}	
};
template <class T>
class ThreadTree {			//线索化二叉树类
protected:
     ThreadNode<T> *root;	//树的根指针
     void createInThread (ThreadNode<T> *current,  
            ThreadNode<T> *& pre);
	    //中序遍历建立线索二叉树
     ThreadNode<T> *parent (ThreadNode<T> *t);	 
        //寻找结点t的双亲结点
public:
     ThreadTree () : root (NULL) { }	//构造函数
	void createInThread();        //建立中序线索二叉树
     ThreadNode<T> *First (ThreadNode<T> *current);
		//寻找中序下第一个结点
     ThreadNode<T> *Last (ThreadNode<T> *current);
		//寻找中序下最后一个结点
	  ThreadNode<T> *Next (ThreadNode<T> *current);
		//寻找结点在中序下的后继结点
	  ThreadNode<T> *Prior (ThreadNode<T> *current);
		//寻找结点在中序下的前驱结点
	       ………
	};
template <class T>
void ThreadTree<T>::createInThread () {
     ThreadNode<T> *pre = NULL;    //前驱结点指针
	 if (root != NULL) {   	         //非空二叉树, 线索化
          createInThread (root, pre);				    //中序遍历线索化二叉树
	      pre->rightChild = NULL;  pre->rtag = 1;		   //后处理中序最后一个结点
	 }
};
template <class T>
void ThreadTree<T>::
createInThread (ThreadNode<T> *current,ThreadNode<T> *& pre) {
//通过中序遍历，添加缺失的边进行连接, 对二叉树进行线索化
     if (current == NULL) return;
     createInThread (current->leftChild, pre);
		//递归, 左子树线索化
	 if (current->leftChild == NULL) {				//建立当前结点的前驱线索
          current->leftChild = pre;   current->ltag = 1; 
     }
     if (pre != NULL && pre->rightChild == NULL) 	    //建立前驱结点的后继线索
        { pre->rightChild = current;   pre->rtag = 1; }	
     pre = current;							   //前驱跟上,当前指针向前遍历
	 createInThread (current->rightChild,  pre);		  //递归, 右子树线索化
};//就是左中右的中序遍历模式，对于中结点双向连接
```

##### *其他线索化二叉树

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102172300448.png" alt="image-20231102172300448" style="zoom:50%;" />
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102172308402.png" alt="image-20231102172308402" style="zoom:50%;" />

### 树与森林

- 广义表表示

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104104227049.png" alt="image-20231104104227049" style="zoom: 50%;" />

- 双亲表示

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104104606866.png" alt="image-20231104104606866" style="zoom: 50%;" />

- 链表表示

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104104947906.png" alt="image-20231104104947906" style="zoom:50%;" />

- 指针节点表示

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104105053288.png" alt="image-20231104105053288" style="zoom:50%;" />

- 子女兄弟表示

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104105352996.png" alt="image-20231104105352996" style="zoom:50%;" />
    - firstchild指向第一个子女节点，nextSibling指向下一个兄弟，即横向沿链扫描

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104105730382.png" alt="image-20231104105730382" style="zoom:50%;" />


```c++
template <class T>
    struct TreeNode {			//树的结点类
        T data;				//结点数据
        TreeNode<T> *firstChild, *nextSibling;
        //子女及兄弟指针
        TreeNode (T value = 0, TreeNode<T> *fc = NULL,   
                  TreeNode<T> *ns = NULL)     //构造函数
            : data (value), firstChild (fc), nextSibling (ns) { }
    };
template <class T>
    class Tree {			//树类
        private:
        TreeNode<T> *root, *current;				//根指针及当前指针
        int Find (TreeNode<T> *p, T value);			//在以p为根的树中搜索value
        void RemoveSubTree (TreeNode<T> *p);		//删除以p为根的子树
        bool FindParent (TreeNode<T> *t, 
                         TreeNode<T> *p);
        public:
        Tree () { root = current = NULL; }	//构造函数
        bool Root ();	           //置根结点为当前结点
        bool IsEmpty () { return root == NULL; }
        bool FirstChild ();
        //将当前结点的第一个子女置为当前结点
        bool NextSibling ();
        //将当前结点的下一个兄弟置为当前结点
        bool Parent ();
        //将当前结点的双亲置为当前结点
        bool Find (T value);
        //搜索含value的结点, 使之成为当前结点
        …… 			//树的其他公共操作
    };
template <class T>
    bool Tree<T>::
FindParent (TreeNode<T> *t, TreeNode<T> *p) {
    //在根为*t的树中找*p的双亲, 并置为当前结点
    TreeNode<T> *q = t->firstChild;     //*q是*t长子
    bool succ;
    while (q != NULL && q != p) {	  //扫描兄弟链
        if ((succ = FindParent (q, p)) == true) 
            return succ;	//递归搜索以*q为根的子树
        q = q->nextSibling;
    }
    if (q != NULL && q == p) {
        current = t;  return true;
    }
    else { current = NULL;  return false; }   //未找到
}
```

#### 树的遍历

- 先根次遍历
  - 树的先根遍历结果与其对应二叉树表示的**前序遍历**结果相同


- 后根次遍历
  - 树的后根遍历结果与其对应二叉树表示的**中序遍历**结果相同

- 广度优先遍历

```c++
template <class T> 
    void Tree<T>::
LevelOrder(void (*visit) (BinTreeNode<T> *t) ) {
    //按广度优先次序分层遍历树, 树的根结点是
    //当前指针current。   
    Queue<TreeNode<T>*> Q;
    TreeNode<T> *p;
    if (current != NULL) { 	      //树不空 
        p = current;                             //保存当前指针
        Q.EnQueue (current);             //根结点进队列
        while (!Q.IsEmpty ()) {
            Q.DeQueue (current);        //退出队列
            visit (current);                    //访问之
            current = current->firstChild;
            while (current != NULL) { 
                Q.EnQueue (current);
                current = current->nextSibling;
            }
        }
        current = p;	  //恢复算法开始的当前指针
    }
};

```


#### 森林与二叉树的转换

- 使用**子女-兄弟表示**存储树可以将树转化二叉树

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104133118713.png" alt="image-20231104133118713" style="zoom:50%;" />
- 森林转化为二叉树
  - 二叉树B的根是F第一棵树$T_1$的根
  - 左子树为$B(T_{11},\dots,T_{1m})$即$T_1$的根的子树
  - 右子树为$B(T_2,\dots,T_n)$即除$T_1$外其他树构成的森林
- 二叉树转化为森林
  - $F$中第一颗树$T_1$的根为$B$的根
  - $T_1$的根的子树森林${T_{11},\dots,T_{1m}}$是由B的根的左子树$LB$转化而来
  - $F$中除了$T_1$之外其余的树组成的森林${T_2,T_3,\dots,T_n}$是由$B$的根的右子树$RB$转换而成的森林

#### 森林的遍历

- 森林的先根次序遍历
  - 先根遍历森林的**第一棵子树森林**，然后再遍历森林中除第一棵树外**其他树组成的森林**
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104135109737.png" alt="image-20231104135109737" style="zoom: 33%;" />
- 森林的后根次序遍历
  - 先访问第一棵子树的根结点的**子树森林**，然后访问森林的**根结点**$r_1$,然后再遍历森林中除第一棵树外其**他树组成的森林**
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104135531229.png" alt="image-20231104135531229" style="zoom:33%;" />
- 森林的广度优先遍历
  - 先遍历**各棵树**的**根节点**
  - 遍历各棵树根结点的所有子女
  - 逐层向下进行遍历
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104135726455.png" alt="image-20231104135726455" style="zoom:33%;" />

### 堆

- 每次出队列的是优先权最高的元素。

- 完全二叉树，并且父节点与子节点有确定的大小关系

- 下标从**0**开始时结点间的序号关系

  - 父节点$\lfloor (i-1)/2\rfloor$
  - 左右子女$2i+1,2i+2$

- 最小堆示例


```c++
template <class E>
    class MinHeap : public MinPQ<E> {
        //最小堆继承了（最小）优先级队列
        public: 
        MinHeap (int sz = DefaultSize);	//构造函数
        MinHeap (E arr[], int n);		//构造函数
        ～MinHeap() { delete [ ] heap; }	//析构函数
        bool Insert (E& x);			//插入
        bool Remove (E& x);			//删除
        bool IsEmpty () const		//判堆空否
        { return  currentSize == 0; }
        bool IsFull () const		//判堆满否
        { return currentSize == maxHeapSize; }	
        void MakeEmpty () { currentSize = 0; }	//置空堆
        private: 
        E *heap;			//最小堆元素存储数组
        int currentSize;		//最小堆当前元素个数
        int maxHeapSize;	//最小堆最大容量
        void siftDown (int start, int m);	//调整算法
        void siftUp (int start);		          //调整算法
    };
template <class E>
    MinHeap<E>::MinHeap (int sz) {
        maxHeapSize = (DefaultSize < sz) ? 
            sz : DefaultSize;
        heap = new E[maxHeapSize];  	//创建堆空间
        if (heap == NULL) {
            cerr << “堆存储分配失败！” << endl;  exit(1);
        }
        currentSize = 0;				//建立当前大小
    };
template <class E>
    MinHeap<E>::MinHeap (E arr[], int n) {
        maxHeapSize = (DefaultSize < n) ? n : DefaultSize;
        heap = new E[maxHeapSize]; 
        if (heap == NULL) {
            cerr << “堆存储分配失败！” << endl;  exit(1);
        }
        for (int i = 0; i < n; i++) heap[i] = arr[i];
        currentSize = n;	       //复制堆数组, 建立当前大小
        int currentPos = (currentSize-2)/2;	
        //找最初调整位置:最后分支结点
        while (currentPos >= 0) {	    //逐步向上扩大堆
            siftDown (currentPos, currentSize-1);
            //局部自上向下下滑调整
            currentPos--;
        }					
    };
template <class E>
    void MinHeap<E>::siftDown (int start, int m ) {
        //私有函数: 从结点start开始到m为止, 自上向下比较, 
        //如果子女的值小于父结点的值,  则关键码小的上浮, 
        //继续向下层比较, 将一个集合局部调整为最小堆。
        int i = start,   j = 2*i+1;  	//j是i的左子女位置
        E temp = heap[i]; 			
        while (j <= m) {			//检查是否到最后位置
            if ( j < m && heap[j] > heap[j+1] ) j++;
            //让j指向两子女中的小者
            if ( temp <= heap[j] ) break;	//小则不做调整
            else { heap[i] = heap[j];  i = j; j = 2*j+1; }
            //否则小者上移, i, j下降
        }
        heap[i] = temp;	      	//回放temp中暂存的元素
    };
template <class E>
    void MinHeap<E>::siftUp (int start) {
        //私有函数: 从结点start开始到结点0为止, 自下向上
        //比较, 如果子女的值小于父结点的值, 则相互交换, 
        //这样将集合重新调整为最小堆。关键码比较符<=
        //在E中定义。
        int j = start,  i = (j-1)/2;   E temp = heap[j];
        while (j > 0) {		//沿父结点路径向上直达根
            if (heap[i] <= temp) break;							//父结点值小, 不调整
            else { heap[j] = heap[i];  j = i;  i = (i-1)/2; }
            //父结点结点值大, 调整
        }	
        heap[j] = temp;				//回送
    };
template <class E>
    bool MinHeap<E>::Insert (const E& x )  {
        //公共函数: 将x插入到最小堆中
        if ( currentSize == maxHeapSize ) 	//堆满
        { cerr << "Heap Full" << endl;  return false; }
        heap[currentSize] = x;  		//插入
        siftUp (currentSize);			//向上调整
        currentSize++;				//堆计数加1
        return true;
    };
template <class E>
    bool MinHeap<E>::Remove (E& x) {
        if ( !currentSize ) {		//堆空, 返回false
            cout << "Heap empty" << endl;  return false;
        }
        x = heap[0];  
        heap[0] = heap[currentSize-1];
        currentSize--;
        siftDown(0, currentSize-1);    	//自上向下调整为堆
        return true;			//返回最小元素
    };
```

- **上浮操作通常在插入新元素到堆中时使用**。当一个新元素被添加到**堆的末尾时**，它可能会破坏堆的性质。为了修复这个性质，我们需要将这个元素向上移动到合适的位置，以恢复堆的性质。
- **下沉操作用在删除堆顶元素或者调整堆中某个元素的值时**。在删除**堆顶元素后**，通常将堆的最后一个元素移动到堆顶，这样会破坏堆的性质。为了修复这个性质，需要将这个元素向下移动到合适的位置
- 修改元素
  - 如果在最大堆中增加了一个元素的值，或者在最小堆中减少了一个元素的值，这个元素可能会违反堆的性质，因为它可能变得比其父节点大（最大堆）或小（最小堆）。在这种情况下，**需要进行上浮操作。**
  - 如果在最大堆中减少了一个元素的值，或者在最小堆中增加了一个元素的值，这个元素可能会违反堆的性质，因为它可能变得比其孩子节点小（最大堆）或大（最小堆）。在这种情况下，**需要进行下沉操作。**

### Huffman树

- 带权路径长度达到最小的扩充二叉树

#### 路径长度

- ZI路径长度PL：连接两结点的路径上的分支数
- 内部路径长度IPL：各**非叶节点**到根节点的路径长度之和
- 外部路径长度EPL：各**叶节点**到根节点的路径长度之和
- $PL=EPL+IPL$
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104142019640.png" alt="image-20231104142019640" style="zoom: 33%;" />
- **完全二叉树路径长度最小**，有$PL=\sum^n_{i=1}\lfloor\log_2i\rfloor$

##### 带权路径长度WPL

- 把**叶结点看成“外结点”**，**非叶结点看成“内结点”**。这样的二叉树称为相应权值的**扩充二叉树**。
- 扩充二叉树中**只有度为 2 的内结点和度为 0的外结点**。根据二叉树的性质，**有 n 个外结点就有 n-1 个内结点，总结点数为2n-1。**
- $WPL=\sum_{i=1}^1w_i*l_i$(权值乘以路径长度)
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104142729316.png" alt="image-20231104142729316" style="zoom: 33%;" />

#### Huffman树构造方式

- 初始状态：给定n个权值${w_0,w_1,\cdots,w_{n-1}}$构造有n棵扩充二叉树的森林$F={T_0,\cdots,T_{n-1}}$，每颗子树都只有一个带特定权值的根节点，左右子树为空

- 重复以下，直至剩下一棵树：

  - 选择两颗根节点权值最小的扩充二叉树，作为左右子树构造新二叉树，新二叉树根节点的权值为左右子树上根节点的权值之和
  - 在F中删去两颗二叉树并把新的加入F


```c++
#include "heap.h"
const int DefaultSize = 20; // 缺省权值集合大小
template <class E>
struct HuffmanNode
{           // 树结点的类定义
    E data; // 结点数据
    HuffmanNode<E> *parent;
    HuffmanNode<E> *leftChild, *rightChild; // 左、右子女和父结点指针
    HuffmanNode() : parent(NULL), leftChild(NULL),
                    rightChild(NULL) {} // 构造函数
    HuffmanNode(E elem,                 // 构造函数
                HuffmanNode<E> *pr = NULL,
                HuffmanNode<E> *left = NULL,
                HuffmanNode<E> *right = NULL)
        : data(elem), parent(pr), leftChild(left),
          rightChild(right){}
};
template <class E>
class HuffmanTree
{ // Huffman树类定义
public:
    HuffmanTree(E w[], int n);           // 构造函数
    ~HuffmanTree() { deleteTree(root); } // 析构函数
protected:
    HuffmanNode<E> *root;               // 树的根
    void deleteTree(HuffmanNode<E> *t); // 删除以 t 为根的子树
    void mergeTree(HuffmanNode<E> &ht1, HuffmanNode<E> &ht2,
                   HuffmanNode<E> *&parent);
};
template <class E>
HuffmanTree<E>::HuffmanTree(E w[], int n)
{
    // 给出 n 个权值w[0]～w[n-1], 构造Huffman树
    minHeap<E> hp; // 使用最小堆存放森林
    HuffmanNode<E> *parent, &first, &second;
    HuffmanNode<E> *NodeList =
        new HuffmanNode<E>[n]; // 森林
    for (int i = 0; i < n; i++)
    {
        NodeList[i].data = w[i];
        NodeList[i].leftChild = NULL;
        NodeList[i].rightChild = NULL;
        NodeList[i].parent = NULL;
        hp.Insert(NodeList[i]); // 插入最小堆中
    }
    for (i = 0; i < n - 1; i++)
    {                                     // n-1趟, 建Huffman树
        hp.Remove(first);                 // 根权值最小的树
        hp.Remove(second);                // 根权值次小的树
        mergeTree(first, second, parent); // 合并
        hp.Insert(*parent);               // 重新插入堆中
    }
    root = parent; // 建立根结点
};
template <class E>
void HuffmanTree<E>::
    mergeTree(HuffmanNode<E> &bt1,
              HuffmanNode<E> &bt2,
              HuffmanNode<E> *&parent)
{
    parent = new HuffmanNode<E>;
    parent->leftChild = &bt1;
    parent->rightChild = &bt2;
    parent->data.key =
        bt1.root->data.key + bt2.root->data.key;
    bt1.root->parent = bt2.root->parent = parent;
};
```

- Huffman编码

  - 根据字符出现频率决定对字符的编码，使用变长二进制编码
  - 总编码长度就是表示报文中全部字母需要的二进制位的数目，**就是Huffman树的带权路径长度WPL**
  - **CAST** **CAST** **SAT AT A TASA**
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102114616906.png" alt="image-20231102114616906" style="zoom:50%;" />

## 集合与字典

### 集合

- 集合是成员的一个集群，集合中的成员可以是原子（单元素），也可以是集合；集合的成员**必须互不相同**，并具有**相同的数据类型**。
- 集合中的成员一般是**无序**的，但在表示时写在一个序列里有一个**线性有序关系**
  - 如果是完全无序，会给合并、查找等操作带来很大的麻烦

#### 使用位向量实现集合

- 当集合是${0,1,2,\dots,n}$的一个子集并且 $n$ 不是很大时使用 $(0,1)$ 表示元素是否在集合中（状态压缩）


```c++
#include <assert.h>
#include <iostream.h>
const int DefaultSize = 50;
template <class T>
    class bitSet {
        //用位向量来存储集合元素, 集合元素的范围在0到
        //setSize-1之间。数组采用16位无符号短整数实现
        public:
        bitSet (int sz = DefaultSize);	//构造函数
        bitSet (const bitSet<T>& R);	//复制构造函数
        ～bitSet () { delete [ ]bitVector; }	//析构函数
        unsigned short getMember (const T x);  //读取集合元素x
        void putMember (const T x, unsigned short v);  //将值v送入集合元素x
        void makeEmpty () { 			//置空集合
            for (int i = 0; i < vectorSize; i++)
                bitVector[i] = 0;
        }
        bool addMember (const T x);	//加入新成员x
        bool delMember (const T x);	//删除老成员x
        bitSet<T>&  operator = (const bitSet<T>& R);
        bitSet<T>&  operator + (const bitSet<T>& R);
        bitSet<T>&  operator * (const bitSet<T>& R);
        bitSet<T>&  operator - (const bitSet<T>& R);
        bool Contains (const T x);						                      //判x是否集合this的成员
        bool subSet (bitSet<T>& R);   //判this是否R的子集
        bool operator == (bitSet<T>& R);				   			   //判集合this与R相等
        friend istream& operator >> (istream& in,  
                                     bitSet<T>& R);		   //输入
        friend ostream& operator << (ostream& out, 
                                     bitSet<T>& R);		   //输出
        private:
        int setSize;		//集合大小
        int vectorSize;		//位数组大小
        unsigned short *bitVector;						                    //存储集合元素的位数组
    };

template <class T>
    bitSet<T>::bitSet (int sz) : setSize (sz) {    //构造函数
        assert (setSize > 0);		   //检查参数的合理性
        vectorSize = (setSize+15) >> 4;	//存储数组大小
        bitVector = new unsigned short[vectorSize];	//分配空间
        assert (bitVector != NULL);						//检查存储分配是否成功
        for (int i = 0; i < vectorSize; i++)
            bitVector[i] = 0;			//初始化
    };

template<class T>
    unsigned short bitSet<T>:: getMember (const T x) {//读取集合元素x，x从0开始
        int ad = x/16;  
        int id = x%16;
        unsigned short elem = bitVector[ad];
        return ((elem >> (15 - id)) %2);
    };

template<class T>
    void bitSet<T>:: putMember (const T x, unsigned short v) {  //将值v送入集合元素x
        int ad = x/16;  
        int id = x%16;
        unsigned short elem = bitVector[ad];
        unsigned short temp = elem >> (15-id);
        elem = elem << (id+1);
        if (temp%2==0 && v ==1) temp = temp +1;
        else if (temp%2==1 && v==0) temp = temp -1;
        bitVector[ad] = (temp<<(15-id)) | (elem >> (id+1));
    };

template<class T>
    bitSet<T>&  bitSet<T>::          //求集合this与R的并
operator + (const bitSet<T>& R) {
    assert (vectorSize == R.vectorSize); 
    bitSet temp (vectorSize);

    for (int i = 0; i < vectorSize; i++)
        temp.bitVector[i] = bitVector[i] | R.bitVector[i];

    return temp;  //按位求"或", 由第三个集合返回
};

template <class T>
    bitSet<T>&  bitSet<T>::              //求集合this与R的交
operator * (const bitSet<T>& R) {	
    assert (vectorSize == R.vectorSize);
    bitSet temp (setSize);

    for (int i = 0; i < vectorSize; i++)
        temp.bitVector[i] = bitVector[i] & R.bitVector[i];

    return temp;  //按位求“与”, 由temp返回
};

template <class T>
    bitSet<T>&  bitSet<T>::		//求集合this与R的差
operator - (const bitSet<T>& R) {	
    assert (vectorSize == R.vectorSize); 
    bitSet temp (setSize);
    for (int i = 0; i < vectorSize; i++)
        temp.bitVector[i] =  bitVector[i] & (~R.bitVector[i]);

    return temp;			//由第三个集合返回
};

template <class T>
bool bitSet<T>::subSet (bitSet<T>& R) {
//判this是否R的子集（即是否存在一位this中为1R中为0）
     assert (setSize == R.setSize);
     for (int i = 0; i < vectorSize; i++)   //按位判断
          if (bitVector[i] & (~R.bitVector[i])) return false;

	return true;	
};

```

#### 使用链表实现集合

- 使用有序链表表示集合，链表中的每个结点表示集合的一个成员

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231109233325590.png" alt="image-20231109233325590" style="zoom:33%;" />


```c++
template <class T>
    struct SetNode {		//集合的结点类定义
        T data;			//每个成员的数据
        SetNode<T> *link;	//链接指针
        SetNode() : link (NULL);		//构造函数
        SetNode (const T& x, SetNode<T> *next = NULL) 
            : data (x), link (next);		//构造函数
    };
template <class T>
    class LinkedSet {		//集合的类定义
        private:
        SetNode<T> *first, *last;      //有序链表表头指针, 表尾指针				
        public:
        LinkedSet () { first = last = new SetNode<T>; }	
        LinkedSet (LinkedSet<T>& R);	//复制构造函数 
        ～LinkedSet () { makeEmpty();  delete first; }	
        void makeEmpty();			//置空集合
        bool addMember (const T& x);
        bool delMember (const T& x);
        LinkedSet<T>& operator = (LinkedSet<T>& R);
        LinkedSet<T>& operator + (LinkedSet<T>& R);
        LinkedSet<T>& operator * (LinkedSet<T>& R);
        LinkedSet<T>& operator - (LinkedSet<T>& R);
        bool Contains (const T x);	//判x是否集合的成员
        bool operator == (LinkedSet<T>& R);							//判集合this与R相等
        bool Min (T& x);	//返回集合最小元素的值
        bool Max (T& x);	//返回集合最大元素的值
        bool subSet (LinkedSet<T >& R);						  	//判this是否R的子集
    };

template <class T>
    LinkedSet<T>&  LinkedSet<T>::
operator + (LinkedSet<T>& R) {
    //求集合this与集合R的并
    SetNode<T> *pb = R.first->link;	//R扫描指针
    SetNode<T> *pa = first->link;	//this扫描指针
    LinkedSet<T> temp;			//创建空链表
    SetNode<T> *p, *pc = temp.first;	//结果存放指针
    while (pa != NULL && pb != NULL) {
        if (pa->data == pb->data) {	//两集合共有
            pc->link = new SetNode<T>(pa->data);
            pa = pa->link;  pb = pb->link;
        }
        else if (pa->data < pb->data) {	//this元素值小
            pc->link = new SetNode<T>(pa->data);
            pa = pa->link;
        }
        else {			//R集合元素值小
            pc->link = new SetNode<T>(pb->data);
            pb = pb->link;
        }
        pc = pc->link;
    }
    if (pa != NULL) p = pa;	//this集合未扫完
    else p = pb;			//或R集合未扫完
    while (p != NULL) {		//向结果链逐个复制
        pc->link = new SetNode<T>(p->data);
        pc = pc->link;  p = p->link;
    }
    pc->link = NULL;  temp.last = pc;        //链表收尾
    return temp;
}；

```

### 等价类与并查集

- 等价类具有：自反性、对称性、传递性
- 确定等价类的过程
  - 读入并存储等价对
  - 标记和输出
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231109233945417.png" alt="image-20231109233945417" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231109233952530.png" alt="image-20231109233952530" style="zoom:33%;" />

- 三种操作：合并、查找、构造函数
- 并查集使用**树的双亲表示**存储
- 非根结点的下标对应元素表示父元素，根节点为 $-k$ 表示**集合中的元素个数**（初始时都初始化为-1）
  - 注意使用这种方法时
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231109234451925.png" alt="image-20231109234451925" style="zoom:33%;" />


```c++
const int DefaultSize = 10;
class UFSets {	//集合中的各个子集合互不相交
    public:
    UFSets (int sz = DefaultSize);	//构造函数
    ～UFSets() { delete []parent; }	//析构函数
    UFSets& operator = (UFSets& R);    //集合赋值
    void Union (int Root1, int Root2);	     //子集合并
    int Find (int x);				//查找x的根
    void WeightedUnion (int Root1, int Root2);
    //改进例程:加权的合并算法
    private:
    int *parent;		  //集合元素数组(双亲表示)
    int size;			  //集合元素的数目
};

UFSets::UFSets (int sz) {	
    //构造函数：sz 是集合元素个数，双亲数组的范围
    //为parent[0]～parent[size-1]。
    size = sz;			  //集合元素个数
    parent = new int[size];  //创建双亲数组
    for (int i = 0; i < size; i++) parent[i] = -1;	  
    //每个自成单元素集合
}; 
//朴素方式
int UFSets::Find (int x) {
    //函数搜索并返回包含元素x的树的根。
    if (parent[x] < 0) return x;   //根的parent[]值小于0  (值小于0表示是根，直接用下标，而不是负数，负数表示的是数目，不是唯一标识)
    else return (Find (parent[x]));
};
void UFSets::Union (int Root1, int Root2) {
    //求两个不相交集合Root1与Root2的并
    parent[Root1] += parent[Root2];
    parent[Root2] = Root1;
    /将Root2连接到Root1下面
};
//按秩和并、路径压缩
void UFSets :: 
WeightedUnion (int Root1, int Root2) {
    //按Union的加权规则改进的算法
    int temp = parent[Root1] + parent[Root2];
    if (parent[Root2] < parent[Root1]) {
        parent[Root1] = Root2;     //Root2中结点数多
        parent[Root2] = temp;      //Root1指向Root2
    }
    else {  
        parent[Root2] = Root1;    //Root1中结点数多
        parent[Root1] = temp;      //Root2指向Root1
    }
};
int UFSets::Find (int x) {
    //函数搜索并返回包含元素x的树的根。
    if (parent[x] < 0) return x;
    else{
        parent[x] = Find (parent[x])
    	return parent[x]；
    }
};
```

### 字典

- 字典是元素的集合，每个元素有一个称作关键码（key）的域，不同元素的关键码不同；<名字-属性>

#### 字典的线性表描述

- 字典保存在线性序列中，关键码从左到右依次增大，可以使用有序顺序表或有序链表

- 有序顺序表


```c++
#include <iostream.h>
#include “SeqList.h”
const int defaultSize = 50;
template <class K, class E> 
    class SortedList : public SeqList {
        public:
        int Search (K k1) const;			     //搜索
        void Insert (const K k1, E& e1);	     //插入
        bool Remove (const K k1, E& e1);	     //删除
    };
template <class K, class E> 
    int SortedList<K, E>::Search (K k1) const {
        //顺序搜索关键码为k1的数据对象
        int n = last+1;
        for (int i = 1;  i <= n;  i++)
            if (data[i-1] == k1) return i;         //成功
        else if (data[i-1] > k1) break;
        return 0;       //顺序搜索失败, 返回失败信息
    };//因为键是从小到达排列，因此大于了就表示查找失败
```

- 衡量一个搜索算法的时间效率的标准是：在搜索过程中**关键码平均比较次数**，也称为**平均搜索长度ASL**。搜索第 $i$ 个元素的概率为 $p_i$ ，搜索到时所需的比较次数为 $c_i$ ，搜索成功的平均搜索长度 $ASL_{succ}=\sum_{i=1}^{n}p_i\cdot{c_i}$

- 本实现中成功查找的平均比较次数为$\frac1n\frac{(n+1)n}2=\frac{n+1}2$

- 搜索不成功时不需一直比较到表尾，只要发现下一个元素的值比给定值大，就可断定搜索不成功

- 使用判定树描述顺序查找

  - 搜索成功时停在内结点，搜索失败时停在外结点
  - 判定树是一种**扩充二叉树**。内结点代表顺序表中**已有的元素**，外结点代表**失败结点**，它表示在两个**相邻已有元素值之间的值**。
  - $ASL_{unsucc}=\frac1{n+1}(\sum^n_{i=1}i+n)$
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110001215892.png" alt="image-20231110001215892" style="zoom:50%;" />

- 使用判定树描述折半查找

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110001625405.png" alt="image-20231110001625405" style="zoom:33%;" />

- 有序链表


```c++
#include <assert.h>
template <class K, class E>
    struct ChainNode {		//链表结点类定义
        K key;
        E attr;
        ChainNode<K, E> *link;
        ChainNode() : link (NULL) { };	 //构造函数
        ChainNode (K k1, E& e1,                      //构造函数
        ChainNode<K,E> *next = NULL): key (k1), attr (e1), link (next) { };
    };
template <class K, class E>
    class SortedChain {		//有序链表类定义
        public:
        SortedChain () {		//构造函数
            first = new ChainNode<K, E>;
            assert (first != NULL);
        };
        ～SortedChain ();		//析构函数
        ChainNode<K, E> *Search (K k1);    	     //搜索
        void Insert (const K k1, E& e1);		     //插入
        bool Remove (const K k1, E& e1);	     //删除  
        ChainNode<K, E> *Begin () { return first->link; }	                                         //定位第一个
        ChainNode<K, E> *Next (ChainNode<K, E> 
                               *current) const {	//定位下一个
            if (current != NULL) return current->link;
            else return NULL;
        }
        private:
        ChainNode<K, E> *first;	//链表的头指针
    };

template <class K, class E>
    ChainNode<K, E> *SortedChain<T>::
Search (K k1) const {
    ChainNode<K, E> *p = first->link;
    while (p != NULL && p->key< k1) 
        p = p->link;		      //重载：元素判小于
    if ( p != NULL && p->key== k1) return p;			                          //重载：元素判等于
    else return NULL;
};

template <class K, class E>
    void SortedChain<K, E>::
Insert (const K k1,  E& e1) {
    ChainNode<K, E> *p = first->link, *pre = first；   
        ChainNode<K, E> *newNode;
    while (p != NULL && p->key<= k1)				       //重载：元素判小于等于
    { pre = p;  p = p->link; }	     //寻找插入位置
    if (p != NULL && p->key== k1) p->attr= e1;     
    else {
        newNode = new ChainNode<K, E>(k1,e1);
        if (newNode == NULL) {        
            cerr << “存储分配失败！” << endl;
            exit (1); 
        }
        newNode->link = p;   pre->link = newNode; 
    }
};

template <class K, class E>
    bool SortedChain<K, E>::Remove (const K k1,  E& e1) { 
        ChainNode<K, E> *p = first->link, *pre = first；
            while (p != NULL && p->key< k1) 
            { pre = p;  p = p->link; }	        //寻找删除位置
        if (p != NULL && p->key== k1) {				            //重载：元素关键码判等于
            pre->link = p->link;
            e1 = p->attr;  
            delete p;
            return true;
        }
        else return false;		      //未找到删除结点
    };

```

### 散列表

- 在元素存储位置与其关键码之间建立一个确定的对应函数关系Hash()， 使得每个关键码与唯一的存储位置相对应`Address ＝ Hash(key)`
- 在插入时依此函数计算存储位置并**按此位置存放**。在搜索时对元素的关键码进行同样的计算，把求得的函数值当做元素存储位置，然后按此位置搜索。这就是散列方法
- 称这些产生冲突的散列地址相同的不同关键码为同义词。

#### 散列函数

- 要求
  - 散列函数应是简单的，能在较短的时间内计算出结果。
  - 散列函数的定义域必须**包括需要存储的全部关键码**，如果散列表允许有 m 个地址时，其值域必须在 0 到 m-1 之间。
  - 散列函数计算出来的地址应能**均匀分布**在整个地址空间中 : 若 key 是从关键码集合中随机抽取的一个关键码,  散列函数应能以同等概率取0 到 m-1 中的每一个值。
- 直接定址法
  - 取关键码的线性函数值为散列地址 $Hash(key)=a*key+b$
  - 这类散列函数是**一对一的映射**，一般不会产生冲突。但它要求散列地址空间的大小与关键码集合的**大小相同。**
- 数字分析法
  - 设有 n 个 d 位数,   每一位可能有 r 种不同的符号。这 r 种不同符号在各位上出现的频率不一定相同。根据散列表的大小,  **选取其中各种符号分布均匀的若干位**作为散列地址。
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110003436992.png" alt="image-20231110003436992" style="zoom:33%;" />
    - 选取 $\lambda_k$小的位
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110003530403.png" alt="image-20231110003530403" style="zoom:33%;" />
    - 应该取关键码的456位作为散列地址
  - 数字分析法仅适用于**事先明确知道表中所有关键码每一位数值的分布情况**，它完全依赖于关键码集合。如果换一个关键码集合，选择哪几位要重新决定。
- 除留余数法
  - 设散列表中允许地址数为m，取一个不大于 m，但最接近于或等于 m 的**质数 p** 作为除数 $hash(key)=key\%p \ p<=m$
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110003758347.png" alt="image-20231110003758347" style="zoom:33%;" />
  - 可按计算出的地址存放记录。注意,  **使用散列函数计算出的地址范围是 0 到 22**，而 23、24 这几个地址实际上不能用散列函数计算出来，只能在**处理冲突**时达到这些地址。
- 平方取中法
  - 首先计算构成关键码的**标识符的内码的平方**, 然后按照散列表的大小取**中间的若干位**作为散列地址。
  - 因为内码平方数的**中间几位**一般是由标识符**所有字符**决定, 所以对不同的标识符计算出的散列地址**大多不相同。**
  - 一般取散列地址为**8的某次幂**。例如, 若散列地址总数取为 m = 8^r^，则对内码的平方数取中间的 r 位。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110003954498.png" alt="image-20231110003954498" style="zoom:33%;" />
    - 使用八进制表示

- 折叠法

  - 此方法把关键码自左到右**分成位数相等的几部分**,  每一部分的位数应与散列表地址位数相同,  只有**最后一部分的位数可以短一些**。把这些部分的**数据叠加起来**,  就可以得到具有该关键码的记录的散列地址。

  - 叠加方式
    - 移位法：把各部分**最后一位对齐相加**；
    - 分界法：各部分**不折断**，沿各部分的分界**来回折叠**, 然后对齐相加。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110004306263.png" alt="image-20231110004306263" style="zoom:33%;" />
  - 一般当关键码的位数很多，而且关键码每一位上数字的分布**大致比较均匀时**，可用这种方法得到散列地址。
  - 假设地址空间为HT[**400**]，利用以上函数计算，取其中3位，取值范围在**0～999，可能超出地址空间范围**，为此必须将0～999压缩到0～399。可将计算出的地址**乘以一个压缩因子0.4**，把计算出的地址压缩到允许范围。

####  冲突处理

- 闭散列方式：线性探查法
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110005301946.png" alt="image-20231110005301946" style="zoom:33%;" />
  - 发生冲突时**顺次查找$H_i=(H_{i-1}+1)\%m,i=1,2,\dots,m-1$**
    - 注意线性探测需要**在到达数组末尾时回到数组开头**
  - 搜索成功的平均搜索长度（实际位置-散列位置+1）
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110005625170.png" alt="image-20231110005625170" style="zoom:33%;" />
  - 搜索不成功的平均搜索长度为：
    - 假设每种字母出现概率相同（这决定从什么位置开始搜索直到末尾）
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110005807834.png" alt="image-20231110005807834" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110005906375.png" alt="image-20231110005906375" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110005917223.png" alt="image-20231110005917223" style="zoom:33%;" />
  - 搜索成功的平均比对次数 $(1+1/(1-\alpha))/2$
- 开散列方式：链地址法
  - 若设散列表地址空间的位置从 0～m-1, 则关键码集合中的所有关键码被划分为 m 个子集，**具有相同地址的关键码归于同一子集**。我们称同一子集中的关键码互为同义词。**每一个子集称为一个桶。**
  - 通常各个桶中的表项通过一个**单链表链接**起来，称之为**同义词子表**。
  - 所有桶号相同的表项都链接在同一个同义词子表中，各链表的表头结点**组成一个向量**。**向量的元素个数与桶数一致**。**桶号为i**的同义词子表的表头结点是向量中第 i 个元素。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110010357022.png" alt="image-20231110010357022" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110010406307.png" alt="image-20231110010406307" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110010414230.png" alt="image-20231110010414230" style="zoom:33%;" />
  - 每个节点指向的桶，一个桶可能有多个页表（比如一个页表30条），页表之间使用链式连接，查询一个页表相当于进行一次磁盘读取
  - 搜索成功的平均比对次数 $1+\al$

## 搜索结构

- 静态环境，搜索结构在插入和删除等操作的前后不发生改变。（静态搜索表）
- 动态环境，为保持较高的搜索效率, 搜索结构在执行插入和删除等操作的前后将自动进行调整，结构可能发生变化。（动态搜索表）

### 静态搜索结构

#### 数组实现

- 数据节点键值对


```c++
#include <iostream.h>
#include <assert.h>
const int defaultSize = 100;
template <class K, class E>
    class dataList;		//数据表类的前视定义, K为关键码对应的类，E为其他属性对应的类
template <class K, class E >
    class dataNode {		//数据表中结点类的定义
        friend class dataList<K, E>;						              //声明其友元类为dataList
        public:
        dataNode (const K x, const E e) : key(x), other(e) { }	    //构造函数
        K getKey() const { return key; }	    //读取关键码
        void setKey (K x) { key = x; }	    //修改关键码
        private:
        K key;			//关键码域  
        E other;		          //其他域（视问题而定）
    }; 

```

```c++
template <class K, class E >
    class dataList {		//数据表类定义
        public:
        dataList (int sz = defaultSize) 
            : ArraySize(sz), CurrentSize(0) {
                Element = new dataNode<K, E>[sz];   
                assert (Element != NULL);
            }
        dataList (dataList<K, E>& R);   //复制构造函数
        virtual ～dataList() { delete []Element; }	 //析构函数
        virtual int Length() { return CurrentSize; }	
        //求表的长度
        virtual K getKey (int i) const { 				                           //提取第 i个（从1开始）元素的key值 
            assert (i > 0 & i <= CurrentSize); 
            return Element[i-1].key;
        } 
        virtual void setKey (K x, int i) {				                //修改第 i个（从1开始）元素的key值
            assert (i > 0 & i <= CurrentSize);
            Element[i-1].key = x;
        }	
        virtual int SeqSearch (const K x) const;	    //搜索
        virtual bool Insert (K x , E e1);	    	    //插入
        virtual bool Remove (K x, E& e1);	    //删除
        friend ostream& operator << (ostream& out, 
                                     const dataList<K, E>& OutList);             //输出
        friend istream& operator >> (istream& in,dataList<K, E>& InList);                        //输入
        protected:
        dataNode<K, E> *Element;	   //数据表存储数组
        int ArraySize, CurrentSize;					                            //数组最大长度和当前长度
    };

template <class K, class E>
    bool dataList<K, E>::Insert (K k, E e1) {
        //在dataList的尾部插入新元素, 若插入失败,函数返
        //回false, 否则返回true.
        if (CurrentSize == ArraySize) return false;
        dataNode<K, E>  node =  dataNode<K, E> (k,e1);
        Element[CurrentSize] = node; //插入在尾端
        CurrentSize++;  return true;
    };

template <class K, class E>
    bool dataList<K, E>::Remove (K x, E& e1) {
        //在dataList中删除关键码为x的元素, 通过e1返回。
        //用尾元素填补被删除元素。
        if (CurrentSize == 0) return false;
        for (int i == 0; i < CurrentSize && 
             Element[i].key != x; i++)  //在表中顺序寻找
            if (i == CurrentSize) return false;	         //未找到
        e1 = Element[i].other;	     //找到,保存被删元素的值
        Element[i] = Element[CurrentSize-1];    //填补
        CurrentSize--;  return true;
    };

```

##### 顺序搜索

- **监视哨**：设在数据表 dataList 中顺序搜索关键码与 给定值 x 相等的数据元素，要求数据元素在表中从下标 0 开始存放, 下标为 CurrentSize 的元素作为控制搜索过程**自动结束**的“监视哨”使用。若搜索失败，则函数返回 CurrentSize+1。


```c++
template <class K, class E>
int dataList<K, E>::SeqSearch (const K x) const {
     Element[CurrentSize].key = x;
	 int i = 0;		                    //将x设置为监视哨
     while (Element[i].key != x) i++;//这个循环中进行比对（即对目标的搜索）				                                        //从前向后顺序搜索
     return i+1;
};
```

- 平均比对次数

  - 设表中 $n$ 个元素，搜索到第 $i$ 个元素的概率为 $p_i$ ，平均比较次数为 $c_i$ ，则搜索成功的平均搜索长度 $ASL_{succ}=\sum^n_{i=1}p_i\cdot c_i$
  - 对于顺序搜索 $ASL——{succ} = \sum^n_{i=1}p_i\cdot i=\sum^n_{i=1}\frac1n\cdot i=\frac{n+1}2$
  - 搜索不成功 $ASL_{unsucc}=n+1$

- 有序顺序表的折半查找

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124111014885.png" alt="image-20231124111014885" style="zoom:50%;" />



### 二叉搜索树

- 定义：二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树

  - 每个结点都有一个作为搜索依据的关键码(key)，所有结点的**关键码互不相同**。
  - 左子树（如果非空）上所有结点的关键码都**小于**根结点的关键码。
  - 右子树（如果非空）上所有结点的关键码都**大于**根结点的关键码。
  - 左子树和右子树也是二叉搜索树。

- **中序遍历**可以得到从小到达的排序

- 结构定义


```c++
#include <iostream.h>
#include <stdlib.h>
template <class K, class E>
    struct BSTNode  {			    //二叉树结点类
        K key;                                             // 关键码
        E data;			 //除关键码外的其他数据域
        BSTNode<K, E> *left, *right;  //左子女和右子
        BSTNode() { left = NULL; right = NULL; }   //构造函数

        BSTNode (const K k1, const E x, BSTNode<K, E> *L = NULL,  BSTNode<K, E> *R = NULL) { 
            key = k1; data = x; left = L; right = R;
        }  //构造函数
        ～BSTNode() {}				//析构函数
        void setData (K k1, E x) { key = k1; data = x; }	//修改	
        E getData() { return data; }		//提取
        bool operator < (const BSTNode  & x) //判小于
        { return key < x.key; } 
        bool operator > (const BSTNode  & x) 	//判大于
        { return key > x.key; }
        bool operator == (const BSTNode  & x) 	//判等于
        { return key == x.key; }
    };  
template <class K, class E>
    class BST {				  //二叉搜索树类定义
        public:
        BST() { root = NULL; }	  //构造函数
        BST(K value);			  //构造函数
        ～BST() {};			  //析构函数	
        bool Search (const K x) const	//搜索 
        { return Search(x,root) != NULL; }
        BST<K, E>& operator = (const BST<K, E>& R);		     				//重载：赋值
        void makeEmpty() 			//置空
        { makeEmpty (root); root = NULL;}
        void PrintTree() const { PrintTree (root); }    //输出
        E Min() { return Min(root)->data; }	 //求最小

        E Max() { return Max(root)->data; }	 //求最大

        bool Insert (const E& e1)                //插入新元素
        { return Insert(e1, root);}

        bool Remove (const K x) { return Remove(x, root);} 	  //删除含x的结点
        private: 
        BSTNode<K, E> *root;	//根指针
        K RefValue;	 		//输入停止标志
        BSTNode<K, E> * 		//递归：搜索
            Search (const K x, BSTNode<K, E> *ptr);
        void makeEmpty (BSTNode<K, E> *& ptr);						//递归：置空
        void PrintTree (BSTNode<K, E> *ptr) const;						//递归：打印
        BSTNode<K, E> *		//递归：复制
            Copy (const BSTNode<K, E> *ptr);		
        BSTNode<K, E>* Min (BSTNode<K, E>* ptr);						//递归：求最小
        BSTNode<K, E>* Max (BSTNode<K, E>* ptr);					//递归：求最大
        bool Insert (const K k1, const E& e1, BSTNode<K, E>*& ptr);		//递归：插入
        bool Remove (const K x, BSTNode<K, E>*& ptr);					//递归：删除
    };
```

- 搜索


```c++
template<class K, class E>
BSTNode<K, E>* BST<K, E>::
Search (const K x, BSTNode<K, E> *ptr) {
//私有递归函数：在以ptr为根的二叉搜索树中搜
//索含x的结点。若找到，则函数返回该结点的
//地址，否则函数返回NULL值。
    if (ptr == NULL) return NULL; 
    else if (x < ptr->key) return Search(x, ptr->left);
    else if (x > ptr->key) return Search(x, ptr->right);
    else return ptr;				//搜索成功
};

//非递归版本
template<class K, class E>
    BSTNode<K, E>* BST<K, E>::
Search (const K x, BSTNode<K, E> *ptr) {
    //叉搜索树中搜索含x的结点。若找到，则函数返
    //回该结点的地址，否则函数返回NULL值。
    if (ptr == NULL) return NULL; 
    BSTNode<K, E>* temp = ptr;
    while (temp != NULL) {
        if (x == temp->key) return temp;
        if (x < temp->key) temp = temp->left;
        else temp = temp->right;
    }
    return NULL;
};
```

- 插入


```c++
template <class K, class E>
    bool BST<K, E>::Insert (const K k1, const E& e1, BSTNode<K, E> *& ptr) {	   
        //私有函数：在以ptr为根的二叉搜索树中插入值为
        //<k1,e1>的结点。若在树中已有含<k1,e1>的结点则不插入
        if (ptr == NULL) {	   //新结点作为叶结点插入
            ptr = new BSTNode<K, E>(k1,e1); //创建新结点
            if (ptr == NULL)
            { cerr << "Out of space" << endl;  exit(1); }
            return true;
        }
        else if (k1 < ptr->key) Insert (k1,e1, ptr->left);	 	//左子树插入
        else if (k1 > ptr->key) Insert (k1,e1, ptr->right);		//右子树插入
        else return false;	      //已在树中,不再插入
    };

```

- 为了向二叉搜索树中插入一个新元素，必须先检查这个元素是否在树中已经存在。即要先进行一次搜索，搜索成功测说明**不需要再插入**，搜索不成功则说明要将将新元素插入到**操作停止的位置**

- 利用二叉树的插入算法来建立二叉树

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124112504803.png" alt="image-20231124112504803" style="zoom:50%;" />

- 删除维护

  - 删除叶结点，只需将其双亲结点指向它的指针清零，再释放它即可。
    
  - 被删结点右子树为空，可以拿它的左子女结点顶替它的位置，再释放它。
    
  - 被删结点左子树为空，可以拿它的右子女结点顶替它的位置，再释放它。
    
  - 被删结点左、右子树都不为空，可以在它的**右子树中**寻找中序下的第一个结点(关键码最小),(左子树最后一个即)用它的值填补到被删结点中，再来处理这个结点的删除问题。
    
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124121813205.png" alt="image-20231124121813205" style="zoom:33%;" />
    

```c++
template <class K, class E>
    bool BST<K, E>::Remove (const K x, 
                            BSTNode<K, E> *& ptr) {
        //在以 ptr 为根的二叉搜索树中删除含 x 的结点
        BSTNode<K, E> *temp;
        if (ptr != NULL) {//为null表示不存在
            if (x < ptr->key) Remove (x, ptr->left);	
            //在左子树中执行删除
            else if (x > ptr->key) Remove (x, ptr->right);
            //在右子树中执行删除（找到目标了）
            else if (ptr->left != NULL && ptr->right != NULL)
            {       //ptr指示关键码为x的结点，它有两个子女
                temp = ptr->right;  
                //到右子树搜寻中序下第一个结点
                while (temp->left != NULL) 
                    temp = temp->left;
                ptr->key = temp->key;
                ptr->data = temp->data;
                //用该结点数据代替根结点数据（从右子出发去删除这个换上来的点）
                Remove (ptr->key, ptr->right);
            }
            //至少一个为空
            else {	//ptr指示关键码为x的结点有一个子女
                temp = ptr;
                if (ptr->left == NULL) ptr = ptr->right;
                else ptr = ptr->left;
                delete temp;
                return true;
            }
        }
        return false;
    }; 
```

### AVL树

- AVL树是一种高度平衡的二叉树，或者是空树，或者满足左右子树都是AVL树，并且**高度差绝对值不超过1**

- 平衡因子

  - 每个节点附加一个数字，给出**右子树的高度减去左子树的高度**所得的高度差，即节点的平衡因子bf
  - 取值：-1，0，1（否则就失去了平衡不是AVL树了）

- 高度和平均搜索长度可以保持在$O(log_2n)$

  - 搜索、插入、删除一个结点并做平衡化旋转所需时间

- 基本定义


```c++
#include <iostream.h>
#include “stack.h”
template <class K, class E>
    struct AVLNode : public BSTNode<K, E> {
        //AVL树结点的类定义  
        int bf;
        AVLNode() { left = NULL; right = NULL; bf = 0; }
        AVLNode (K k, E x, AVLNode<K, E> *l = NULL,  
                 AVLNode<K, E> *r = NULL) 
        { key = k; data = x;  left = l;  right = r;  bf = 0; }
    };
template <class K, class E>
    class AVLTree : public BST<K, E> {
        //平衡的二叉搜索树（AVL）类定义
        public:
        AVLTree() { root = NULL; }		//构造函数
        AVLTree (K Ref) { RefValue = Ref; root = NULL; }
        //构造函数：构造非空AVL树
        int Height() const; //使用指针引用返回结果
        AVLNode<K, E>* Search (K x, AVLNode<K, E> *& ptr) const;	         //搜索
        bool Insert (K x, E& e1) { return Insert (root, x, e1); } //插入
        bool Remove (K x, E& e1)
        { return Remove (root, x, e1); } 	         //删除
        friend istream& operator >> (istream& in, 
                                     AVLTree<K, E>& Tree);		       //重载：输入
        friend ostream& operator << (ostream& out,
                                     const AVLTree<K, E>& Tree);        //重载：输出
        protected:
        int Height (AVLNode<K, E> *ptr) const; 
        bool Insert (AVLNode<K, E>*& ptr, K x, E& e1);
        bool Remove (AVLNode<K, E>*& ptr, K x, E& e1);
        void RotateL (AVLNode<K, E>*& ptr); 	  //左单旋
        void RotateR (AVLNode<K, E>*& ptr);	  //右单旋
        void RotateLR (AVLNode<K, E>*& ptr);		//先左后右双旋
        void RotateRL (AVLNode<K, E>*& ptr);		//先右后左双旋
    };

```

#### 平衡化旋转

- 插入或者删除后可能造成不平衡，需要通过旋转进行调整

- 左单旋转

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124135422714.png" alt="image-20231124135422714" style="zoom:50%;" />


```c++
template <class K, class E> 
void AVLTree<K, E>:://ptr会返回为新的跟
RotateL (AVLNode<K, E> *& ptr) {
//右子树比左子树高: 做左单旋转后新根在ptr
     AVLNode<K, E> *subL = ptr;
    ptr = subL->right;
    subL->right = ptr->left;
    ptr->left = subL; 
    ptr->bf = subL->bf = 0;
};
```

- 右单旋转

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124135633148.png" alt="image-20231124135633148" style="zoom:50%;" />


```c++
template <class K, class E>
void AVLTree<K, E>::
RotateR (AVLNode<K, E> *& ptr) { 
//左子树比右子树高, 旋转后新根在ptr
    AVLNode<K, E> *subR = ptr;   //要右旋转的结点
    ptr = subR->left;
    subR->left = ptr->right;	
    ptr->right = subR;		
    ptr->bf = subR->bf = 0;
};
```

- 先左后右

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124140410239.png" alt="image-20231124140410239" style="zoom: 50%;" />

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124140501524.png" alt="image-20231124140501524" style="zoom:50%;" />


```c++
template <class K, class E>
void AVLTree<K, E>:: RotateLR (AVLNode<K, E> *& ptr) {
    AVLNode<K, E> *subR = ptr;
    AVLNode<K, E> *subL = subR->left;
    ptr = subL->right;
    subL->right = ptr->left;
    ptr->left = subL;
    if (ptr->bf <= 0) subL->bf = 0;
    else subL->bf = -1;
    subR->left = ptr->right;
    ptr->right = subR;	
    if (ptr->bf == -1) subR->bf = 1;
    else subR->bf = 0;
    ptr->bf = 0;
};
```

- 先右后左

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124150329550.png" alt="image-20231124150329550" style="zoom: 50%;" />

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124150401610.png" alt="image-20231124150401610" style="zoom:50%;" />


```c++
template <class K, class E>
void AVLTree<K, E>::
RotateRL (AVLNode<K, E> *& ptr) {
    AVLNode<K, E> *subL = ptr;
    AVLNode<K, E> *subR = subL->right;
    ptr = subR->left;
    subR->left = ptr->right; 
    ptr->right = subR;
    if (ptr->bf >= 0) subR->bf = 0;
    else subR->bf = 1;
    subL->right = ptr->left;
    ptr->left = subL;
    if (ptr->bf == 1) subL->bf = -1;
    else subL->bf = 0;
    ptr->bf = 0;
}; 
```

- 补充：旋转的原理*

  - 单旋转

    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124142916619.png" alt="image-20231124142916619" style="zoom: 33%;" />

    - 假设某次操作后哦 $bf(D)=-2$ 假设 $h(A)>=h(C)$

    - $$
      设h(E)=x,则
      \begin{cases}
          h(B)=x+2\\
          h(A)=x+1\\
          x\leq h(C)\leq x+1
      \end{cases}
      $$

    - 对D向右旋转，则<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124143857668.png" alt="image-20231124143857668" style="zoom:33%;" />

    - $$
      \begin{cases}
          0\leq h(C)-h(E)\leq 1\\
          x+1\leq h'(D)=\max(h(C),h(E))+1=h(C)+1\leq x+2\\
          0\leq h'(D)-h(A)\leq 1
      \end{cases}
      $$

  - 双旋转

    - $h(A)<h(C)$

    - $$
      \begin{cases}
          h(B)=x+2\\
          h(C)=x+1\\
          h(A)=x
      \end{cases}
      $$

    - 先对节点 B 进行一次左旋操作，再对节点 D 进行一次右旋操作

    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124144734158.png" alt="image-20231124144734158" style="zoom:33%;" />

    - $$
      \begin{cases}
          x-1\leq h'(rs_B),h'(ls_D)\leq x\\
          0\leq h(A)-h'(rs_B)\leq 1\\
          0\leq h(E)-h'(ls_D)\leq 1\\
          h'(B)=\max(h(A),h'(rs_B))+1=x+1\\
          h'(D)=\max(h(E),h'(ls_D))+1=x+1\\
          h'(B)-h'(D)=0
      \end{cases}
      $$

#### 插入

- 在插入新结点后（向二叉搜索树那样进行失败的查询后在原位置进行插入），需从插入结点**沿通向根的路径向上回溯**。 如果在某一结点发现高度不平衡，停止回溯。从发生不平衡的结点起，**沿刚才回溯的路径取直接下两层**的结点。
  - 如果这三个结点处于**一条直线上**，则采用**单旋转**进行平衡化。单旋转可按其方向分为左单旋转和右单旋转。 如果这三个结点处于**一条折线**上，则采用**双旋转**进行平衡化。双旋转分为先左后右和先右后左两类。
- 插入新结点并修改pr的平衡因子值后，pr的平衡因子值有三种情况：
  - 结点pr的平衡因子为0：什么也不需要做（说明向矮的树插入），树的高度不发生变化
  - $|bf|=1$
    - 说明插入前pr的平衡因子是0，不需要旋转，但是子树**高度加一**，需要继续考察双亲节点的平衡状态
  - $bf=-2$
    - 在较高的子树插入，需要旋转转化
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124151451461.png" alt="image-20231124151451461" style="zoom:50%;" />
  - $bf=2$
    - 右子树高
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124151416103.png" alt="image-20231124151416103" style="zoom:50%;" />
- 例：输入关键码序列为 { 16, 3, 7, 11, 9, 26, 18, 14, 15 }
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124151639598.png" alt="image-20231124151639598" style="zoom: 50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124151655002.png" alt="image-20231124151655002" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124151712299.png" alt="image-20231124151712299" style="zoom:50%;" />


#### 删除

- 如果被删结点x最多只有一个子女，可做简单删除:
  - 将结点x从树中删去。
  - 如果结点x有一个子女，可以简单地把x的双亲中原来指向x的指针改成指到这个子女结点；
  - 如果结点x没有子女，x双亲原来指向x的指针置为NULL。
  - 将原来以结点x的父结点为根的**子树的高度减1。**

- 如果被删结点 x 有两个子女:
  -  搜索x在中序次序下的直接前驱 y (同样也可以找直接后继)。
  -  把结点 y 的内容传送给结点 x，现在**问题转移到删除结点 y**，把结点 y 当作被删结点。
  -  因为结点 y 最多有一个子女，可以简单地用 1. 给出的方法进行删除。

- 删除x之后的维护（必须沿结点x的父结点通向根的路径**反向追踪**高度的变化对路径上各个结点的影响）
  - 用shorter（一个bool变量）指明子树高度是否缩短，初始为True，在向上遍历检查中，如果shorter编程false算法终止，否则要进行检查及操作
  - 若节点的bf为0，则有一个子树缩短，bf变为-1/1，但是shorter为false，停止向上
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153016874.png" alt="image-20231124153016874" style="zoom:50%;" />

  - 若bf 不为0且较高的子树被缩短。则 p 的 bf 改为0，同时shorter置为True。还要继续**检查上层结点**的平衡因子。
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153059726.png" alt="image-20231124153059726" style="zoom:50%;" />

  - 结点 p 的 bf 不为0，且较矮的子树又被缩短。则在结点 p **发生不平衡**。需要进行平衡化旋转来恢复平衡。（假设高子树根为q）
    - 如果 q（较高的子树）的 bf 为0，执行一个单旋转来恢复结点 p 的平衡，置shorter为False。**无需检查上层结点的平衡因子**。<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153359641.png" alt="image-20231124153359641" style="zoom:50%;" />
    - 如果 q 的 bf 与 p 的 bf **相同**，则执行一个单旋转来恢复平衡，结点 p 和 q 的 bf 均改为0，同时置shorter为True。**还要继续检查上层结点的平衡因子。**<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153430823.png" alt="image-20231124153430823" style="zoom:50%;" />
    - 如果 p 与 q 的 bf **相反**，则执行一个双旋转来恢复平衡。新根结点的 bf 置为0，其他结点的 bf 相应处理，同时置shorter为True。**还要继续检查上层结点的**平衡因子。<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153614636.png" alt="image-20231124153614636" style="zoom:50%;" />

- 例子
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153736125.png" alt="image-20231124153736125" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153754433.png" alt="image-20231124153754433" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153804464.png" alt="image-20231124153804464" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153815889.png" alt="image-20231124153815889" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153827947.png" alt="image-20231124153827947" style="zoom:50%;" />

## 图

### 图的基本概念

- 图是由**顶点集合以及顶点之间的关系集合**组成的一种数据结构：
  G＝( V, E )    
- 完全图：若有 n 个顶点的无向图有 n(n-1)/2 条边, 则此图为无向完全图。若有 n 个顶点的有向图有n(n-1) 条边, 则此图为**有向完全图**。
- 邻接顶点   如果 (u, v) 是 E(G) 中的一条边，则称 u 与 v 互为邻接顶点。
- 简单路径   若路径上各顶点 v1, v2, ..., vm 均不互相重复, 则称这样的路径为简单路径。
- 

### 图的存储结构

- 图的模板基类（带权无向图）


```c++
template <class T, class E>
    class Graph {			    //图的类定义
        protected:
        int maxVertices;		    //图中最大顶点数
        int numEdges;			    //当前边数
        int numVertices;		    //当前顶点数
        virtual int getVertexPos (T vertex);	
        //给出顶点vertex在图中位置
        public: 
        Graph (int sz = DefaultVertices);  	//构造函数
        ～Graph();				//析构函数
        bool GraphEmpty () const 		//判图空否
        { return numEdges == 0; }	
        int NumberOfVertices () { return numVertices; }
        //返回当前顶点数
        int NumberOfEdges () { return numEdges; }
        //返回当前边数
        virtual T getValue (int i);		//取顶点 i 的值
        virtual E getWeight (int v1, int v2);  //取边上权值
        virtual int getFirstNeighbor (int v);
        //取顶点 v 的第一个邻接顶点
        virtual int getNextNeighbor (int v, int w);
        //取邻接顶点 w 的下一邻接顶点
        virtual bool insertVertex (const T vertex);
        //插入一个顶点vertex
        virtual bool insertEdge (int v1, int v2, E cost);
        //插入边(v1,v2), 权为cost
        virtual bool removeVertex (int v);	
        //删去顶点 v 和所有与相关联边
        virtual bool removeEdge (int v1, int v2);	
        //在图中删去边(v1,v2)
    };
```

#### 邻接矩阵表示

- 在图的邻接矩阵表示中，有一个记录各个顶点信息的顶点表，还有一个表示各个顶点之间关系的邻接矩阵
- 存储带权图
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209180138116.png" alt="image-20231209180138116" style="zoom:33%;" />

#### 邻接表

- 把邻接矩阵的各行分别组织为一个单链表
- 无向图
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209181018735.png" alt="image-20231209181018735" style="zoom:33%;" />
- 有向图的（邻接表和逆邻接表）
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209181039623.png" alt="image-20231209181039623" style="zoom:33%;" />

#### **邻接多重表** 

- 无向图的邻接表表示中，每条边被存**储了两遍**，既浪费了空间，又造成为边做标记等有关边的处理的不方便
- 在邻接多重表中, **每一条边只有一个边结点**。为有关边的处理提供了方便。
- **无向图**
  - 边结构<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209181912923.png" alt="image-20231209181912923" style="zoom:33%;" />
    - vertex1和vertex2是该边两顶点位置。path1域是链接指针, 指向下一条**依附顶点vertex1的边**；path2 是指向下**一条依附顶点vertex2的**边链接指针。
  - 点结构<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209181946722.png" alt="image-20231209181946722" style="zoom:33%;" />
    - data 存放与该顶点相关的信息，firstout 是指向依附于该顶点的**第一条边的指针。**
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209182013312.png" alt="image-20231209182013312" style="zoom:33%;" />
- **有向图**
  - 用有向图的邻接多重表可以结合邻接表和逆邻接表
  - 点结构<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209182121133.png" alt="image-20231209182121133" style="zoom:33%;" />
    - 数据成员data存放与该顶点相关的信息，指针firstout指向以该顶点为始顶点的**出边表**的第一条边， firstin 指向以该顶点为终顶点的**入边表**的第一条边。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209182155568.png" alt="image-20231209182155568" style="zoom:33%;" />

### 最小生成树

- 克鲁斯卡尔：并查集+堆
- 普里姆(Prim)：每次选已经确定的点最近的点加入

### 最短路径

- Dijkstra

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216160515589.png" alt="image-20231216160515589" style="zoom:33%;" />


Floyd

```c++
template <class T, class E>
    void Floyd (Graph<T, E>& G, E a[][], int path[][]) {
    //a[i][j]是顶点i和j之间的最短路径长度。path[i][j]
    //是相应路径上顶点j的前一顶点的顶点号。
    for (i = 0; i < n; i++)//矩阵a与path初始化
        for (j = 0; j < n; j++) {
            a[i][j] = G.getWeight (i, j);
            if (i != j && a[i][j] < maxValue) path[i][j] = i;
            else path[i][j] = 0;
        }
    for (k = 0; k < n; k++)//针对每一个k, 产生a(k)及path(k)       
        for (i = 0; i < n; i++)
            for (j = 0; j < n; j++)
                if (a[i][k] + a[k][j] < a[i][j]) { 
                    a[i][j] = a[i][k] + a[k][j];               
                    path[i][j] = path[k][j]; 
                    //缩短路径长度, 绕过 k 到 j
                }
};
```

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216155534762.png" alt="image-20231216155534762" style="zoom:33%;" />

### 活动网络(拓扑排序任务调度)

#### AOV网络

- 对给定的AOV网络，必须先判断它是否存在有向环，如果出现了有向环，则意味着某项活动应以自己作为先决条件。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209183331470.png" alt="image-20231209183331470" style="zoom:33%;" />
- 拓扑排序
  - bfs（逐渐删去度为0的点）

#### AOE网络

- 在无有向环的带权有向图中, 用**有向边表示一个工程中的活动** , 用边上权值表示活动持续时间 ,  用**顶点表示事件** ,  则这样的有向图叫做用边表示活动的网络
- 表示完成全部任务需要的最少时间
- 整个工程只有一个开始点和一个完成点，开始点（即入度为零的顶点）称为**源点**，结束点（即出度为零的顶点）称为**汇点**。
  - 完成整个工程所需的时间取决于从源点到汇点的**最长路径长度**，这条路径长度最长的路径就叫做**关键路径**
  - 关键路径上的所有活动都是**关键活动**
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209184606697.png" alt="image-20231209184606697" style="zoom:33%;" />
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209184600500.png" alt="image-20231209184600500" style="zoom:33%;" />
- 先求解Ve、Vl
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209184826624.png" alt="image-20231209184826624" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209184846084.png" alt="image-20231209184846084" style="zoom:33%;" />
- 计算Ae、Al
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209184957786.png" alt="image-20231209184957786" style="zoom:33%;" />
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209185008828.png" alt="image-20231209185008828" style="zoom:33%;" />

## 排序

- 内排序与外排序:   内排序是指在排序期间数据元素全部存放在内存的排序；外排序是指在排序期间全部元素个数太多，不能同时存放在内存，必须根据排序过程的要求，不断在内、外存之间移动的排序。
- 排序的复杂度：排序码的比较次数和元素移动次数

![image-20231216130305703](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216130305703.png)

### 插入排序

- 每步将一个待排序的元素，按其排序码大小，插入到前面已经排好序的一组元素的适当位置上, 直到元素全部插入为止。

#### 直接插入排序

- 即传统的插入排序，从后向前比较插入，不能放就交换位置，即将元素向后移动
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216115343430.png" alt="image-20231216115343430" style="zoom:33%;" />


```c++
for (i = left+1; i <= right; i++)
    if (L[i] < L[i-1]) {
        temp = L[i];  j = i-1;	
        do {
            L[j+1] = L[j];  j--;
        } while (j >= left && temp < L[j]);
        L[j+1] = temp;  
    }
}
```

- 事件复杂度分析

  - 最好情况下如元素已经排好序，则比较次数为n-1移动次数为0
  - 最坏情况下逆序，比较和移动均为$n^2/2$
  - 平均为$O(n^2)$

- 稳定排序

#### 折半插入排序

- 在查找位置时使用折半查找而不是从后向前逐一比对


```c++
int i, low, high, middle, k;
for (i = left+1; i <= right; i++) {
    temp = L[i];  low = left;  high = i-1; 
    while (low <= high) {	//折半搜索寻找插入位置
        middle = (low+high)/2;	//取中点
        if (temp < L[middle])	  //插入值小于中点值
            high = middle-1;	  //向左缩小区间
        else low = middle+1;	  //否则, 向右缩小区间
    }
    for (k = i-1; k >= low; k--) L[k+1] = L[k];
    //成块移动,空出插入位置
    L[low] = temp;	     //插入
}
```

- 平均比较次数<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216120538672.png" alt="image-20231216120538672" style="zoom: 25%;" />

- 折半插入排序的元素移动次数与直接插入排序都**依赖于元素的初始排列**。

- 当 n 较大时，总排序码比较次数比直接插入排序的最坏情况要好得多，但**比其最好情况要差**。

- 稳定的排序方法

#### 希尔排序

- 取一个整数 gap < n 作为间隔，将全部元素分为 gap 个子序列，所有距离为 gap 的元素放在同一个子序列中，在每一个子序列中分别施行**直接插入排序**。然后缩小间隔 gap, 例如取 gap = gap/2，重复上述的子序列划分和排序工作。直到最后取 gap == 1，将所有元素放在同一个序列中排序为止。
- 开始时 gap 的值较大，子序列中的元素较少，排序速度较快;  随着排序进展，gap 值逐渐变小, 子序列中元素个数逐渐变多，由于前面工作的基础，大多数元素已基本有序，所以排序速度仍然很快。
- 示例
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216121145103.png" alt="image-20231216121145103" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216121153754.png" alt="image-20231216121153754" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216121202148.png" alt="image-20231216121202148" style="zoom:33%;" />


```c++
void ShellSort (dataList<T>& L, 
                const int left, const int right) {
    int i, j, gap = right-left+1;		//增量的初始值
    Element<T> temp;
    do {
        gap = gap/3+1;			//求下一增量值
        for (i = left+gap; i <= right; i++)
            if (L[i] < L[i-gap]) {		//逆序
                temp = L[i];  j = i-gap;
                do {
                    L[j+gap] = L[j];  j = j-gap;
                } while (j >= left && temp < L[j]);
                L[j+gap] = temp;	//将vector[i]回送
            }
    } while (gap > 1);
};
```

- 复杂度约为$n^{1.25}$

- 不稳定排序

### 快速排序

- 不稳定的排序方法（partition引起）
- 对于 n 较大的平均情况而言, 快速排序是“快速”的, 但是当 n 很小时, 这种排序方法往往比其它简单排序方法还要慢。

### 交换排序

#### 冒泡排序

```c++
while (pass <= right && exchange) {
    exchange = 0;		    	//标志为0假定未交换
    for (int j = right;  j >= pass;  j--)      
        if (L[j-1] > L[j]) { 	//逆序
            Swap (L[j-1], L[j]); 	//交换
            exchange = 1;        	//标志置为1,有交换
        }
    pass++;
}
```

- 在元素的初始排列已经按排序码从小到大排好序时，此算法**只执行一趟起泡**，做n-1次排序码比较，不移动元素。这是最好的情形。

- 最坏的情形是算法执行n-1趟起泡,第i趟 (1≤ in) 做n-i次排序码比较, 执行n-i次元素交换。

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216122522417.png" alt="image-20231216122522417" style="zoom: 33%;" />

- 稳定的排序

### 选择排序

- 基本思想是:  每一趟 (例如第 i 趟, i = 0, 1, …, n-2) 在后面 n-i 个待排序元素中选出排序码最小的元素，作为有序元素序列的第 i 个元素。待到第 n-2 趟作完，待排序元素只剩下1个,  就不用再选了。

#### 直接选择排序

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216123058842.png" alt="image-20231216123058842" style="zoom: 50%;" />


```c++
void SelectSort (dataList<T>& L, 
          const int left, const int right) {
    for (int i = left; i < right; i++) {
        int k = i;    //在L[i]到L[right]之间找最小排序码元素
        for (int j = i+1;  j <= right;  j++) 
            if (L[j] < L[k]) k = j;
        if (k != i) Swap (L[i], L[k]);	//交换 
    }
};
```

- 比较次数固定为$\frac{n(n-1)}2$

- 当这组元素初始状态是按其排序码从小到大有序的时候,  元素的移动次数达到最少RMN = 0，
  最坏情况是每一趟都要进行交换，总的元素移动次数为 RMN = 3(n-1)。

- 不稳定的排序方法(交换过程引起，可能破坏相同元素的顺序)

#### 锦标赛排序

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216124219257.png" alt="image-20231216124219257" style="zoom:50%;" />
- 示例
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216124454645.png" alt="image-20231216124454645" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216124504173.png" alt="image-20231216124504173" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216124515669.png" alt="image-20231216124515669" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216124558765.png" alt="image-20231216124558765" style="zoom:33%;" />
- 第一次为构建树，之后只需要对树进行更新即可
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216124713381.png" alt="image-20231216124713381" style="zoom:33%;" />
- 稳定的排序方法

#### 堆排序

```c++
template <class T>
    siftDown (dataList<T>& L, const int start, const int m){
    //私有函数: 从结点start开始到m自上向下比较, 
    //如果子女的值大于双亲的值, 则相互交换, 将一
    //个集合局部调整为最大堆。
    int i = start;  int j = 2*i+1;	 //j是i的左子女
    Element<T> temp = L[i];	 //暂存子树根结点
    while (j <= m) {		   	 //逐层比较
        if (j < m && L[j] < L[j+1]) j++;
        //让j指向两子女中的大者
        if (temp >= L[j]) break;	 //temp排序码大,不调整
        else {			    //否则子女中的大者上移
            L[i] = L[j];
            i = j;  j = 2*j+1;  	    //i下降到子女位置
        }
    }
    L[i] = temp;		    //temp放到合适位置
};
template <class T>
    void HeapSort (dataList<T>& L) {
    //对表L.Vector[0]到L.Vector[n-1]进行排序, 使得表
    //中各个元素按其排序码非递减有序
    int i, n = L.length();
    for (i = (n-2)/2; i >= 0; i--) 	//建堆
        siftDown (L, i, n-1);	
    for (i = n-1; i >= 0; i--) {		//修堆
        L.Swap(0, i);  siftDown (L, 0, i-1);
    }
};
```

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216125259784.png" alt="image-20231216125259784" style="zoom:33%;" />
- 示例
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216125321501.png" alt="image-20231216125321501" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216125327873.png" alt="image-20231216125327873" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216125337392.png" alt="image-20231216125337392" style="zoom:33%;" />

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216125445021.png" alt="image-20231216125445021" style="zoom:33%;" />
- 堆排序是一个不稳定的排序方法（每次将堆顶移动到尾部的交换引起）。

### 归并排序

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216125751339.png" alt="image-20231216125751339" style="zoom:33%;" />
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216125930199.png" alt="image-20231216125930199" style="zoom:33%;" />
- 归并排序是一个稳定的排序方法。

## 文件

### 主存储器和外存储器

#### 磁带

- 磁带带面每一横排9位二进制，8位数据位1位奇偶校验位
- 磁带的存储密度BPI
  - 6250BPI（=246排/mm）、1600BPI（=64排/mm）、800BPI（32排/mm）。正常走带速度为3～5m/Sec
- 传送速度=存储密度*走带速度
- 应用中发使用文件进行数据处理的基本单位为（逻辑）记录，磁带上存储的为（物理）记录
- 在使用磁带或磁盘存放逻辑记录时，常常把若 干个逻辑记录**打包**进行存放，把这个过程叫做 “块化”（blocking）。经过块化处理的物理 记录叫做**块化记录**。
- 磁带每次启停都有 一个加速与减速的过程，在这段时间内走带不稳定，只能走空带，这段空带叫做**记录间间隙**（块间间隙IBG）
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231228000040266.png" alt="image-20231228000040266" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231228000328437.png" alt="image-20231228000328437" style="zoom: 33%;" />
- 读写一个块的实践$t_{IO}=t_a+t_b$
  - $t_a$：延时时间（读写磁头到达待读写块所需的时间）
  - $t_b$：对一个块读写的时间（数据传输时间+IBG）
- 磁带设备只能用于处理**变化少，只进行顺序存取**的大量数据。

#### 磁盘

- ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228000901.png)
	- 数据存储在盘面的**磁道**上，磁道划分为若干段（扇区）
	- 每个盘面都有磁头，磁头同步在磁道之间移动，所处的磁道合起来称为柱面

- 读取：
	- 先选定柱面，并移动磁头寻查（机械动作较慢）
	- 确定读写的磁道（电子线路）
	- 确定扇区，旋转延迟（机械动作）
	- 进行读写
	- $t_{io}=t_{seek}+t_{latency}+t_{rw}$
	- 平均寻查时间+平均等待时间（旋转延迟）+数据传输时间

- 在 MS-DOS 系统中，**多个扇区集结成组**，称为簇，作为文件分配的最小单位。
- UNIX 系统中不使用簇，文件分配的最小单位和读写的最小单位是**一个扇区**，称为一个块

#### 缓冲区

- 在磁盘读写时内存需要开辟区域用于存方读入/写出的信息，即输入缓冲区和输出缓冲区。
- 缓冲区大小应与操作系统一次读写的块的大小相适应，这样就可以通过一次读写完成操作
- 如果缓冲区大小与磁盘上的块大小不适配，就会造成存储空间的浪费
- 缓冲区的构造可以看作一个**先进先出**的队列。

- 目标：减少磁盘 io，一次多读/多写一点

```cpp
template <class T>
    void buffer<T>::OutputInfo (ostream& out, T x) {
        if (current == maxSize) {
        //一次性输出
            for (int i = 0; i < maxSize; i++) out << data[i];
            current = 0;
        }
        data[current] = x; current++;
    };
    template <class T>
        void buffer<T>::InputInfo (istream& in, T& x) {
            if (current < maxSize) {
                x = data[current];
                current++;
            }
            else {
            //一次性读取
                for (int i = 0; i < maxSize; i++) in >> data[i];
                current = 0;
            }
        };
```

### 文件组织

- 文件是存储在外存上的数据结构，一般是在**逻辑上具有完整意义的一组相关信息项的有序序列**。
- 操作系统文件：流式文件，没有结构的字符流，按物理记录读写
- 数据库文件：具有结构的数据集合，按页块读写

#### 文件的组成

- 文件由记录组成（文件存取的基本单位），记录由数据项（文件可使用的基本单位）组成
- 文件记录分为逻辑记录和物理记录。前者是**面向用户**的基本存取单位，后者是**面向外设**的基本存取单位。

- 能够**唯一标识**一个记录的数据项或数据项集称为**主关键码项**，其值称为主关键码；
- **不唯一标识**一个记录的数据项或数据项集称为**次关键码项**，其值称为次关键码。

- 文件结构：**逻辑结构、存储结构、操作**
	- 文件的逻辑结构是线性的
	- 文件的存储结构：顺序存储、直接存取组织（散列函数）、索引组织
	- 操作定义在逻辑结构、实现在存储结构
		- ![|300](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228003141.png)

- 评价文件组织的效率
	- 执行文件操作所花费的时间
	- 文件组织所需要的空间

- 顺序存取设备：磁带
- 直接存取设备：磁盘

#### 顺序文件

- 顺序文件中的记录按它们**进入文件的先后顺序存放**，其逻辑顺序与物理顺序**一致**
- 如果按**主关键码有序**，则称为**顺序有序**文件，否则为顺序无序文件
- 在顺序存取设备上只能顺序搜索存取，存放在**直接存取**设备上时才能进行折半搜索等操作

- 顺序文件的存取方式
	- 连续文件：记录顺序的存放在外存的连续区域
		- 速度快、存储利用率高
		- 不能扩充区域大小
	- 串联文件：成块存放，但块与块之间可以不连续，通过块状指针顺序链接
		- 文件可以扩充、存储利用率高
		- 影响了存取和修改的效率。

#### 直接存取文件

- 散列文件，利用散列组织文件，记录的逻辑顺序与物理顺序不一定相同，通过记录的关键码可直接确定该记录的地址
- 使用散列函数把关键码集合映射到地址集合

- 冲突和处理
- 按桶散列
	- 记录成组存放，若干组构成桶
	- 若一个桶能存放 m 个记录，则 m 个互为同义词的记录可以存放在同一地址的桶中。当第 m+1 个同义词出现时，发生**溢出**。
	- 溢出链：将第 m+1 个同义词存放到“**溢出桶**”。并称存放前 m 个同义词的桶为“**基桶**”。溢出桶和基桶大小相同。当在基桶中检索不成功，就循指针到溢出桶中检索。
		- ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228005110.png)
		- 删除记录时，因为可能需要重新链接，所以只需做一个**逻辑删除标记**即可，待系统做周期性重构时再做物理删除。
	- 分布式溢出空间：
		- 出桶按照一定的间隔分布在基桶之间。如果有**一个基桶溢出了**，系统就将记录**存放在下一个溢出桶中**。如果溢出桶溢出了，则溢出到**下一个溢出桶**
		- ![image.png|225](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228005639.png)
	- 相继溢出法：
		- 不设置溢出桶，当发生溢出时，溢出记录直接存方到下一个相继的桶中（下一个不是已满的桶中）
		- 优点是对溢出不需要漫长的寻找。紧邻的桶通常相距不多于一次磁盘旋转。但当邻近的多个桶被挤满时，则为了查找空闲空间就需要检查许多桶。如果桶的容量很小更是如此。
		- ![image.png|225](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228005846.png)

- 可扩充散列
	- 基于数字搜索树，根据桶的大小进行合并、分裂等操作

- 优点：随机存放、记录不需进行排序、插入删除方便、存取速度快、不需要索引区和节省存储空间等优点。
- 缺点：不能顺序存取，只能按**关键码随机存取**。在经过多次插入、删除后，可能出现溢出桶满而基桶内多数记录已被删除的情况。此时需要**重新组织文件**。

#### 索引文件

- 由**索引表和数据表（主文件）** 组成，索引表指示逻辑记录与物理记录的对应关系，是按关键码有序的表

- 索引顺序文件：主文件也按关键码有序。此时可对主文件分组，**一组记录对应一个索引项**。称这种索引表为**稀疏索引**。
	- 即一个索引项对应数据表中的**一组记录**
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228125653.png)

- 索引非顺序文件：主文件中记录未按关键码有序。此时，**每一个主文件记录必须对应一个索引项**。称这种索引表为**稠密索引**
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228125641.png)


- **静态索引**：多级索引结构，每一级索引都是一个有序表，结构简单，但是不方便修改，修改需要重组索引
	- 数据装入时就已经定型，在整个运行期间，**结构不发生变化**。
- **动态索引**：动态调整的**平衡搜索树结构**，方便插入搜索删除
	- 在整个系统运行期间, 结构随数据的增删及时调整, 以保持最佳的搜索效率。

- 搜索的时间代价取决于访问外存的次数，即**索引树的高度**

- 索引顺序文件
	- 先在索引表搜索给定的值 k, 使 i 满足 $ID[i-1].max\_key<K<ID[i].max\_key$ 得到子表项
	- 在第 i 个子表中搜索记录
	- 根据存储的方式，可以使用顺序搜索或折半搜索
- 索引顺序文件的搜索成功平均搜索长度 $ASL_{IndexSeq}=ASL_{Index}+ASL_{SubList}$
	- 搜索子表位置的平均搜搜常速+子表内搜索的平均搜索长度
	- 把长度为 n 的表分成均等的 b 个表，每个表 s 个记录，则 $ASL_{IndexSeq}=\frac{b+1}{2}+\frac{s+1}{2}$
	- 其中 $b=\left\lceil  \frac{n}{s}  \right\rceil$ ，因而 $l=\sqrt{ n }$ 时取得最小长度

#### 倒排表

- 用主关键码建立索引叫**主索引**
	- $key|addr$
- 但是只使用关键码有时无法回答根据存储内容进行筛选的查询，使得只能进行低效率的**顺序搜索**
	- 因此除了主关键码外可以把经常搜索的属性设定为**次关键码**，并针对次关键码的属性，建立**次索引**
	- 次索引中**列出属性的取值**，对取值建立有序链表，把具有相同属性值得记录按存放地址/主关键码的顺序**连接**。由次关键码、链表长度、链表本身三部分组成。
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228133114.png)
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228133951.png)
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228134008.png)
	- 通过此索引得到链并进行布尔运算就可以通过属性实现查询

- **倒排表**是次索引的一种实现。在表中所有次关键码的链都保存在次索引中，仅通过**搜索次索引**就能找到所有具有相同属性值的记录。

- 在倒排表中各个属性链表的长度大小不一, 管理比较困难。为此引入**单元式倒排表**。
	- 索引项中不存放记录的存储地址, 而是**存放该记录所在硬件区域**（即存储区域）的标识。（一次 I / O 操作能存取的存储空间作为硬件区域）
	- 为使索引空间最小, 在索引中标识这个硬件区域时可以使用一个能转换成地址的**二进制数**, 整个次索引形成一个 (二进制数的) **位矩阵**
	- 二进位的值为 **1** 的硬件区域**包含具有该次关键码的记录**。（即状态压缩）
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228134645.png)
	- 针对一个查询：按照此索引抽取属性的位相量，按位进行布尔运算，就求得满足查询要求的记录**在哪些硬件区域中**，再读入这些硬件区域，从中查找所需的数据记录。
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228134800.png)

#### 多级索引结构

- 数据记录比较大时索引表也会太大，可以建立索引的索引
- 二级索引可以**常驻内存**，二级索引中一个索引项对应一个索引块，登记该索引块的最大关键码及该索引块的存储地址。

- 多级索引结构用 m 叉树表示，称为 m 路搜索
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228152750.png)

##### 静态索引结构（ISAM 索引顺序存取方法文件）

- 典型的例子是对磁盘上的数据文件建立**盘组、柱面、磁道三级地址**的多级索引。
- ISAM 文件用柱面索引对各个**柱面进行索引**。一个柱面索引项保存该柱面上的**最大关键码** （最后一个记录）以及柱面**开始地址指针**。
	- 如果柱面太多，可以建立柱面索引的分块索引，即**主索引**。主索引不太大，一般常驻内存。
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228153623.png)

- 在每个柱面上，所有数据记录存放于**基本区**，此外保留一部分磁道作为**溢出区**。
- 所有记录在**基本区按关键码升序排列**，后一磁道所有记录的关键码均**大于前一磁道所有记录**的关键码。（用于选择统一柱面不同盘面上的磁道）
	- 通过位于每个柱面**第 0 号磁道**上的**磁道索引**进行搜索
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228155749.png)
	- **基本区索引项**：它包含本磁道在基本区最大的关键码和该磁道基本区的开始地址指针。
	- **溢出区索引项**：它存放的是本磁道在溢出区的最大关键码和溢出记录链的头部指针。

- 在某一磁道插入一个新记录时，如果原来该磁道基本区记录已经放满，则根据磁道索引项指示位置插入新记录后，把**最后的溢出记录**（具有最大关键码）移出磁道基本区，再根据溢出索引项将这个溢出记录放**入溢出区**，并以有序链表插入算法将溢出记录链入。

##### 动态索引结构（m 路路搜索树）

- m 路搜索树的定义
	- 一棵空树，或者是一个满足以下性质的节点结构的树：
	  - 根节点最多有 m 棵子树，并具有以下结构：  
	    `(n, P0, K1, P1, K2, P2, …, Kn, Pn)`  
	    其中：
	    - `Pi` 是指向子树的指针，满足 `0 ≤ i ≤ n < m`；
	    - `Ki` 是关键码，满足 `1 ≤ i ≤ n < m` 且 `Ki < Ki+1` 对于 `1 ≤ i < n`。
	- 对于任意节点内部的关键码和指针的关系满足：
	  - 在子树 `Pi` 中的所有关键码 `K` 都满足 `Ki < K < Ki+1` 对于 `0 < i < n`；
	  - 在子树 `Pn` 中的所有关键码都**大于** `Kn`；
	  - 在子树 `P0` 中的所有关键码都**小于** `K1`。、
	- 每个子树 `Pi` 也是一个 m 路搜索树，满足 `0 ≤ i < n`。
	- ![image.png|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228161444.png)

- 每个节点最多有 $m-1$ 个关键码，高度为 h 的 m 路搜索树中关键码最大数目为 $m^h-1$

- 提高搜索树的路数 m, 可以改善树的搜索性能。对于给定的关键码数 n，如果搜索树是平衡的，可以使 m 路搜索树的性能接近最佳。

- 搜索算法：
	- ![image.png|225](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228162922.png)
```cpp
const int MaxValue = ……;
//关键码集合中不可能有的最大值
template <class T>
    struct MtreeNode {
        //树结点定义
        int n;
        //索引项个数
        MtreeNode<T> *parent;
        //父结点指针
        T key[m+1]; //key[m]为监视哨，key[0]未用
        int *recptr[m+1];
        //索引项记录起始地址指针
        MtreeNode<T> *ptr[m+1];//子树结点指针，ptr[m]在插入溢出时使用
    };
template <class T>
    //搜索结果三元组
    struct Triple {
        MtreeNode<T> *r;
        //结点地址指针
        int i;
        //结点中关键码序号i
        int tag;
        //tag=0,成功; =1,失败
    };
template <class T>
    class Mtree {
        //m叉搜索树定义
        protected:
        MtreeNode<T> *root;
        //根指针
        int m;
        //路数
        public:
        Triple<T> Search(const T& x);
        //搜索
    };
template <class T>
    Triple<T> Mtree<T>::Search (const T& x) {
        //tag = 0, 表示 x 在结点r中找到, 该结点的k[i]等于x;
        //tag = 1, 表示没有找到x, 可插入结点为r, 插入到该
        //结点的k[i]与k[i+1]之间。
        Triple result;
        //记录搜索结果三元组
        GetNode (root);
        //从盘上读取结点root
        MtreeNode<T> *p = root, *q = NULL;
        //p是扫描指针,q是p的父结点指针
        int i = 0;
        while (p != NULL) {
            //从根开始检测
            i = 0; p->key[(p->n)+1] = MaxValue;
            while (p->key[i+1] < x) i++;
            //在结点内搜索
            if (p->key[i+1] == x) {
                //搜索成功
                result.r = p; result.i = i+1; result.tag = 0;
                return result;
            }
            q = p; p = p->ptr[i];
            //本结点无x, q记下当前结点, p下降到子树
            GetNode(p);
            //从磁盘上读取结点p
        }
        result.r = q; result.i = i; result.tag = 1;
        return result;
        //搜索失败,返回插入位置
    };
```

#### B 树

- 在大规模数据存储中，二叉查找树的**深度会过大**，当内存无法存储所有节点数据时，需要读取磁盘，进行 IO 操作，从而**树的高度越高，I/O 操作次数越多**(假设每个节点需要先从磁盘 IO 读取)，效率也就越低。所以诸如之前所讲的红黑树，AVL 树因为树的高度太高而不适合这种需要大量 IO 操作的查询。所以，B 树通过**多叉的实现来降低树的高度**，从而减少 IO 操作的次数。

- 与红黑树对比
  - **应用**：
    - **B 树**：常用于数据库和文件系统中，因为它们可以**大大减少磁盘 I/O 操作**（层数少）。由于磁盘的寻址时间相对较长，B 树设计的目标是确保树的**高度尽可能地短，从而减少磁盘读/写操作。**
    - **红黑树**：常用于内存中的数据结构，例如在很多语言的库中实现的集合和映射。它们提供了最坏情况下的时间复杂度较好的性能，对于那些需要频繁插入、删除和查找的应用程序来说是非常有价值的。
  - **效率**：
    - **B 树**：因为设计用于磁盘存储，B 树更关心存储空间和磁盘 I/O 操作的效率。它们减少了树的高度并优化了磁盘访问。
    - **红黑树**：因为设计用于内存操作，红黑树更关心**时间效率**，特别是插入、删除和查找的最坏情况下的性能。

#### B(-)树

- 定义：或者是空树, 或者是满足下列性质的树：
	- **根节点至少有两个子女**，其它所有节点至少有 $\left\lceil  \frac{m}{2}  \right\rceil$ 个子女
	- 所有**失败节点** (搜索失败到达的节点，这些节点并不存在，指向他们的指针为 NULL) **位于同一层**
	- 符合 m 路搜索树的所有定义   
	- ![image.png|450](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228165347.png)

- 使用 $key[i]$ 指向节点；$recptr[i]$ 指向实际记录的存放地址
- 每个节点的关键码个数 $\left[ \left\lceil  \frac{m}{2}  \right\rceil -1,m-1\right]$
- 叶节点也称为终端节点

- B 树搜索算法
	- 继承了 m 路搜索树 Mtree 上的搜索算法
	- B 树的搜索过程是一个在**结点内搜索**和循某一条路径**向下一层搜索**交替进行的过程。
	- B 树的搜索时间与 B 树的阶数 m 和 B 树的高度 h 直接有关
	- 搜索成功的时间取决于**关键码所在的层次**，不成功的时间取决于**树的高度**
	- 关键码总数有 $N\leq m^h-1$ 即 $h\geq \lceil \log_{m}(N+1) \rceil$ 
		- 由于 B 树的定义还有
		- ![image.png|400](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228170448.png)
	- 失败节点位于第 h+1 层，失败节点的数目为 N+1
	- 即第 $h+1$ 层节点数 $N+1 \geq 2 \left\lceil  \frac{m}{2}  \right\rceil^{h-1}$
	- $h{\leq}\log_{\lceil{\mathbf{m}}/2\rceil}(({{(N+1)/2)+1}}$

- m 的选择
	- 提高 m 可以可以**减少 h 的高度**，但是 m 很大一个节点的内容**超出内存**时反而增加了读盘次数，降低了效率
	- 选择 m 使得 B 树种找到关键码 x 的时间总量最小
	- 包含从磁盘种读入节点的时间+节点中进行搜索的时间
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228171511.png)


- B 树的插入
	- 插入总是在**某个叶节点**进行的, 之后**自底向上分裂节点**
	- 如果插入后不会破坏定义（关键码数目不超过 m-1 ），则直接插入
	- 如果插入后关键字数目大于 $m-1$ 则要对插入后的节点进行**分裂操**作：$\lceil m/2\rceil$ 关键字放入父节点中，其左侧节点留在原先的子树中，右侧节点放入**新节点**中。（这是一个递归操作）
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228173317.png)
	- ![image.png|300](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228173325.png)

- B 树的删除
	- 首先先通过搜索找要删除的关键码的位置
	- **终端节点**
    - 若删除后关键字数目**仍符合要求**（分为根节点和不是根节点），可以直接删除
    - 若删除后关键字数目过少，且兄**弟够借**（临近的兄弟节点的关键字个数 $>=\lceil m/2 \rceil$ 则从兄弟节点借一个关键字
	    - 将双亲结点中**刚刚大于被删除关键码**的关键字**下移**
	    - 将右兄弟 (或左兄弟) 结点中的最小 (或最大) 关键码**上移**到双亲结点的 Ki 位置；
	    - 将右兄弟 (或左兄弟) 结点中的最左 (或最右) 子树指针平移到被删关键码所在结点中最后 (或最前) 子树指针位置；
		- 在右兄弟 (或左兄弟) 结点中，将被移走的关键码和指针位置用剩余的关键码和指针填补、调整。再将结点中的关键码个数减1
      - ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228184201.png)

    - 兄弟**不够借**，则删除关键字，并与一个不够借的兄弟节点**合并**
	    - 若要合并 p 中的子树指针 Pi 与 Pi+1 所指的结点, 且保留 Pi 所指结点, 则把 p 中的**关键码 Ki+1 下移**到 Pi 所指的结点中。 
	    - 把 p 中子树指针 Pi+1 所指结点中的全部指针和关键码都照**搬到 Pi 所指结点的后面**。  
	    - 在结点 p 中用后面剩余的关键码和指针填补关键码 Ki+1 和指针 Pi+1。 
	    - 修改结点 p 和选定保留结点的关键码个数。如果关键码减少数目不再符合条件，需要继续向上进行修复
      - ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228185503.png)
      - ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228185533.png)
      - ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228185546.png)
      - ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228185600.png)

  - **非终端节点**
	  - 使用右子树中最小关键码（被删除节点的**后继节点**）代替被删除的关键码，再从子树中删除最小关键码
	  - 这就转化为删除终端节点的问题
	  - ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228175418.png)

#### B+树

- B+树是应**文件系统所需**而出的一种 B-树的变型树,**MySQL 中实际使用**

- 定义：
	- 每个节点最多 m 个子树
	- 根节点最少 1 棵，其它节点至少 $\left\lceil  \frac{m}{2}  \right\rceil$ 棵，一棵子树对应一个关键码

- 差异
  - 有**n 棵子树**的结点中含有**n 个关键字**，每个关键字不保存数据，只用来**索引**，**所有数据都保存在叶子节点。**	
    - 非叶子结点的子树指针 P\[i]，指向关键字值属于\[K\[i], K\[i+1])的子树
    - 上层的非叶结点的关键码是其子树中**最大（或最小）关键码**的复写。
  - 所有的**叶子结点中包含了全部关键字的信息**，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小**自小而大顺序链接**。$(K_{i} ,P_{i})$  表示关键码与实际记录存储地址的映射
    - 为所有叶子结点增加一个链指针；
  - 所有的非终端结点可以看成是**索引部分**，结点中仅含其子树（根结点）中的最大（或最小）关键字。$(K_{i} ,P_{i})$ 表示自述中**最大关键码与索引项的对应关系**
  - B+树**只有达到叶子结点才命中**

- 处理指向根节点的指针外，还有一个指向叶节点的指针，B+ 树支持遍历叶节点顺序搜索，以及从根节点随机访问

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231012211615427.png" alt="image-20231012211615427" style="zoom:33%;" />
- 插入
  - 如果节点中**有多余的空间**放入元素，则直接插入即可。
  - 如果插入后叶节点关键码个数大于 m，则将其**分裂**为两个节点，并将其**中间元素的索引放入到父节点中**
  - 如果是叶子节点的话，**拷贝中间元素**的索引到父节点中（因为**叶子节点需要包含所有的元素**）
  - 如果是非叶子节点，则是**上移节点**的中间元素到父节点中。
  - ![image.png|575](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228191826.png)
  - ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228192003.png)

- 删除
  - 仅在**叶节点中删除元素**，如果节点还满足 B+树的要求，则直接删除。
  - 如果**元素个数过少**，并且其**邻近兄弟节点有多余的元素**，则从邻近兄弟节点中**借一个元素，并修改父节点中的索引**使其满足新的划分。
  -  ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228192159.png)
  - 如果其邻近兄弟节点也**没有多余的元素**，则将其和邻近**兄弟节点合并**，并且我们需要**修改其父节点的索引**以满足新的划分。
  -  ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228192232.png)
  - 并且如果父节点的索引元素太少不满足要求，则需要继续看起兄弟节点是否多余，如果没有多余则还需要与兄弟节点合并，如此**不断向上**，直到根节点。如果根节点中元素也被删除，则把根节点删除，并由**合并来的节点作为新的根节点**，树的高度减 1。

- 使用在文件系统的优势
  - 叶子节点串成链表，非常适合**范围查找**
  - 任何关键字的查找都必须走一条从根节点到叶子节点的路，所有关键字查询的路径长度相同。
  - B+树的非叶子节点并没有指向关键字具体信息的指针，**因此其内部节点相对 B 树更小**，如果把所有同一内部节点的关键字存放在同一盘块中，盘块所**能容纳的关键字数量也越多**，具有更好的**空间局部性**，一次性读入内存的需要查找的关键字也越多，**相对的 IO 读写次数也就降低了**。
  - 由于所有数据值都存储在叶子节点中，当新数据插入或旧数据删除时，B+树的大小变化较为稳定。
#### B\*树

- 是 B+树的变体，在 B+树的**非根和非叶子结点**再增加**指向兄弟的指针**；
- B\*树定义了非叶子结点关键字个数至少为 (2/3)*M，即块的最低使用率为**2/3**，空间使用率更高
- 为什么没有使用 B* 树替代 B+树
  - **复杂性**：B\*树的插入和删除操作比 B+树**更复杂**。每当一个 B\*树的节点溢出时，它会尝试将关键字分散到相邻的兄弟节点中，**这需要更多的磁盘 I/O 操作**。只有在相邻节点都满时，节点才会被分裂。这与 B+树中简单的节点分裂方法相比要复杂得多。
  - **不经常的分裂和合并**：尽管 B\*树更加稠密，但在实际操作中，**B+树的节点并不总是完全填充，所以分裂和合并并不频繁**。这意味着 B+树在**实践中的性能与 B\*树相差无几**。
  - **稳定性**：由于 B+树的结构简单，它在实际应用中**表现得更加稳定**。而 B\*树的额外复杂性可能导致更多的错误或不一致。

####  外排序

- 待排序的记录数目太多，无法在内存中一次处理，**必须以文件形式存放于外存**，排序过程中一部分一部分调入内存进行处理，这种基于外部存储设备的排序就是外排序。

- 外排序大多使用归并排序
- 外排序的基本过程
	- 首先建立内存缓冲区，并根据内存缓冲区的大小对文件进行**划分**，对每一段数据分别进行排序，得到初始归并段，写回到外存
	- 按照归并树的模式对初始归并段进行归并，不断扩大归并段，最终归并为一个大的归并段

- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228193327.png)
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228193406.png)

- 把内存区域划分为 3 个缓冲区，两个输入缓冲区一个输入缓冲区。读取两个输入归并段，放在输入缓冲区，在内存中进行两路归并，并将结果输出到输出缓冲区。
- 若记录个数为 n ，磁盘上每个页块容纳 b 个记录，内存缓冲区可容纳 i 个页块，则每个初始归并段的长度为 $len=i*b$ 可以生成 $m=\left\lceil  \frac{n}{len}  \right\rceil$ 个等长的初始归并段
- 做两路归并时第一趟从 $m$ 个初始归并段得到 $\left\lceil  \frac{m}{2}  \right\rceil$ 个归并段，总归并次数为 $\lceil \log_{2}m \rceil$
- $t_{ES}=m^{*}t_{IS}+d^{*}t_{IO}+S^{*}n^{*}t_{mg}$
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228205932.png)
	- $t_{io}$ 是从硬盘进行读写，是时间瓶颈；$t_{mg}$ 则是从内存进行读写
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228205633.png)
- 因此想要提高外排序的效率要尽可能减小 d
- ![image.png|375](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228210853.png)
	- 增大归并路数可以减少归并趟数，有效减少 d
	- 归并趟数为 $\lceil \log_{k}m \rceil$
##### 多路（k）平衡归并

- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228211128.png)
- 假设每趟归并 n 个元素，则一次大致进行 $(n-1)*(k-1)$ 次比较
	- 即总共进行约 $(n-1)*(k-1)*\lceil \log_{k}m \rceil$
	- 也就是说 k 增大会使得**内部归并的时间增大**
	- 使用败者树优化 $\lceil \log_{2}m \rceil*(n-1)$ 与 k 无关无关
- 归并路数 k **不是越大越好**。归并路数 k 增大, 相应需增加输入缓冲区个数。如果可供使用的内存空间不变, 势必要减少每个输入缓冲区的容量, 使内外存交换数据的次数增大。

##### 败者树

- 败者树是完全二叉树
- 每个**叶结点**存放各归并段在归并过程中当前**参加比较的记录**； 
- 每个**非叶结**点存放它两个子女结点中记录**排序码大的结点 (即败者)**；（假设需要按从小到大排序）
	- 胜者树记录胜者（较小的值），并派胜者继续向上
	- 败者树**记录败者**，但仍然**派胜者**继续向上
- 根结点的上一层另外**增加一个结点**，存放树中当前记录排序码**最小的结点** (最小记录)。
	- 这个额外节点存储的就是最终胜者（最小记录）

- 败者树叶结点 key\[]有 k+1 个, key\[0]到 key\[k-1]存放各归并段当前参加归并的**记录的排序码**， key\[k]是辅助工作单元, 在初始建立败者树时使用: 存放一个最小的在各归并段中不可能出现的排序码: -**MaxValue。**
- 败者树非叶结点 loser[]有 k 个, 其中 loser\[1]到 loser\[k-1] 存放各次比较**的败者的归并段号** , loser\[0]中是**最后胜者**所在归并段号。另外还有一个存放各归并段参加归并记录的数组 r\[k]。
- 每选出一个当前排序码最小的记录, 就需要在将它**送入输出缓冲区之后,** 从相应归并段的输入缓冲区中**取出下一个参加归并的记录**, 替换已经取走的最小记录, 再从叶结点到根结点, 沿某一特定路径进行调整, 将下一个排序码最小记录的归并段号调整到 loser\[0]中。
- **段结束标志** MaxNum 升入 loser\[0], 排序完成

- ![image.png|325](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228214220.png)
- ![image.png|325](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228215114.png)

- 败者树的高度为 $\lceil \log_{2}k \rceil+1$
	- 每次调整时做 $\lceil \log_{2}k \rceil$ 次排序（这是优于堆的最坏情况的）

- 在内存中应为每一个归并段分配一个**输入缓冲区**, 其大小应能容纳**一个页块**的记录, 编号与归并段号一致。每个输入缓冲区应有一个指针, 指示当前参加归并的记录。
- 在内存中还应设立一个**输出缓冲区**, 其大小相当于**一个页块**大小。它也有一个缓冲区指针, 指示当前可存放结果记录的位置。每当一个记录 i 被选出, 就执行 OutputRecord (i)操作, 将记录存放到输出缓冲区中。

- 多路归并的具体过程
![[多路合并.pdf]]
