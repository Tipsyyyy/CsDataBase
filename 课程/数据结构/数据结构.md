## **概念**

- 数据：数据是信息的载体，是描述客观事物的数、字符、以及所有能输入到计算机中，被计算机程序识别和处理的符号（数值、字符等）的集合。
- 数据元素（数据成员）: 是数据的基本单位。在不同的条件下，数据元素又可称为元素、结点、顶点、记录等。
- 数据对象：具有相同性质的数据元素（数据成员）的集合。
- 逻辑结构：是对数据成员之间的逻辑关系的描述，它可以用一个数据成员的集合和定义在此集合上的若干关系来表示
- 物理结构：是逻辑结构在计算机中的表示和实现，故又称“存储结构”

- 存储结构是逻辑结构在存储器中的映象
  - 数据元素的映象：任何数据元素在计算机中最终都是转化成一个二进制的位串。
  - 关系的映象：顺序映象、链式映象、索引存储方法、散列存储方法
- 分类
  - **线性**结构：表、栈、队列
  - 非线性结构：
    - **层次**结构： 树，二叉树，堆
    - **网状**结构： 图 
    - 其它：集合
- 抽象数据类型ADT：逻辑设计和物理实现分离
  - 由基本数据类型组成，并包含相关的操作

- 算法的效率包括时间代价和空间代价，前者指的是算法执行时间；后者指的是算法执行过程中所需的**最大**存储空间。
- 算法效率：
  - 后期测试（计时）
  - 事前估计

## 杂项

### 数据结构的形式定义

- 由数据对象和关系组成 Data_Structure = {D, R}
- 由数据集合、关系集合、关系组成
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230912205130886.png" alt="image-20230912205130886" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230912205142916.png" alt="image-20230912205142916" style="zoom:33%;" />

### 序步衡量时间复杂度

- 注释：程序步数为0  

- 声明语句：程序步数为0  

- 表达式、赋值语句：程序步数为1 

- 循环语句：**循环控制语句**每次执行的程序步数为1（尤其注意）

- ```c++
  float sum ( float a[ ], const int n )	{
      float s = 0.0;
      count++;	//count统计执行语句条数
      for ( int i = 0; i < n; i++ ) {
          count+=2;	//针对for语句（i++及比较）
          s += a[i];
          count++; //针对赋值语句
      }	
      count+=2;	//针对for的最后一次
      count++;	//针对return语句
      return s;
  }       //执行结束得 程序步数 count =3 * n + 4
  
  void d(ArrayElement x[],int n){
      int i=0;
      count++;
      do{
          x[i]+=2;i+=2;
          count+=3;
      }while(i<n);
      i=0;
      count++;
      while(i<(n/2)){
          x[i]+=x[i+1];i++;
          count+=3;
      }
      count++;
  }
  ```
  
  - `x = sum (R, n);`则为$1+3*n+4=3*n+5$

## 线性表

- $n(\ge0)$个表项的有限序列$L=(a_1,\dots,a_n)$
- 顺序表：顺序存储方式
  - 存储利用率高，存取速度快
  - 插入、删除等操作时需要移动大量数据
- 链表：链表存储方式
  - 适应表的动态增长和删除
  - 需要额外的指针存储空间
- 存储不同类型数据：使用union类型作为节点
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929172422466.png" alt="image-20230929172422466" style="zoom:33%;" />

### 顺序表

- 顺序表类的定义

  - ```c++
    #include <iostream.h>	       //定义在“seqList.h”中
    #include <stdlib.h>
    #include “linearList.h"
    const int defaultSize = 100;
    template < class E>
        class SeqList: public LinearList<E> {
            protected:
            E *data;		     //存放数组
            int maxSize;	     //最大可容纳表项的项数
            int last;		     //当前已存表项的最后位置
            void reSize(int newSize);	//改变数组空间大小
            public:
            SeqList(int sz = defaultSize);          //构造函数
            SeqList(SeqList<E>& L);	           //复制构造函数
            ～SeqList() {delete[ ] data;}	           //析构函数
            int Size() const {return maxSize;}	 //求表最大容量
            int Length() const {return last+1;}  //计算表长度
            int Search(E& x) const;	
            //搜索x在表中位置，函数返回表项序号
            int Locate(int i) const;
            //定位第 i 个表项，函数返回表项序号
            bool getData(int i, E& x) const;  //取第i个表项的值
            bool Insert(int i, E x);			//插入
            bool Remove(int i, E& x);		//删除
        };
    
    #include <stdlib.h>      //操作“exit”存放在此
    #include “seqList.h”    //操作实现放在“seqList.cpp”
    template <class E>
        SeqList<E>::SeqList(int sz) { 
            if (sz > 0) {
                maxSize = sz;  last = -1;
                data = new E[maxSize];	   //创建表存储数组
                if (data == NULL){   //动态分配失败
                    cerr << "存储分配错误！" << endl;  
                    exit(1); 
                }
            }
        };
    template <class E>
        SeqList<E>::SeqList ( SeqList<E>& L ) {
            maxSize = L.Size(); 
            last = L.Length()-1; 
            E value;
            data = new E[maxSize];	//创建存储数组
            if (data == NULL)		//动态分配失败
            {cerr << "存储分配错误！" << endl;     exit(1);}
            for (int i = 1; i <= last+1; i++)    //传送各个表项
            {L.getData(i, value); data[i-1] = value;}
        };
    template <class E>
        int SeqList<E>::Search(E & x) const {
            //在表中顺序搜索与给定值 x 匹配的表项，找到则
            //函数返回该表项是第几个元素，否则函数返回0
            for (int i = 0; i <= last; i++)	//顺序搜索
                if ( data[i] == x ) 
                    return i+1; //表项序号和表项位置差1
            return 0;		    //搜索失败
        };
    template <class E> 
        bool SeqList<E>::Insert (int i, E x) {
            //将新元素x插入到表中第i (1≤i≤last+2) 个表项位
            //置。
            if (last == maxSize-1) return false;        //表满
            if (i < 1 || i > last+2) return false;  //参数i不合理
            for (int j = last; j >= i-1; j--)                 //依次后移
                data[j+1] = data[j]; 
            data[i-1] = x;	      //插入(第 i 表项在data[i-1]处)
            last++;
            return true;		           //插入成功
        };
    template <class E>
        bool SeqList<E>::Remove (int i, E& x) {
            //从表中删除第 i (1≤i≤last+1) 个表项，通过引用型
            //参数 x 返回被删元素。
            if (last == -1) return false;	           //表空
            if (i < 1 || i > last+1) return false;//参数i不合理
            x = data[i-1];  	
            for (int j = i; j <= last; j++)      //依次前移，填补
                data[j-1] = data[j];
            last--;
            return true; 	
        };	
    
    ```

- 实现集合运算

  - ```c++
    void Union ( SeqList<int> & LA,
                                    SeqList<int> & LB ) {
         int n = LA.Length ( );
         int m = LB.Length ( );
         int x;
         for ( int i = 1; i <= m; i++ ) {
    	 LB.getData(i, x);     //在LB中取一元素
    	 int k = LA.Search (x);     //在LA中搜索它
    	 if ( k == 0 )                //若未找到插入它
                 {n++; LA.Insert (n, x);}
         }
     }
    void Intersection ( SeqList<int> & LA,
                                     SeqList<int> & LB ) {
         int n = LA.Length ( );
         int m = LB.Length ( );  int i = 1; int x;
         while ( i <= n ) {
             LA.getData (i, x);    //在LA中取一元素
     	int k = LB.Search (x);      //在LB中搜索它	
    	if ( k == 0 ) { LA.Remove (i,x);  n--;}
    				//未找到,在LA中删除它
    	else i++;                
         }
     }
    ```

- 查找元素的代价（比较次数）
  - 比较成功$\frac1n*(1+\dots+n)=\frac{1+n}2$
  - 比较失败$n$
- 顺序表插入的时间代价（移动次数）
  - $\frac1{1+n}*(n+\cdots+1+0)=\frac n2$
- 删除元素的代价（移动次数）
  - $\frac 1n *(n-1+\cdots+1)=\frac{n-1}2$

### 链表

- 定义

  - 结构方式

    - ```c++
       struct LinkNode {	        //链表结点结构	
               int data;		        //结点数据, 整型	
               LinkNode * link;            //结点指针		
       };
        
      class List {	     //链表类
          public:
               … 	
          private:
              LinkNode *first ;            //表头指针
       };
      ```

  - 复合方式

    - ```c++
       class List;	                    //复合方式
       class LinkNode {	        //链表结点类	
       friend class List;	        //链表类为其友元类
       private:
           int data;		        //结点数据, 整型	
           LinkNode * link;            //结点指针		
       };
       class List {	                    //链表类		
       private:
           LinkNode *first ;            //表头指针
       };
      ```

  - 嵌套方式

    - ```c++
      class List {	                    //链表类	
        public:
          …
       private:
          class LinkNode {	        //链表结点类	
            public:
                int data;		        //结点数据, 整型	
                LinkNode * link;            //结点指针		
       };
      
           LinkNode *first ;            //表头指针
       };
      ```

  - 继承方式

    - ```c++
      class LinkNode {	        //链表结点类	
           protected:
               int data;		        //结点数据, 整型	
               LinkNode * link;            //结点指针		
       };
       class List: pubic class LinkNode {	     //链表类
          public:
               … 	
          private:
              LinkNode *first ;            //表头指针
       };
      ```

- 插入

  - ```c++
    bool List::Insert(int i, int x) {
        //将新元素 x 插入到第 i 个结点之后。i 从1开始，
        //i = 0 表示插入到首元结点之前。
        if (first == NULL || i == 0) {	  //空表或首元结点前
            LinkNode *newNode = new LinkNode(x);		  //建立一个新结点
            newNode->link = first;  first = newNode;
            //新结点成为首元结点
        }			 		
        else {                     //否则，寻找插入位置
            LinkNode *current = first;	  int k = 1;     
            while (k < i && current != NULL)    //找第i结点
            { current = current->link;  k++; }
            if (current == NULL && first != NULL)    //链短
            {cerr << “无效的插入位置!\n”;  return false;}
            else {		 //插入在链表的中间
                LinkNode *newNode = new LinkNode(x);
                newNode->link = current->link;
                current->link = newNode;
            }
        }
        return true; 
    };
    
    ```

  - 三类：头中尾

- 删除

  - ```c++
    bool List::Remove (int i, int& x) {
    //将链表中的第 i 个元素删去, i 从1开始。
        LinkNode *del;		//暂存删除结点指针
    	if (i <= 1)  { del = first;  first = first->link; }
    	else { 
            LinkNode *current = first;  k = 1;   //找i-1号结点
    	    while (k < i-1 && current != NULL)	
      		  { current = current->link;   k++; }
    	    if (current == NULL || current->link == NULL) { 	  cout << “无效的删除位置!\n”;  return false;
            }	
            del = current->link;  	 //删中间/尾结点
    	 	 current->link = del->link;		
    	  }
    	  x = del->data;  delete del; 	//取出被删结点数据
    	  return true;			
    };
    
    ```

- 使用附加头节点统一操作

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231108142313329.png" alt="image-20231108142313329" style="zoom:33%;" />
  
- 双向循环列表

  - ```c++
    template <class E> 
        struct DblNode {		//链表结点类定义
            E data;			//链表结点数据
            DblNode<E> *lLink, *rLink;//前驱、后继指针
            DblNode ( DblNode<E> *l = NULL, 
                     DblNode<E> *r = NULL ) 
            { lLink = l;  rLink = r; }           //构造函数
            DblNode ( E value, DblNode< E> *l = NULL, DblNode<E> *r = NULL)
            { data = value;  lLink = l;  rLink = r; }  //构造函数
        };
    template <class E>
        class DblList {		//链表类定义
            public:
            DblList ( E uniqueVal ) {	        //构造函数
                first = new DblNode<E> (uniqueVal);
                first->rLink = first->lLink = first;
            };
    
            DblNode<E> *getFirst () const { return first; }
            void setFirst ( DblNode<E> *ptr ) { first = ptr; }
            DblNode<E> *Search ( E x, int d);	
            //在链表中按d指示方向寻找等于给定值x的结点,
            //d=0按前驱方向,d≠0按后继方向
            DblNode<E> *Locate ( int i, int d );	
            //在链表中定位序号为i(≥0)的结点, d=0按前驱方
            //向,d≠0按后继方向
            bool Insert ( int i, E x, int d );
            //在第i个结点后插入一个包含有值x的新结点,d=0
            //按前驱方向,d≠0按后继方向
            bool Remove ( int i, E& x, int d );   //删除第i个结点
            bool IsEmpty() { return first->rlink == first; }
            //判双链表空否
            private:
            DblNode<E> *first;                 //表头指针
        };
    template <class E>
        DblNode< E> *DblList<E>::Search (E x, int d) {
            //在双向循环链表中寻找其值等于x的结点。
            DblNode<E> *current = (d == 0)?
                first->lLink : first->rLink;   //按d确定搜索方向
            while ( current != first && current->data != x )	current = (d == 0) ? 
                current->lLink : current->rLink;
            if ( current != first ) return current;	   //搜索成功
            else return NULL;			   //搜索失败
        };
    //查住删除可以使用search寻址，避免重复
    ```

  - 同样可以添加一个头节点避免讨论

    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929182712053.png" alt="image-20230929182712053" style="zoom: 25%;" />
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929182722977.png" alt="image-20230929182722977" style="zoom:25%;" />

- 静态链表
  - 为数组中每一个元素附加一个链接指针，就形成静态链表结构。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929190709672.png" alt="image-20230929190709672" style="zoom:33%;" />

#### 应用：多项式运算

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929183126551.png" alt="image-20230929183126551" style="zoom:33%;" />
- 使用顺序表存储：更适用于指数连续排列的多项式
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929183408098.png" alt="image-20230929183408098" style="zoom:25%;" />
- 链表存储
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929185343560.png" alt="image-20230929185343560" style="zoom:25%;" />
  
- ```c++
  struct Term {	            //多项式结点定义	
      float coef;	            //系数		
      int exp;		            //指数
      Term *link;		  //链接指针
      Term (float c, int e, Term *next = NULL)
      { coef = c;  exp = e;  link = next;}
      Term *InsertAfter ( float c, int e); 
      friend ostream& operator << (ostream&, 
                                   const Term& );
  }; 
  class Polynomial {			//多项式类的定义
      public:
      Polynomal() { first = new Term(0, -1); }	//构造函数
      Polynomal (Polynomal& R);            //复制构造函数
      int maxOrder();	  			  //计算最大阶数
      private:
      Term *first;
      friend ostream& operator << (ostream&, 
                                   const Polynomal& );
      friend istream& operator >> ( istream&, 
                                   Polynomal& );
      friend void Add ( Polynomial& A, Polynomial& B,
                       Polynomial& C );
      friend void Mul ( Polynomial& A, Polynomial& B, 
                       Polynomial& C );
  };
  ```

  - 加法运算：
    - 双指针：指数不等，小者加入结果；指数相等，如果相加后结果不为0则加入结果；一个指针为null，将另一个链的剩余部分加入到结果。




## 栈和队列

- **限制存取位置的线性结构**

### 栈

- 数组实现
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231108145739856.png" alt="image-20231108145739856" style="zoom:50%;" />

- ```c++
  template <class E> class Stack {	
      public:
      Stack ( int=10 );		   //构造函数
      void Push ( const E & item);  //进栈
      E Pop ( );                     //出栈
      E getTop ( );               //取栈顶元素
      void makeEmpty ( );         //置空栈
      int IsEmpty ( ) const;        //判栈空否
      int IsFull ( ) const;           //判栈满否
  }
  
  #include <assert.h>
  template <class E> class SeqStack : public Stack<E> {
      private:
      int top;	                           //栈顶指针
      E *elements;	         //栈元素数组
      int maxSize;	                  //栈最大容量
      void overflowProcess();	//栈的溢出处理
      public:
      Stack (int sz = 10);               //构造函数    
      ~Stack ( ) { delete [ ] elements; }
      void Push (E x);             //进栈    
      int Pop (E& x);              //出栈
      int getTop (E& x);        //取栈顶
      void makeEmpty ( ) { top = -1; }   //置空栈
      int IsEmpty ( ) const { return top == -1; } 
      int IsFull ( ) const 
      { return top == maxSize-1; }	
  }
  template <class E>
      void SeqStack<E>::overflowProcess() {
          //私有函数：当栈满则执行扩充栈存储空间处理
          E *newArray = new E[2*maxSize];				//创建更大的存储数组
          for (int i = 0; i <= top; i++) 
              newArray[i] = elements[i];
          maxSize += maxSize;  
          delete [ ]elements;  
          elements = newArray;  	//改变elements指针
      }; 
  template <class E>
      void SeqStack<E>::Push(E x) {   
          //若栈不满, 则将元素x插入该栈栈顶, 否则溢出处理
          if (IsFull() == true) overflowProcess();	      //栈满
          elements[++top] = x;	     //栈顶指针先加1, 再进栈
      }; 
  
  template <class E>
      bool SeqStack<E>::Pop(E& x) {
          //函数退出栈顶元素并返回栈顶元素的值
          if (IsEmpty() == true) return false;
          x = elements[top--];	     //栈顶指针退1
          return true;		     //退栈成功
      };
  template <class E>
      bool Seqstack<E>::getTop(E& x) {
          //若栈不空则函数返回该栈栈顶元素的地址
          if (IsEmpty() == true) return false;
          x = elements[top];
          return true;
      };
  
  ```

- n个元素入栈，可能的出栈顺序数目：
  - 枚举第一个元素的出栈时间，分治$f(n) = \sum_{i=1}^{i=n}{f(i-1)*f(n-i)} $（卡特兰数），通项为$f(n) = \frac{C_{2n}^{n}}{n+1}$
  - 在于在第一个元素入栈之后出栈之前有i-1个元素入栈又出栈，这可以作为一个类似的子问题

- 多栈共享栈空间
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929192722735.png" alt="image-20230929192722735" style="zoom:33%;" />
  
  - ```c++
    bool Push(DualStack& DS, E x, int i) {
         if (DS.t[0]+1 == DS.t[1]) return false;//已满
         if (i == 0) DS.t[0]++; else DS.t[1]--;
         DS.V[DS.t[i]] = x;   
         return true;
    }
    
    bool Pop(DualStack& DS, E & x, int i) {
         if (DS.t[i] == DS.b[i]) return false;//为空
         x = DS.V[DS.t[i]]; 
         if (i == 0) DS.t[0]--; else DS.t[1]++;
         return true;
    } 
    ```
  
- 链式栈
  - **栈顶在链头**
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929193637012.png" alt="image-20230929193637012" style="zoom:33%;" />
  - ```c++
    template <class E>
    LinkedStack<E>::makeEmpty() {	
    //逐次删去链式栈中的元素直至栈顶指针为空。
        StackNode<E> *p;
    	while (top != NULL)		//逐个结点释放
            { p = top;  top = top->link;  delete p; }
    };
    
    template <class E>
    void LinkedStack<E>::Push(E x) {
    //将元素值x插入到链式栈的栈顶,即链头
         top = new StackNode<E> (x, top);	//创建新结点
         assert (top != NULL);		//创建失败退出
    };
    template <class E>
    bool LinkedStack<E>::Pop(E& x) {
    //删除栈顶结点, 返回被删栈顶元素的值。
        if (IsEmpty() == true) return false;   //栈空返回
      	 StackNode<E> *p = top;		//暂存栈顶元素
    	 top = top->link;			//退栈顶指针
    	 x = p->data;   
        delete p;		//释放结点
        return true;	
    };
    template <class E>
    bool LinkedStack<E>::getTop(E& x) const {	
    	  if (IsEmpty() == true) return false;   //栈空返回
    	  x = top->data;                       //返回栈顶元素的值
         return true;
    	};
    template <class E>
    ostream& operator << (ostream& os, 
              LinkedStack<E> & s) {
         //输出栈中元素的重载操作<<
         os << “栈中元素个数=”<<s.getSize() << endl;
         LinkNode<E> * p = s.top; int i = 0;
         while (p != NULL) {
              os << ++i << “:” <<p->data << endl; 
              p = p-> link;         
         }
          return os;
    };
    ```
  - 

#### 应用：表达式的计算

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929193806916.png" alt="image-20230929193806916" style="zoom:33%;" />
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929193948093.png" alt="image-20230929193948093" style="zoom:33%;" />

  - ```c++
    void Calculator :: Run ( ) {
        char ch;   double newoperand;
        while ( cin >> ch,  ch != ‘;’ ) { 
            switch ( ch ) {
                case ‘+’ :  case ‘-’ :   case ‘*’ :   case ‘/’ :            	case ‘^’ :  DoOperator ( ch );  break;   			                         //计算
                default :  cin.putback ( ch ); 
                    //将字符放回输入流
                    cin >> newoperand;  //读操作数
                    S.Push( newoperand );
            }
        }
    }
    void Calculator :: DoOperator ( char op ) {
        //从栈S中取两个操作数，形成运算指令并计算进栈
        double left, right;   bool result;
        result = Get2Operands(left, right); //退出两个操作数
        if ( !result ) return;
        switch ( op ) {
            case ‘+’: S.Push ( left + right);  break;     //加
            case ‘-’: S.Push ( left - right);  break;     //减
            case ‘*’: S.Push ( left * right);  break;      //乘
            case ‘/’: if ( right != 0.0 ) {S.Push ( left / right); break; }
                else { cout << “除数为0!\n” );  exit(1); } //除
            case ‘^’: S.Push ( Power(left,right) ); //乘幂
        }
    }
    bool Calculator :: Get2Operands(double& left, 
                                    double& right ) {
        //从栈S中取两个操作数
        if (S.IsEmpty( ) == true)
        {cerr << “缺少右操作数！”<< endl; return false;}
        S.Pop(right);
    
        if (S.IsEmpty( ) == true)
        {cerr << “缺少左操作数！”<< endl; return false;}
        S.Pop(left);
    
        return true;
    }
    
    ```
  - 

- 由中缀生成后缀表达式

  - 手动转化方式
    - 先对中缀表达式按运算优**先次序加上括号**，再**把操作符后移到右括号的后面**并以就近移动为原则，最后将所有括号消去。
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231108151451666.png" alt="image-20231108151451666" style="zoom:50%;" />

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929194833254.png" alt="image-20230929194833254" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929194856002.png" alt="image-20230929194856002" style="zoom:33%;" />
    - 如果是**数字直接输出**
    - ；作为额外的第一个和最后一个元素
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231107212727767.png" alt="image-20231107212727767" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231107212737135.png" alt="image-20231107212737135" style="zoom:50%;" />
  - 补充：c++运算优先级
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231108193455527.png" alt="image-20231108193455527" style="zoom:50%;" />


#### 栈与递归

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929201421957.png" alt="image-20230929201421957" style="zoom:33%;" />

- 借助栈将递归过程改为非递归过程，可以提高效率
  - **单向递归和尾递归**可直接用迭代实现其非递归过程 其他情形必须借助栈实现非递归过程
  - 其他情形必须借助**栈**实现非递归过程
- 栈的链表实现头指针指向栈顶(这样栈顶出栈后才能继续向下访问)

### 队列

- ```c++
  template <class E>
  class Queue {
  public:
       Queue() { };	      //构造函数
       ～Queue() { };	      //析构函数
       virtual bool EnQueue(E x) = 0;           //进队列
       virtual bool DeQueue(E& x) = 0;	      //出队列
       virtual bool getFront(E& x) = 0;	      //取队头  
       virtual bool IsEmpty() const = 0;	      //判队列空
       virtual bool IsFull() const = 0;	      //判队列满
  };
  
  #include <assert.h>
  #include <iostream.h>
  #include “Queue.h”
  template <class E>
  class SeqQueue : public Queue<E> {	   //队列类定义
  protected:
       int rear, front;		       //队尾与队头指针
       E *elements;		       //队列存放数组
       int maxSize;		       //队列最大容量
  public: 
      SeqQueue(int sz = 10);    //构造函数 
      ～SeqQueue() { delete[ ] elements; }  //析构函数
       bool EnQueue(E x);         //新元素进队列
       bool DeQueue(E& x);      //退出队头元素
       bool getFront(E& x);	      //取队头元素值
       void makeEmpty() { front = rear = 0; }		
       bool IsEmpty() const { return front == rear; }	
       bool IsFull() const 
           { return rear ==maxSize; }	
       int getSize() const 
           { return rear-front; }	
  };
  
  ```

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929202943266.png" alt="image-20230929202943266" style="zoom:33%;" />

  - 进队：rear++；出队：front++

  - 队空时：rear=front；队满时：rear=maxSize

  - 随着元素进入与弹出，逐渐无法使用，出现假溢出

  - 解决：将队列元素存放数组首尾相接，形成循环（环形）队列

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929203307925.png" alt="image-20230929203307925" style="zoom: 33%;" />
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231107220444662.png" alt="image-20231107220444662" style="zoom:33%;" />
    
  - 循环队列的定义

  - ```c++
    void MakeEmpty() { front = rear = 0; }
    int IsEmpty() const { return front == rear; }
    int IsFull() const
        { return (rear+1) % maxSize == front; }
        
    template <class E> 
    SeqQueue<E>::SeqQueue(int sz) 
        : front(0), rear(0), maxSize(sz) {     //构造函数
          elements = new E[maxSize];		
          assert ( elements != NULL );
    };
    template <class E>
    bool SeqQueue<E>::EnQueue(E x) {           
    //若队列不满, 则将x插入到该队列队尾, 否则返回    
      if (IsFull() == true) return false;   
         elements[rear] = x;                    //先存入
         rear = (rear+1) % maxSize;       //尾指针加一
         return true;			
    };
    template <class E>
    bool SeqQueue<E>::DeQueue(E& x) { 
    //若队列不空则函数退队头元素并返回其值
         if (IsEmpty() == true) return false;    
         x = elements[front];                  //先取队头
         front = (front+1) % maxSize;   //再队头指针加一
         return true;
    };
    
    template <class E>
    bool SeqQueue<E>::getFront(E& x) const {
    //若队列不空则函数返回该队列队头元素的值
         if (IsEmpty() == true) return false;    //队列空
    	 x = elements[front];		    //返回队头元素
    	 return true;
    }; 
    ```

- 链式队列

  - 没有队满问题，但是有队空问题（front==NULL）
  
  - ```c++
    #include <iostream.h>
    #include “Queue.h”
    template <class E>
        struct QueueNode {                   //队列结点类定义	
            private: 
            E data;			          //队列结点数据
            QueueNode<E> *link;          //结点链指针
            public:
            QueueNode(E x = 0, QueueNode<E>
                      *next = NULL) : data(x), link(next) { }
        };  
    template <class E>
        class LinkedQueue {	
            private: 
            QueueNode<E> *front, *rear;   //队头、队尾指针
            public: 
            LinkedQueue() : rear(NULL), front(NULL) { }
            ~LinkedQueue();					
            bool EnQueue(E x);
            bool DeQueue(E& x);			
            bool getFront(E& x);			
            void makeEmpty();            //实现与~Queue()同
            bool IsEmpty() const { return front == NULL; }
        };
    //操作时需要讨论是否为空
    template <class E> 
        bool LinkedQueue<E>::EnQueue(E x) {
            //将新元素x插入到队列的队尾
            if (front == NULL)  {              //创建第一个结点
                front = rear = new QueueNode<E> (x);
                if (front == NULL) return false; }	//分配失败 
            else {                                      //队列不空, 插入
                rear->link = new QueueNode<E> (x);
                if (rear->link == NULL) return false; 
                rear = rear->link;
            }
            return true;
        };
    template <class E>
        //如果队列不空，将队头结点从链式队列中删去 
        bool LinkedQueue<E>::DeQueue(E& x) {
            if (IsEmpty() == true) return false;        //判队空
            QueueNode<E> *p = front;		
            x = front->data;  front = front->link;   
            delete p;   return true;				
        };
    
    template <class E> 
        bool LinkedQueue<E>::getFront(E& x) {
            //若队列不空，则函数返回队头元素的值 
            if (IsEmpty() == true) return false; 	
            x = front->data;  return true;
        };
    
    ```
  
  - 
  
- 优先级队列： 是不同于先进先出队列的另一种队列。每次从队列中取出的是具有最高优先权(优先级)的元素

  - 数组实现：每次**插入到相应位置维护顺序**

- 队列的应用

  - 可以使用队列计算杨辉三角
    - 因为从前一行的数据可以计算得到下一行的数据
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231107222221641.png" alt="image-20231107222221641" style="zoom: 50%;" />


## 数组、串和广义表

### 数组

- 数组是相同类型的数据元素的集合

- 多维数组的特点是每一个数据元素可以有**多个直接前驱和多个直接后继**。（不同维度上）

- 二位数组的动态初始化

  - ```c++
    int **A;
    int row =  3, col = 3;   int i, j;          
    A = new int *[row];
    for (i = 0; i < row; i++)
        A[i] = new int [col];
    for (i = 0; i < row; i++)
        for (j = 0; j < col; j++)  cin >> A[i][j];
    ```

- n维数组元素存储地址$a+(\sum_{j=1}^{n-1}(i_j*\prod^n_{k=j+1})+i_n)*l$

### 特殊矩阵

- 特殊矩阵是指非零元素或零元素的**分布有一定规律**的矩阵。 特殊矩阵的压缩存储主要是针对阶数很高的特殊矩阵。为**节省存储空间**，对可以不存储的元素，如零元素或对称元素，不再存储。

#### 对称矩阵

- $a_{ij}==a_{ji}$

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024003216377.png" alt="image-20231024003216377" style="zoom:33%;" />

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024004056130.png" alt="image-20231024004056130" style="zoom:33%;" />

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024004047829.png" alt="image-20231024004047829" style="zoom:33%;" />

- 为节约存储，只存对角线及对角线以上的元素，或者只存对角线或对角线以下的元素。前者称为上三角矩阵，后者称为下三角矩阵

  - 按行存储在一维数组中，元素数目为$n*(n+1)/2$

  - **下三角矩阵中**，对于$i>=j$数组元素$A[i][j]$在数组中存放位置为$1+2+\cdots+i+j=(i+1)*i/2+j$
  - 上三角矩阵中找对称元素即可
    
  - 已知位于位置k，则$i*(i+1)/2<=k<(i+1)*(i+2)/2$的i及$j=k-i*(i+1)/2$的到元素的下标
  
- 对于**上三角矩阵**$A[i][j]$(i<=)位于$n+(n-1)+\dots+(n-i+1)+j-i=(2*n-i-1)*i/2+j$

#### 三对角矩阵

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024004256950.png" alt="image-20231024004256950" style="zoom:33%;" />

- 有$3n-2$个非0元素,$0<=i<=n-1 \ i-1<=j<=i+1$

- $A[i][j]$位于$k=2*i+j$

  - 前面$3*i-1$，$j$前面$j-i+1$

- 对于位于$k$的元素

  - $$
    i=\lfloor(k+1)/3\rfloor \\
    j=k-2*i
    $$

### 稀疏矩阵

- 非零元素的数目$s$远远小于矩阵元素的总数

- 稀疏因子$e=s/(m*n)$
  - 通常认为$e<=0.05$为稀疏矩阵
  - 存储稀疏矩阵时一般只存储非零元素，为了确定其元素的位置必须记下元素的下标，即使用三元组$(i,j,a_{ij})$表示矩阵的元素
  
- 在稀疏矩阵的三元组表中，**非零矩阵元素按行存放。当行号相同时，按列号递增的顺序存放。**

- ```c++
  const int drows = 6,  dcols = 7, dterms = 9;
  template<class E>
  struct Triple {               //三元组
       int row, col;	       //非零元素行号/列号
       E value;                   //非零元素的值
       void operator = (Triple<E>& R)      //赋值
          { row = R.row;  col = R.col;  value = R.value; }
  };		
  template <class E>
  class SparseMatrix {
    public: 
       SparseMatrix (int Rw = drows, int Cl = dcols,
            int Tm = dterms);                   //构造函数
       void Transpose(SparseMatrix<E>& b);    //转置
       void Add (SparseMatrix<E>& a,
            SparseMatrix<E>& b);          //a = a+b
       void Multiply (SparseMatrix<E>& a,
            SparseMatrix<E>& b);          //a = a*b
    pvivate:
       int Rows, Cols, Terms;        //行／列／非零元素数
       Triple<E> *smArray;          //三元组表
  };            
  template <class E>
  SparseMatrix<E>::SparseMatrix (int Rw, int Cl, int Tm) {
      Rows = Rw;   Cols = Cl;   Terms = Tm;
      smArray = new Triple[Terms];          //三元组表
      if (smArray == NULL) {
           cerr << “存储分配失败！” << endl;  exit(1);
      }
  };  
  ```

- 转置

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024005417040.png" alt="image-20231024005417040" style="zoom:33%;" />

  - 设矩阵列数为 Cols，对矩阵三元组表扫描Cols 次。  第 k 次扫描找寻所有**列**号为 k 的项，将其行号变列号、列号变行号，**顺次存于转置矩阵三元组表。**

  - ```c++
    template <class E>
        void SparseMatrix<E> ::
    Transpose (SparseMatrix<E>& B) {
        //转置this矩阵，转置结果由B返回
        B.Rows = Cols;   B.Cols = Rows; 
        B.Terms = Terms;
        //转置矩阵的列数,行数和非零元素个数
        if (Terms > 0) {				
            int CurrentB = 0;   //转置三元组表存放指针
            int i, k;
            for (k = 0; k < Cols; k++)       //处理所有列号
                for (i = 0; i < Terms; i++) 		
                    if (smArray[i].col == k) {		
                        B.smArray[CurrentB].row = k;	
                        B.smArray[CurrentB].col = 
                            smArray[i].row;
                        B.smArray[CurrentB].value=
                            smArray[i].value;	
                        CurrentB++;					
                    }
        }
    };    
    ```

- 快速转置

  - 对原矩阵A 扫描一遍（实际为两遍，建辅助数组需扫描一遍），按 A 中每一元素的列号，**立即确定在转置矩阵 B 三元组表中的位置**，并装入它。

  - rowSize记录矩阵转置前**各列**，即转置矩阵**各行非零元素个数**；

  - rowStart记录转置矩阵**各行**非零元素在转置三元组表中**开始存放位置**。

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024005924543.png" alt="image-20231024005924543" style="zoom: 33%;" />

  - ```c++
    template <class E> 
        void SparseMatrix<E>::
    FastTranspose (SparseMatrix<E>& B) {
        int *rowSize = new int[Cols];       //列元素数数组
        int *rowStart = new int[Cols];      //转置位置数组
        B.Rows = Cols;   B.Cols = Rows;
        B.Terms = Terms;
        if (Terms > 0) {
            int i, j;
            for (i = 0; i < Cols; i++) rowSize[i] = 0;        
            for (i = 0; i < Terms; i++)
                rowSize[smArray[i].col]++; 
            rowStart[0] = 0;	
            for (i = 1; i < Cols; i++)			
                rowStart[i] = rowStart[i-1]+rowSize[i-1];
            for (i = 0; i < Terms; i++) {			
                j = rowStart [smArray[i].col];		
                B.smArray[j].row = smArray[i].col;
                B.smArray[j].col = smArray[i].row;
                B.smArray[j].value = smArray[i].value;
                rowStart [smArray[i].col]++;		
            }  
        }    
        delete [ ] rowSize;   delete [ ] rowStart;
    }      
    
    ```

##### 带行指针的二元组表

- 稀疏矩阵的三元组表可以用**带行指针数组的二元组表代替**。稀疏矩阵的三元组表可以用带行指针数组的二元组表代替。
- 在行指针**数组中元素个数**与矩阵**行数**相等。第 i 个元素的下标 i 代表矩阵的第 i 行，元素的**内容**即为稀疏矩阵第 i 行的第一个**非零元素**在二元组表中的存放位置。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024010536322.png" alt="image-20231024010536322" style="zoom:33%;" />

##### 正交链表示稀疏矩阵

- 适应矩阵操作时（+-*）时矩阵非零元素的动态变化
- 稀疏矩阵表示为行链表与列链表的**十字交叉**，即正交链表（十字链表）
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024010900136.png" alt="image-20231024010900136" style="zoom:33%;" />
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024010908055.png" alt="image-20231024010908055" style="zoom:33%;" />

## 字符串

- 空白串`" "`，空串`""`

- ```c++
  #ifndef ASTRING_H	//定义在文件“Astring.h”中
  #define ASTRING_H
  #define defaultSize = 128;     //字符串的最大长度
  class AString {
      //对象: 零个或多个字符组成的一个有限序列。
      private:
      char *ch;			      //串存放数组
      int curLength;		      //串的实际长度
      int maxSize;		      //存放数组的最大长度
      public:    
      AString(int sz = defaultSize);      //构造函数 	
      AString(const char *init );          //构造函数
      AString(const AString& ob);      //复制构造函数
      ～AString() {delete [ ]ch; }	      //析构函数
      int Length() const { return curLength; }	 //求长度
      Astring& operator() (int pos, int len);   //求子串
      bool operator == (AString& ob) const 
      { return strcmp (ch, ob.ch) == 0; }
      //判串相等. 若串相等, 则函数返回true
      bool operator != (AString& ob) const 
      { return strcmp (ch, ob.ch) != 0; }
      //判串不等. 若串不相等, 则函数返回true  
      bool operator ! () const { return curLength == 0; } 
      //判串空否。若串空, 则函数返回true
      AString& operator = (AString& ob);      //串赋值
      AString& operator += (AString& ob);	//串连接
      char& operator [ ] (int i);		//取第 i 个字符
      int Find (AString& pat, int start) const;    //串匹配
  };
  //构造函数
  AString::AString(int sz) {
  //构造函数：创建一个空串
       maxSize = sz;
       ch = new char[maxSize+1];        //创建串数组
       if (ch == NULL) 
           { cerr << “存储分配错!\n”;  exit(1); }
       curLength = 0;       
       ch[0] = ‘\0’;
  };
  AString::AString(const char *init) {
  //复制构造函数: 从已有字符数组*init复制
       int len = strlen(init);
       maxSize = (len > defaultSize) ? len : defaultSize;
       ch = new char[maxSize+1];     //创建串数组
       if (ch == NULL)
          { cerr << “存储分配错 ! \n”;  exit(1); }
       curLength = len;	 	   //复制串长度
       strcpy(ch, init);		             //复制串值	
   }；
      
  AString :: AString(const AString& ob) {
   //复制构造函数：从已有串ob复制
       maxSize = ob.maxSize;               //复制串最大长度
       ch = new char[maxSize +1];     //创建串数组
       if (ch == NULL) 
           { cerr << “存储分配错! \n”;  exit(1); }
       curLength = ob.curLength;          //复制串长度
       strcpy(ch, ob.ch);                         //复制串值
   };	
  
  AString  AString::operator () (int pos, int len) {
  //从串中第 pos 个位置起连续提取 len 个字符形成
  //子串返回 	
       AString  temp;                           //建立空串对象
       if (pos >= 0 && pos+len-1 < maxSize && len > 0)
       {                                                  //提取子串
  	      if (pos+len-1 >= curLength)  
                 len = curLength - pos;     //调整提取字符数
            temp.curLength = len;           //子串长度
  for (int i = 0, j = pos; i < len; i++, j++) 
  	           temp.ch[i] = ch[j];        //传送串数组
  	      temp.ch[len] = ‘\0’;           //子串结束
       }
       return  temp;
  };	
  
  AString& AString::operator = (const AString& ob) {
       if (&ob != this) {	//若两个串相等为自我赋值
            	delete []ch; 
  		ch = new char[maxSize+1];	//重新分配 
  	     	if (ch == NULL) 
                { cerr << “存储分配失败!\n ”;  exit(1); }
  		curLength = ob.curLength;  strcpy(ch,ob.ch);
       }
  	 else cout << “字符串自身赋值出错!\n”;	
  	 return this;
  }; 
  
  char AString::operator [ ] (int i) {
  //串重载操作：取当前串*this的第i个字符
       if (i < 0 || i >= curLength) 
           { cout << “字符串下标超界!\n ”; exit(1); } 
  	 return ch[i];
  };
  
  AString& AString::operator += (const AString& ob)
  {
       char *temp = ch;		//暂存原串数组
  	 int n = curLength + ob.curLength;	      //串长度累加
  	 int m = (maxSize >= n) ? maxSize : n; //新空间大小
  	 ch = new char[m];
       if (ch == NULL) 
           { cerr << “存储分配错!\n ”;  exit(1); }
  	 maxSize = m;  curLength = n;
  	 strcpy(ch, temp);        	         //拷贝原串数组
  	 strcat(ch, ob.ch);	         //连接ob串数组  	
           delete []temp;  
       return this;
  };
  
  ```

### 串模式匹配

- 在主串中寻找子串（第一个字符）在串中的位置

- 在模式匹配中，子串称为模式，主串称为目标。

- 朴素实现：复杂度$O(n*m)$

  - ```c++
    int AString::Find(AString& pat, int start) const {
    //在当前串中从第 start 个字符开始寻找模式 pat 在当
    //前串中匹配的位置。若匹配成功, 则函数返回首
    //次匹配的位置, 否则返回-1。
         int i, j, n = curLength, m = pat.curLength;
         if (m == 0) return -1;    //pat为空
         for (i = start; i <= n-m; i++) { 
              	for (j = 0; j < m; j++){
                   if (ch[i+j] != pat.ch[j]) break;   //本次失配
               }
               if (j == m) return i;   //pat扫描完, 匹配成功
    	  }
       return -1;	 //在*this中找不到子串
    };	
    ```

#### KMP

##### next数组

- 复杂度$O(n)$

- 由模式串计算，$next[i]$表示$pat[0,i-1]$的最长共同前后缀的长度
- 书上定义（注意书上定义实际上是**之前版本的next[i-1]**）
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024083510277.png" alt="image-20231024083510277" style="zoom:33%;" />如果 j > 0，那么在下一趟比较时模式串 P的起始比较位置是 pnext(j)，目标串 T 的指针不回溯，仍指向上一趟失配的字符；
- 匹配时
  - 如果 j > 0，那么在下一趟比较时模式串 P的起始比较位置是 pnext(j)，目标串 T 的指针不回溯，仍指向上一趟失配的字符；
  - 如果 j = 0，则目标串指针 T 进一，模式串指针 P 回到 p0，继续进行下一趟匹配比较

##### 代码

- ```c++
  vector<int> build_next(string s)//构建next数组
  {
      vector<int>next{-1};//第一位一定为零（因为规定前后缀不能为自身）
      int i=1,len=0;//len记录当前位置最大重合长度
      while(i<s.size())
      {
          if(s[len]==s[i-1]&&len!=i-1)
          {
              len++;
              next.push_back(len);
              i++;
          }
          else
          {
              if(len==0)
              {
                  next.push_back(0);
                  i++;
              }
              else
                  len=next[len];//找到对应的前缀的末尾位置（一种递归思想，长的匹配不上则逐渐缩短去找）
          }
      }
      return next;
  }
      int kmp(string fs,string ss)//ss为待匹配的子串
      {
          vector<int>next=build_next(ss);
          int i=0,j=0;
          while(i<fs.size())
          {
              if(fs[i]==ss[j])
              {
                  i++;
                  j++;
              }
              else if(j>0)
                  j=next[j];//前next[j-1]位仍相同，在这之后继续匹配
              else
                  i++;
              if(j==ss.size())
                  return i-j;
          }
          return -1;
      }
  ```

## 广义表

- 广义表是n个元素组成的有限序列$LS(a_1,\dots,a_n)$

  - **LS是表名**，$a_i$是元素（子表或数据元素）
  - n表示表的长度，$n=0$的表为空表

- n > 0时，表的**第一个表元素**称为广义表 的**表头**（head），除此之外，**其它表元素组成的表**称为广义表的**表尾**（tail）。

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024085427224.png" alt="image-20231024085427224" style="zoom:33%;" />
  - 长度与深度
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231108171244013.png" alt="image-20231108171244013" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024085833176.png" alt="image-20231024085833176" style="zoom:33%;" />
    - 注意:ta返回的**尾元素的元组**,即要**在外面加一组括号**,而head返回表头(单个元素)**不会加上一组额外括号**
    - 表头是一个结点，而表尾是一个广义表
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231108103418890.png" alt="image-20231108103418890" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024090115417.png" alt="image-20231024090115417" style="zoom:33%;" />

- 特性：有次序性、有深度、可递归、有长度、可共享

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024085916942.png" alt="image-20231024085916942" style="zoom:33%;" />

- 广义表结点的定义

  - `utype | info | tlink`
    - 节点类型utype：广义表专用的附加头节点0（**并不是广义表的第一个元素表头，而是一个附加的头节点**，类似于表的标识符ABCD（**表名**））；原子数据1；子表2；
    - 信息info：utype=0时存储引用计数；等于1时存储数据值；等于2时存储子表表头指针
    - 尾指针tlink：utype=0时指向第一个节点；utype!=0时指向同一层下一个节点
  - 存储表示
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231108171439237.png" alt="image-20231108171439237" style="zoom:50%;" />

- ```c++
  template <class T>
      struct GenListNode {	          //广义表结点类定义
          int utype;			//＝0 / 1 / 2
          GenListNode<T> *tlink;	//同层下一结点指针
          union {				//等价变量
              int ref;	                     //存放引用计数
              T value;			//存放数值
              GenListNode<T> *hlink;	  //存放子表指针	
          } info;
          GenListNode()                          //构造函数
              : utype(0), tlink(NULL), info.ref(0) {}
          GenListNode(GenListNode<T>& R) {
              //复制构造函数
              utype = R.utype;   tlink = R.tlink; 
              info = R.info;
          }
      };
  template <class T>
      class GenList {			  //广义表类定义
          public:
          Genlist();			          //构造函数
          ～GenList();			//析构函数 
          bool Head (GenListNode<T>& x);   //x 返回表头
          bool Tail (GenList<T>& lt);	   //lt 返回表尾
          GenListNode<T> *First();	   //返回第一个元素地址(尾元素中)
          GenListNode<T> *Next (GenListNode<T> *elem);
          //返回表元素elem的直接后继元素
          void Copy ( const GenList<T>& R);
          //广义表的复制
          int Length();    		          //计算广义表长度
          int Depth();		
          private:
          GenListNode<T> *first;	//广义表头指针
          GenListNode<T> *Copy (GenListNode<T> *ls);
          //复制一个ls指示的无共享非递归表
          int Length (GenListNode<T> *ls);
          //求由ls指示的广义表的长度
          int Depth (GenListNode<T> *ls);		
          //计算由ls指示的非递归表的深度
          bool Equal (GenListNode<T> *s, 
                      GenListNode<T> *t);
          //判以s和t为表头的两个表是否相等
          void Remove (GenListNode<T> *ls);
          //释放以ls为附加头结点的广义表
          void CreateList (istream &in,  GenListNode<T> *&    ls, SeqList<T>& L1,  SeqList <GenListNode<T> *>& L2);
          //从输入流对象输入广义表的字符串描述, 
          //建立一个带头结点的广义表结构
  
          friend istream& operator >> (istream& in, 
                                       GenList<T>& L);           
      };
  
  template <class T>
      Genlist<T>::GenList() {		//构造函数
          GenListNode<T> * first = new GenListNode;
          if (first == NULL)   { cerr << “存储分配失败！\n”;  exit(1); }
      };
  
  template <class T>
      bool GenList<T>::Head (GenListNode <T>& x) {
          //若广义表非空，则通过x返回其第一个元素的值
          //否则函数没有定义	
          if (first->tlink == NULL) return false;	//空表
          else {						//非空表
              x.utype = first->tlink->utype;
              x.info = first->tlink->info;
              return true;		                 //x返回表头的值
          }
      };	
  template <class T>
      bool GenList<T>::Tail(GenList<T>& lt) {
          //若广义表非空，则通过lt返回广义表除表头元素
          //以外其他元素组成的表，否则函数没有定义
          if (first->tlink == NULL) return false;	    //空表
          else { 				//非空表
              lt.first->utype = 0;		//设置头结点
              lt.first->info.ref = 0;
              lt.first->tlink = Copy(first->tlink->tlink);
              return true; 
          }
      };
  template <class T>
      GenListNode<T> *GenList<T>::First() {
          //返回广义表的第一个元素（若表空，则返回一个
          //特定的空值NULL）	
          if (first->tlink == NULL) return NULL;    //空表      
          else return first->tlink;	 	 //非空表
      };
  template <class T>
      GenListNode<T> *GenList<T>::Next(GenListNode<T> *elem) {
      //返回表元素elem的直接后继元素
      if (elem->tlink == NULL) return NULL;
      else return elem->tlink;
  };
  ```

#### 递归算法

- 复制

  - ```c++
    template <class T>                 //公有函数
    void GenList<T>::Copy(const GenList<T>& R) 
         first = Copy(R.first);          //调用私有函数
    };
    template <class T>                 //私有函数
    GenListNode<T>* GenList<T>::Copy(GenListNode <T> *ls) {//复制一个 ls 指示的无共享子表的非递归表
         GenListNode<T> *q = NULL;
         if (ls != NULL) {
              q = new GenListNode<T>;  //处理当前的结点q
              q->utype = ls->utype;	  //复制结点类型
    	      	switch (ls->utype) {	  //根据utype传送信息
                  case 0: q->info.ref = ls->info.ref;  break;	        	  
                  case 1: q->info.value = ls->info.value;  break;
                  case 2: q->info.hlink = Copy(ls->info.hlink);   
                               break;
                 }
              q->tlink = Copy(ls->tlink);  //处理同层下一结点
        }
         return q;
    };
    ```

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024093048284.png" alt="image-20231024093048284" style="zoom: 50%;" />

- 长度：

  - 求广义表的长度就是**求同一层**次中tlink连接起来的单链表的长度

  - ```c++
    template<class T>
        int GenList<T>::Length(){
          return Length(first);  
        };
    template<class T>
        int GenList<T>::Length(GenListNode<T>*ls){
            if(ls!=NULL)return 1+Length(ls->tlink);
            else return 0;
        }
    ```

- 深度：

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024093712174.png" alt="image-20231024093712174" style="zoom:33%;" />

  - ```c++
    template <class T>
        int GenList<T>::Depth() {             //公有函数
            //计算一个非递归表的深度
            return Depth(first);
        };
    
    template <class T>                      //私有函数
        int GenList<T>::Depth(GenListNode<T> *ls) {
            if (ls->tlink == NULL) return 1;		
            // ls->tlink ==NULL, 空表，深度为1
            GenListNode<T> *temp = ls->tlink;  
            int m = 0, n;
            while (temp != NULL) {	//在广义表顶层横扫
                if (temp->utype == 2) {	   //扫描到表结点 
                    n = Depth(temp->info.hlink);	
                    //递归计算以子表深度
                    if (m < n) m = n;	   //取最大深度
                }
                temp = temp->tlink;
            }
            return m+1;			  //返回深度
        };
    ```

- 比较相等

  - ```c++
    template<class T>
        bool equal(GenList<T>*s,GenListNode<T>*t){
        int x;
        if(s->tlink==NULL&&t->tlink==NULL)return true;
        if(s->tlink!=NULL&&t->tlink!=NULL&&s->tlink->utype==t->tlink->utype){
            if(s->tlink->utype==1){
                x=(s->tlink->info.value==t->tlink->info.value)?1:0;
            }
            else if(s->tlink->utype==2){
                x=equal(s->tlink->info.hlink,t->tlink->info.hlink);
            }
            if(x==1)return equals(s->tlink,t->tlink);
        }
        return false;
    }
    ```

- 删除元素

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024094015893.png" alt="image-20231024094015893" style="zoom:33%;" />

  - ```c++
    template <class T>
    void delvalue(GenListNode<T> *ls, T x) {
         if (ls->tlink != NULL) {		     //非空表 
    	      GenListNode<T> * p = ls->tlink;  //第一个结点
    	      while (p != NULL && (p->utype == 1 &&
                   p->info.value == x)) {
                   ls->tlink = p->tlink;  delete p;  
                   p = ls->tlink;               //p指向同层下一结点
     	     }					
             if (p != NULL) {//遇到表元素
                  if (p->utype == 2)        
                       delvalue(p->info.hlink, x);//递归在子表中删除
                  delvalue(p, x);	//在该表行中继续删除
              }
         }
    };	
    ```

  - 对于共享表来说，如果一个表元素有多个地方使用它，贸然删去它会造成其他地方使用出错。因此，当要做删除时，**先把该表的头结点中的引用计数 ref 减1，当引用计数减到 0 时才能执行结点的真正释放。**

  - ```c++
    template <class T>
    GenList<T>::～GenList() {
    //广义表的析构函数, 每个头结点都有引用计数
         Remove(first);
        if(first.info.ref<=0)
             delete first; //first要额外处理
    };
    template <class T>
    void GenList<T>::Remove(GenListNode<T> *ls) {
    //私有函数：释放以ls为表头指针的广义表 
         ls->info.ref--;	     	//头结点的引用计数减1
         if (ls->info.ref <= 0) {		//如果减到0
       	      GenListNode<T> *q;	
              while (ls->tlink != NULL) {	//横扫表顶层
                   q = ls->tlink;			//到第一个结点
                   if (q->utype == 2) {		//递归删除子表
                        Remove(q->info.hlink);
                        if (q->info.hlink->info.ref <= 0)
                            delete q->info.hlink;   //删子表头结点
     		    }
     		    ls->tlink = q->tlink;  delete q;
       	      }
         }
    };
    ```

- 由字符串建立广义表

  - 字符串描述`S(A ( ‘b’, ‘c’ ), B(‘#’), ‘d’ )；`
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024130516374.png" alt="image-20231024130516374" style="zoom:50%;" />

  - 检测从输入流对象输入的一个字符，如果遇到表名（用大写字母表示），首先检查这个**表名是否已经存在**，如果是，说明该表是**共享表**，只要将相应头结点的引用计数加一即可；如果不是，保存该表名并建立相应广义表。表名后面一定是左括号‘(’，不是则输入错，是则递归建立广义表结构。
    - **注意：ABCD是表的标识符（指向表的外部指针），与表头区分**

  - 如果遇到用小写字母表示的原子，则建立原子结点；如果遇到右括号‘)’，子表链收尾并退出递归。

  - 空表情形括号里应夹入**一个非英文字母**，如字符'#'，不能一个字符也没有。整个广义表描述字符串以';'结束

  - ```c++
    template<class T>
        void Genlist<T>::CreateList(istream &in,GenListNode<T>*&ls,SeqList<T>&L1,SeqList<GenListNode<T>*>&L2)//L1存储大写字母的表名，L2存储表名对应子表节点的地址
        {
            T chr;
            in>>chr;
            if(isalpha(chr)&&isupper(chr)||chr=='(')//大写字母或(
            {
                ls=new GenListNode<T>;
                ls->utype=2;
                if(isalpha(chr)&&isupper(chr)){
                    int n=L1.Length();
                    int m=L1.Search(chr);
                    if(m!=0){//表已经建立
                        GenListNode<T>*p=L2.Locate(m);
                        p->ref++;
                        ls->info.hlink=p;//可以直接使用
                        return;
                    }
                    else{
                        ls->info.hlink=new GenListNode<T>;//新的外头界点
                        ls->info.hlink->utype=0;
                        ls->info.hlink->ref=1;
                        L1.insert(n,chr);
                        L2.insert(n,ls->hlink);
                    }
                    in>>chr;
                    if(chr!='(')
                        exit(-1);
                }
                CreateList(in,ls->info.hlink->tlink,L1,L2);//继续处理子表
                CreateList(in,ls,L1,L2);//子表处理完成，继续处理
            }
            else if(isalpha(chr)&&islower(chr)){
                ls=new GenListNode<T>;
                ls->utype=1;
                ls->info.value=chr;
                CreateList(in,ls,L1,L2);
            }
            else if(chr==',')
                CreateList(in,ls->tlink,L1,L2);
            else if (chr == ')') 
                ls->tlink = NULL;
            else if (chr == '#') 
                ls = NULL;
        }
    
    template <class T>
        istream& operator >> (istream& in, GenList<T>& L)
    {
        int n;
        cout << “输入广义表串的字符个数：”<< endl;
        in >> n;
        SeqList<T> Ls1(n); 	
        SeqList <GenListNode<T> *> Ls2 (n);
        CreateList (in, L.first, Ls1, Ls2);	//建立存储结构
    }; 
    ```

## 树

- 有根树T是n>=0个点的有限集合（n=0时为空树）
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102102434551.png" alt="image-20231102102434551" style="zoom:50%;" />
  - r是根（无前驱），$T_i$是根的子树
  - 每棵子树的根结点有且仅有一个直接前驱，但可以有0个或多个直接后继

- 基本概念
  - 度：节点的子树数目就是节点的度，**数中度的最大值是树的度**
  - 分支结点：度不为0的结点即为分支结点，亦称为非终端结点。
  - 叶结点：度为0的结点即为叶结点，亦称为终端结点。
  - 祖先：**根结点到该结点**的路径上的**各个结点**都是该结点的祖先。
  - 子孙：某结点的**所有下属结点**，都是该结点的子孙。
  - 结点的**层次**：规定**根结点在第一层**，其子女结点的层次等于它的层次加一。
  - 结点的深度：结点的**深度即为结点的层次**；离根**最远**结点的**层次即为树的深度**。
  - 结点的**高度**：规定**叶结点的高度为1**，其双亲结点的高度等于它的高度加一。**树的高度等于根节点的高度**
  - 有序树：节点的各棵子树有次序
  - 无序树：节点的各棵子树可以互换位置
  - 同一**结点**的子女互称兄弟
  - 森林：森林是m（m≥0）棵树的集合

### 二叉树

- 结点的一个有限集合，或者为空；或者由一个根结点加上两棵分别称为左子树右子树的互不相交的二叉树组成
- 性质
  - 第i层最多$2^{i-1}$结点（跟位于第一层）
  - 深度为k的二叉树最少$k$个结点，最多$2^k-1$个（满二叉树）；n个节点的**完全二叉树**深度$\lceil\log_2(n+1)\rceil$
  - 设叶节点$n_0$个，非叶节点$n_2$个，则$n_0=n_2+1$
- 满二叉树：有$2^k-1$个结点的二叉树
- 完全二叉树：除第k层外 全满（堆的要求）
- 二叉树的顺序表示：
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102104712509.png" alt="image-20231102104712509" style="zoom:50%;" />

#### 二叉树的链表表示

- 二叉链表表示，三叉链表表示（增加**指向父节点**）
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102151721048.png" alt="image-20231102151721048" style="zoom:33%;" />

#### 二叉树遍历

##### 利用前序遍历建立二叉树

- 使用@表示空结点（否则不能只通过前序遍历创建）

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102152852580.png" alt="image-20231102152852580" style="zoom:33%;" />

- ```c++
  template<class T> 
      void BinaryTree<T>::CreateBinTree (ifstream& in, BinTreeNode<T> *& subTree) {
          //私有函数: 以递归方式建立二叉树。
          T item;
          if ( !in.eof () ) {	    	//未读完, 读入并建树	
              in >> item;  		//读入根结点的值
              if (item != RefValue) {//不是表示空结点的@
                  subTree = new BinTreeNode<T>(item);
                  //建立根结点
                  if (subTree == NULL) 
                  {cerr << “存储分配错!” << endl;  exit (1);}
                  CreateBinTree (in, subTree->leftChild);
                  //递归建立左子树
                  CreateBinTree (in, subTree->rightChild);
                  //递归建立右子树
              }
              else subTree = NULL;						    //封闭指向空子树的指针
          }
      };
  ```

##### 非递归的遍历

- 前序遍历

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102153554354.png" alt="image-20231102153554354" style="zoom: 33%;" />

  - ```c++
    template <class T> 
    void BinaryTree<T>::
    PreOrder (void (*visit) (BinTreeNode<T> *t) ) {
         stack<BinTreeNode<T>*> S;
         BinTreeNode<T> *p = t; 
         S.Push (NULL);
    	 while (p != NULL) {
              visit(p);			   //访问结点
     	      if (p->rightChild != NULL)
                   S.Push (p->rightChild);  //预留右指针在栈中
              if (p->leftChild != NULL) 
                   p = p->leftChild;	//进左子树
     	      else S.Pop(p);		//左子树为空
         }
    };
    ```

- 中序遍历

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102155003400.png" alt="image-20231102155003400" style="zoom: 33%;" />

  - ```c++
    template <class T> 
    void BinaryTree<T>::
    InOrder (void (*visit) (BinTreeNode<T> *t)) {
         stack<BinTreeNode<T>*> S;    
          BinTreeNode<T> *p = t; 
        do {
              while (p != NULL) {	//遍历指针向左下移动
                   S.Push (p); 		//该子树沿途结点进栈
                   p = p->leftChild;
              }
              if (!S.IsEmpty()) {		//栈不空时退栈
                   S.Pop (p);  visit (p);	//退栈, 访问
                   p = p->rightChild;	//遍历指针进到右子女
              }
         } while (p != NULL || !S.IsEmpty ());
    };
    ```

- 后序遍历

  - 定义栈的结点

    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102155436923.png" alt="image-20231102155436923" style="zoom:33%;" />

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102155556809.png" alt="image-20231102155556809" style="zoom:50%;" />

  - ```c++
    template <class T>
        void BinaryTree<T>::
    PostOrder (void (*visit) (BinTreeNode<T> *t) {
        Stack<stkNode<T>> S;   stkNode<T> w; 
        BinTreeNode<T> * p = t;     //p是遍历指针
        do {
            while (p != NULL) {	
                w.ptr = p;  w.tag = L;  S.Push (w);   
                p = p->leftChild;					}
            int continue1 = 1;	    //继续循环标记, 用于R
            while (continue1 && !S.IsEmpty ()) {
                S.Pop (w);  p = w.ptr;
                switch (w.tag) {   	//判断栈顶的tag标记
                    case L:  w.tag = R;  S.Push (w); 
                        continue1 = 0;  
                        p = p->rightChild;  break;
                    case R:  visit (p);   break;	
                }
            }
        } while (!S.IsEmpty ());	//继续遍历其他结点
        cout << endl;
    };
    ```

#### 层次遍历

- 使用一个先进先出队列，在处理上一层时，将其下一层的结点直接进到队列（的队尾）。在上一层结点遍历完后，下一层结点正好处于队列的队头，可以继续访问它们。
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102160454567.png" alt="image-20231102160454567" style="zoom: 33%;" />

#### 线索化二叉树

- 穿线树，通过遍历二叉树可以将二叉树中所有节点的数据排列在一个线性序列中，可以找到前驱和后继
- 法一：直接添加pred指针和succ指针
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102161258892.png" alt="image-20231102161258892" style="zoom:33%;" />
  - 问题：占用空间大，原先的left和right指针有2n个但是只有n-1个非空，没有得到充分利用
- 方法二：利用空余的left和right指针存储前后继，使用标志位ltag、rtag指明指针是指示子女还是前驱后继（线索），一般用left存前驱，right存后继
  - 标志位=0表示存储的是子女结点，=1表示存储线索
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102162242680.png" alt="image-20231102162242680" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102162305362.png" alt="image-20231102162305362" style="zoom:50%;" />
  - 实际上对于原始存在的左右节点，其tag均为0，对于新创建的为1.

##### 中序线索化二叉树

- 寻找后继

  - | rightChild\rtag | ==0                                              | ==1            |
    | --------------- | ------------------------------------------------ | -------------- |
    | ==NULL          | 无此情况                                         | 无后继         |
    | !=NULL          | 后继为当前结点**右子树**的中序下的**第一个结点** | 后继为子女结点 |

    

- 寻找前驱

  - | leftChild\ltag | ==0                                              | ==1              |
    | -------------- | ------------------------------------------------ | ---------------- |
    | ==NULL         | 无此情况                                         | 无前驱           |
    | !=NULL         | 前驱为当前结点**左子树**中序下的**最后一个结点** | 前驱为左子女结点 |

- ```c++
  template<T>
  TreadNode<T>*ThreadTree<T>::First(ThreadNode<T>*current){
      //返回以current为根的中序线索二叉树中中序序列下的第一个结点
      ThreadNode<T>*p=current;
      while(p->ltag==0)p=p->leftChild;
      return p;
  }
  template<T>
  TreadNode<T>*ThreadTree<T>::Next(ThreadNode<T>*current){
      ThreadNode<T>*p=current->rightChild;
      if(current->rtag==0)return First(p);
      else return p;
  }
  template<T>
  TreadNode<T>*ThreadTree<T>::Last(ThreadNode<T>*current){
      //返回以current为根的中序线索二叉树中中序序列下的最后一个结点
      ThreadNode<T>*p=current;
      while(p->rtag==0)p=p->rightChild;
      return p;
  }
  template<T>
  TreadNode<T>*ThreadTree<T>::Prior(ThreadNode<T>*current){
      ThreadNode<T>*p=current->leftChild;
      if(current->ltag==0)return Last(p);
      else return p;
  }
  ```

- 中序遍历建立线索化二叉树

  - ```c++
    template <class T>
    struct ThreadNode {	      //线索二叉树的结点类
         int ltag, rtag;		      //线索标志
         ThreadNode<T> *leftChild, *rightChild;//线索或子女指针
         T data;			      //结点数据
         ThreadNode ( const T item)             //构造函数
              : data(item), leftChild (NULL),
                rightChild (NULL), ltag(0), rtag(0) {}	
    };
    template <class T>
    class ThreadTree {			//线索化二叉树类
    protected:
         ThreadNode<T> *root;	//树的根指针
         void createInThread (ThreadNode<T> *current,  
                ThreadNode<T> *& pre);
    	    //中序遍历建立线索二叉树
         ThreadNode<T> *parent (ThreadNode<T> *t);	 
            //寻找结点t的双亲结点
    public:
         ThreadTree () : root (NULL) { }	//构造函数
    	void createInThread();        //建立中序线索二叉树
         ThreadNode<T> *First (ThreadNode<T> *current);
    		//寻找中序下第一个结点
         ThreadNode<T> *Last (ThreadNode<T> *current);
    		//寻找中序下最后一个结点
    	  ThreadNode<T> *Next (ThreadNode<T> *current);
    		//寻找结点在中序下的后继结点
    	  ThreadNode<T> *Prior (ThreadNode<T> *current);
    		//寻找结点在中序下的前驱结点
    	       ………
    	};
    template <class T>
    void ThreadTree<T>::createInThread () {
         ThreadNode<T> *pre = NULL;    //前驱结点指针
    	 if (root != NULL) {   	         //非空二叉树, 线索化
              createInThread (root, pre);				    //中序遍历线索化二叉树
    	      pre->rightChild = NULL;  pre->rtag = 1;		   //后处理中序最后一个结点
    	 }
    };
    template <class T>
    void ThreadTree<T>::
    createInThread (ThreadNode<T> *current,ThreadNode<T> *& pre) {
    //通过中序遍历，添加缺失的边进行连接, 对二叉树进行线索化
         if (current == NULL) return;
         createInThread (current->leftChild, pre);
    		//递归, 左子树线索化
    	 if (current->leftChild == NULL) {				//建立当前结点的前驱线索
              current->leftChild = pre;   current->ltag = 1; 
         }
         if (pre != NULL && pre->rightChild == NULL) 	    //建立前驱结点的后继线索
            { pre->rightChild = current;   pre->rtag = 1; }	
         pre = current;							   //前驱跟上,当前指针向前遍历
    	 createInThread (current->rightChild,  pre);		  //递归, 右子树线索化
    };//就是左中右的中序遍历模式，对于中结点双向连接
    ```

##### *其他线索化二叉树

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102172300448.png" alt="image-20231102172300448" style="zoom:50%;" />
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102172308402.png" alt="image-20231102172308402" style="zoom:50%;" />

### 树与森林

- 广义表表示

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104104227049.png" alt="image-20231104104227049" style="zoom: 50%;" />

- 双亲表示

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104104606866.png" alt="image-20231104104606866" style="zoom: 50%;" />

- 链表表示

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104104947906.png" alt="image-20231104104947906" style="zoom:50%;" />

- 指针节点表示

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104105053288.png" alt="image-20231104105053288" style="zoom:50%;" />

- 子女兄弟表示

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104105352996.png" alt="image-20231104105352996" style="zoom:50%;" />
    - firstchild指向第一个子女节点，nextSibling指向下一个兄弟，即横向沿链扫描

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104105730382.png" alt="image-20231104105730382" style="zoom:50%;" />

- ```c++
  template <class T>
      struct TreeNode {			//树的结点类
          T data;				//结点数据
          TreeNode<T> *firstChild, *nextSibling;
          //子女及兄弟指针
          TreeNode (T value = 0, TreeNode<T> *fc = NULL,   
                    TreeNode<T> *ns = NULL)     //构造函数
              : data (value), firstChild (fc), nextSibling (ns) { }
      };
  template <class T>
      class Tree {			//树类
          private:
          TreeNode<T> *root, *current;				//根指针及当前指针
          int Find (TreeNode<T> *p, T value);			//在以p为根的树中搜索value
          void RemoveSubTree (TreeNode<T> *p);		//删除以p为根的子树
          bool FindParent (TreeNode<T> *t, 
                           TreeNode<T> *p);
          public:
          Tree () { root = current = NULL; }	//构造函数
          bool Root ();	           //置根结点为当前结点
          bool IsEmpty () { return root == NULL; }
          bool FirstChild ();
          //将当前结点的第一个子女置为当前结点
          bool NextSibling ();
          //将当前结点的下一个兄弟置为当前结点
          bool Parent ();
          //将当前结点的双亲置为当前结点
          bool Find (T value);
          //搜索含value的结点, 使之成为当前结点
          …… 			//树的其他公共操作
      };
  template <class T>
      bool Tree<T>::
  FindParent (TreeNode<T> *t, TreeNode<T> *p) {
      //在根为*t的树中找*p的双亲, 并置为当前结点
      TreeNode<T> *q = t->firstChild;     //*q是*t长子
      bool succ;
      while (q != NULL && q != p) {	  //扫描兄弟链
          if ((succ = FindParent (q, p)) == true) 
              return succ;	//递归搜索以*q为根的子树
          q = q->nextSibling;
      }
      if (q != NULL && q == p) {
          current = t;  return true;
      }
      else { current = NULL;  return false; }   //未找到
  }
  ```

#### 树的遍历

- 先根次遍历
  - 树的先根遍历结果与其对应二叉树表示的**前序遍历**结果相同


- 后根次遍历
  - 树的后根遍历结果与其对应二叉树表示的**中序遍历**结果相同

- 广度优先遍历


  - ```c++
    template <class T> 
        void Tree<T>::
    LevelOrder(void (*visit) (BinTreeNode<T> *t) ) {
        //按广度优先次序分层遍历树, 树的根结点是
        //当前指针current。   
        Queue<TreeNode<T>*> Q;
        TreeNode<T> *p;
        if (current != NULL) { 	      //树不空 
            p = current;                             //保存当前指针
            Q.EnQueue (current);             //根结点进队列
            while (!Q.IsEmpty ()) {
                Q.DeQueue (current);        //退出队列
                visit (current);                    //访问之
                current = current->firstChild;
                while (current != NULL) { 
                    Q.EnQueue (current);
                    current = current->nextSibling;
                }
            }
            current = p;	  //恢复算法开始的当前指针
        }
    };
    
    ```


#### 森林与二叉树的转换

- 使用**子女-兄弟表示**存储树可以将树转化二叉树

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104133118713.png" alt="image-20231104133118713" style="zoom:50%;" />
- 森林转化为二叉树
  - 二叉树B的根是F第一棵树$T_1$的根
  - 左子树为$B(T_{11},\dots,T_{1m})$即$T_1$的根的子树
  - 右子树为$B(T_2,\dots,T_n)$即除$T_1$外其他树构成的森林
- 二叉树转化为森林
  - $F$中第一颗树$T_1$的根为$B$的根
  - $T_1$的根的子树森林${T_{11},\dots,T_{1m}}$是由B的根的左子树$LB$转化而来
  - $F$中除了$T_1$之外其余的树组成的森林${T_2,T_3,\dots,T_n}$是由$B$的根的右子树$RB$转换而成的森林

#### 森林的遍历

- 森林的先根次序遍历
  - 先根遍历森林的**第一棵子树森林**，然后再遍历森林中除第一棵树外**其他树组成的森林**
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104135109737.png" alt="image-20231104135109737" style="zoom: 33%;" />
- 森林的后根次序遍历
  - 先访问第一棵子树的根结点的**子树森林**，然后访问森林的**根结点**$r_1$,然后再遍历森林中除第一棵树外其**他树组成的森林**
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104135531229.png" alt="image-20231104135531229" style="zoom:33%;" />
- 森林的广度优先遍历
  - 先遍历**各棵树**的**根节点**
  - 遍历各棵树根结点的所有子女
  - 逐层向下进行遍历
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104135726455.png" alt="image-20231104135726455" style="zoom:33%;" />

### 堆

- 每次出队列的是优先权最高的元素。

- 完全二叉树，并且父节点与子节点有确定的大小关系

- 下标从**0**开始时结点间的序号关系

  - 父节点$\lfloor (i-1)/2\rfloor$
  - 左右子女$2i+1,2i+2$

- 最小堆示例

  - ```c++
    template <class E>
        class MinHeap : public MinPQ<E> {
            //最小堆继承了（最小）优先级队列
            public: 
            MinHeap (int sz = DefaultSize);	//构造函数
            MinHeap (E arr[], int n);		//构造函数
            ～MinHeap() { delete [ ] heap; }	//析构函数
            bool Insert (E& x);			//插入
            bool Remove (E& x);			//删除
            bool IsEmpty () const		//判堆空否
            { return  currentSize == 0; }
            bool IsFull () const		//判堆满否
            { return currentSize == maxHeapSize; }	
            void MakeEmpty () { currentSize = 0; }	//置空堆
            private: 
            E *heap;			//最小堆元素存储数组
            int currentSize;		//最小堆当前元素个数
            int maxHeapSize;	//最小堆最大容量
            void siftDown (int start, int m);	//调整算法
            void siftUp (int start);		          //调整算法
        };
    template <class E>
        MinHeap<E>::MinHeap (int sz) {
            maxHeapSize = (DefaultSize < sz) ? 
                sz : DefaultSize;
            heap = new E[maxHeapSize];  	//创建堆空间
            if (heap == NULL) {
                cerr << “堆存储分配失败！” << endl;  exit(1);
            }
            currentSize = 0;				//建立当前大小
        };
    template <class E>
        MinHeap<E>::MinHeap (E arr[], int n) {
            maxHeapSize = (DefaultSize < n) ? n : DefaultSize;
            heap = new E[maxHeapSize]; 
            if (heap == NULL) {
                cerr << “堆存储分配失败！” << endl;  exit(1);
            }
            for (int i = 0; i < n; i++) heap[i] = arr[i];
            currentSize = n;	       //复制堆数组, 建立当前大小
            int currentPos = (currentSize-2)/2;	
            //找最初调整位置:最后分支结点
            while (currentPos >= 0) {	    //逐步向上扩大堆
                siftDown (currentPos, currentSize-1);
                //局部自上向下下滑调整
                currentPos--;
            }					
        };
    template <class E>
        void MinHeap<E>::siftDown (int start, int m ) {
            //私有函数: 从结点start开始到m为止, 自上向下比较, 
            //如果子女的值小于父结点的值,  则关键码小的上浮, 
            //继续向下层比较, 将一个集合局部调整为最小堆。
            int i = start,   j = 2*i+1;  	//j是i的左子女位置
            E temp = heap[i]; 			
            while (j <= m) {			//检查是否到最后位置
                if ( j < m && heap[j] > heap[j+1] ) j++;
                //让j指向两子女中的小者
                if ( temp <= heap[j] ) break;	//小则不做调整
                else { heap[i] = heap[j];  i = j; j = 2*j+1; }
                //否则小者上移, i, j下降
            }
            heap[i] = temp;	      	//回放temp中暂存的元素
        };
    template <class E>
        void MinHeap<E>::siftUp (int start) {
            //私有函数: 从结点start开始到结点0为止, 自下向上
            //比较, 如果子女的值小于父结点的值, 则相互交换, 
            //这样将集合重新调整为最小堆。关键码比较符<=
            //在E中定义。
            int j = start,  i = (j-1)/2;   E temp = heap[j];
            while (j > 0) {		//沿父结点路径向上直达根
                if (heap[i] <= temp) break;							//父结点值小, 不调整
                else { heap[j] = heap[i];  j = i;  i = (i-1)/2; }
                //父结点结点值大, 调整
            }	
            heap[j] = temp;				//回送
        };
    template <class E>
        bool MinHeap<E>::Insert (const E& x )  {
            //公共函数: 将x插入到最小堆中
            if ( currentSize == maxHeapSize ) 	//堆满
            { cerr << "Heap Full" << endl;  return false; }
            heap[currentSize] = x;  		//插入
            siftUp (currentSize);			//向上调整
            currentSize++;				//堆计数加1
            return true;
        };
    template <class E>
        bool MinHeap<E>::Remove (E& x) {
            if ( !currentSize ) {		//堆空, 返回false
                cout << "Heap empty" << endl;  return false;
            }
            x = heap[0];  
            heap[0] = heap[currentSize-1];
            currentSize--;
            siftDown(0, currentSize-1);    	//自上向下调整为堆
            return true;			//返回最小元素
        };
    ```

- **上浮操作通常在插入新元素到堆中时使用**。当一个新元素被添加到**堆的末尾时**，它可能会破坏堆的性质。为了修复这个性质，我们需要将这个元素向上移动到合适的位置，以恢复堆的性质。
- **下沉操作用在删除堆顶元素或者调整堆中某个元素的值时**。在删除**堆顶元素后**，通常将堆的最后一个元素移动到堆顶，这样会破坏堆的性质。为了修复这个性质，需要将这个元素向下移动到合适的位置
- 修改元素
  - 如果在最大堆中增加了一个元素的值，或者在最小堆中减少了一个元素的值，这个元素可能会违反堆的性质，因为它可能变得比其父节点大（最大堆）或小（最小堆）。在这种情况下，**需要进行上浮操作。**
  - 如果在最大堆中减少了一个元素的值，或者在最小堆中增加了一个元素的值，这个元素可能会违反堆的性质，因为它可能变得比其孩子节点小（最大堆）或大（最小堆）。在这种情况下，**需要进行下沉操作。**

### Huffman树

- 带权路径长度达到最小的扩充二叉树

#### 路径长度

- ZI路径长度PL：连接两结点的路径上的分支数
- 内部路径长度IPL：各**非叶节点**到根节点的路径长度之和
- 外部路径长度EPL：各**叶节点**到根节点的路径长度之和
- $PL=EPL+IPL$
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104142019640.png" alt="image-20231104142019640" style="zoom: 33%;" />
- **完全二叉树路径长度最小**，有$PL=\sum^n_{i=1}\lfloor\log_2i\rfloor$

##### 带权路径长度WPL

- 把**叶结点看成“外结点”**，**非叶结点看成“内结点”**。这样的二叉树称为相应权值的**扩充二叉树**。
- 扩充二叉树中**只有度为 2 的内结点和度为 0的外结点**。根据二叉树的性质，**有 n 个外结点就有 n-1 个内结点，总结点数为2n-1。**
- $WPL=\sum_{i=1}^1w_i*l_i$(权值乘以路径长度)
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231104142729316.png" alt="image-20231104142729316" style="zoom: 33%;" />

#### Huffman树构造方式

- 初始状态：给定n个权值${w_0,w_1,\cdots,w_{n-1}}$构造有n棵扩充二叉树的森林$F={T_0,\cdots,T_{n-1}}$，每颗子树都只有一个带特定权值的根节点，左右子树为空

- 重复以下，直至剩下一棵树：

  - 选择两颗根节点权值最小的扩充二叉树，作为左右子树构造新二叉树，新二叉树根节点的权值为左右子树上根节点的权值之和
  - 在F中删去两颗二叉树并把新的加入F

- ```c++
  #include "heap.h"
  const int DefaultSize = 20; // 缺省权值集合大小
  template <class E>
  struct HuffmanNode
  {           // 树结点的类定义
      E data; // 结点数据
      HuffmanNode<E> *parent;
      HuffmanNode<E> *leftChild, *rightChild; // 左、右子女和父结点指针
      HuffmanNode() : parent(NULL), leftChild(NULL),
                      rightChild(NULL) {} // 构造函数
      HuffmanNode(E elem,                 // 构造函数
                  HuffmanNode<E> *pr = NULL,
                  HuffmanNode<E> *left = NULL,
                  HuffmanNode<E> *right = NULL)
          : data(elem), parent(pr), leftChild(left),
            rightChild(right){}
  };
  template <class E>
  class HuffmanTree
  { // Huffman树类定义
  public:
      HuffmanTree(E w[], int n);           // 构造函数
      ~HuffmanTree() { deleteTree(root); } // 析构函数
  protected:
      HuffmanNode<E> *root;               // 树的根
      void deleteTree(HuffmanNode<E> *t); // 删除以 t 为根的子树
      void mergeTree(HuffmanNode<E> &ht1, HuffmanNode<E> &ht2,
                     HuffmanNode<E> *&parent);
  };
  template <class E>
  HuffmanTree<E>::HuffmanTree(E w[], int n)
  {
      // 给出 n 个权值w[0]～w[n-1], 构造Huffman树
      minHeap<E> hp; // 使用最小堆存放森林
      HuffmanNode<E> *parent, &first, &second;
      HuffmanNode<E> *NodeList =
          new HuffmanNode<E>[n]; // 森林
      for (int i = 0; i < n; i++)
      {
          NodeList[i].data = w[i];
          NodeList[i].leftChild = NULL;
          NodeList[i].rightChild = NULL;
          NodeList[i].parent = NULL;
          hp.Insert(NodeList[i]); // 插入最小堆中
      }
      for (i = 0; i < n - 1; i++)
      {                                     // n-1趟, 建Huffman树
          hp.Remove(first);                 // 根权值最小的树
          hp.Remove(second);                // 根权值次小的树
          mergeTree(first, second, parent); // 合并
          hp.Insert(*parent);               // 重新插入堆中
      }
      root = parent; // 建立根结点
  };
  template <class E>
  void HuffmanTree<E>::
      mergeTree(HuffmanNode<E> &bt1,
                HuffmanNode<E> &bt2,
                HuffmanNode<E> *&parent)
  {
      parent = new HuffmanNode<E>;
      parent->leftChild = &bt1;
      parent->rightChild = &bt2;
      parent->data.key =
          bt1.root->data.key + bt2.root->data.key;
      bt1.root->parent = bt2.root->parent = parent;
  };
  ```

- Huffman编码

  - 根据字符出现频率决定对字符的编码，使用变长二进制编码
  - 总编码长度就是表示报文中全部字母需要的二进制位的数目，**就是Huffman树的带权路径长度WPL**
  - **CAST** **CAST** **SAT AT A TASA**
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102114616906.png" alt="image-20231102114616906" style="zoom:50%;" />

## 集合与字典

### 集合

- 集合是成员的一个集群，集合中的成员可以是原子（单元素），也可以是集合；集合的成员**必须互不相同**，并具有**相同的数据类型**。
- 集合中的成员一般是**无序**的，但在表示时写在一个序列里有一个**线性有序关系**
  - 如果是完全无序，会给合并、查找等操作带来很大的麻烦

#### 使用位向量实现集合

- 当集合是${0,1,2,\dots,n}$的一个子集并且 $n$ 不是很大时使用 $(0,1)$ 表示元素是否在集合中（状态压缩）

- ```c++
  #include <assert.h>
  #include <iostream.h>
  const int DefaultSize = 50;
  template <class T>
      class bitSet {
          //用位向量来存储集合元素, 集合元素的范围在0到
          //setSize-1之间。数组采用16位无符号短整数实现
          public:
          bitSet (int sz = DefaultSize);	//构造函数
          bitSet (const bitSet<T>& R);	//复制构造函数
          ～bitSet () { delete [ ]bitVector; }	//析构函数
          unsigned short getMember (const T x);  //读取集合元素x
          void putMember (const T x, unsigned short v);  //将值v送入集合元素x
          void makeEmpty () { 			//置空集合
              for (int i = 0; i < vectorSize; i++)
                  bitVector[i] = 0;
          }
          bool addMember (const T x);	//加入新成员x
          bool delMember (const T x);	//删除老成员x
          bitSet<T>&  operator = (const bitSet<T>& R);
          bitSet<T>&  operator + (const bitSet<T>& R);
          bitSet<T>&  operator * (const bitSet<T>& R);
          bitSet<T>&  operator - (const bitSet<T>& R);
          bool Contains (const T x);						                      //判x是否集合this的成员
          bool subSet (bitSet<T>& R);   //判this是否R的子集
          bool operator == (bitSet<T>& R);				   			   //判集合this与R相等
          friend istream& operator >> (istream& in,  
                                       bitSet<T>& R);		   //输入
          friend ostream& operator << (ostream& out, 
                                       bitSet<T>& R);		   //输出
          private:
          int setSize;		//集合大小
          int vectorSize;		//位数组大小
          unsigned short *bitVector;						                    //存储集合元素的位数组
      };
  
  template <class T>
      bitSet<T>::bitSet (int sz) : setSize (sz) {    //构造函数
          assert (setSize > 0);		   //检查参数的合理性
          vectorSize = (setSize+15) >> 4;	//存储数组大小
          bitVector = new unsigned short[vectorSize];	//分配空间
          assert (bitVector != NULL);						//检查存储分配是否成功
          for (int i = 0; i < vectorSize; i++)
              bitVector[i] = 0;			//初始化
      };
  
  template<class T>
      unsigned short bitSet<T>:: getMember (const T x) {//读取集合元素x，x从0开始
          int ad = x/16;  
          int id = x%16;
          unsigned short elem = bitVector[ad];
          return ((elem >> (15 - id)) %2);
      };
  
  template<class T>
      void bitSet<T>:: putMember (const T x, unsigned short v) {  //将值v送入集合元素x
          int ad = x/16;  
          int id = x%16;
          unsigned short elem = bitVector[ad];
          unsigned short temp = elem >> (15-id);
          elem = elem << (id+1);
          if (temp%2==0 && v ==1) temp = temp +1;
          else if (temp%2==1 && v==0) temp = temp -1;
          bitVector[ad] = (temp<<(15-id)) | (elem >> (id+1));
      };
  
  template<class T>
      bitSet<T>&  bitSet<T>::          //求集合this与R的并
  operator + (const bitSet<T>& R) {
      assert (vectorSize == R.vectorSize); 
      bitSet temp (vectorSize);
  
      for (int i = 0; i < vectorSize; i++)
          temp.bitVector[i] = bitVector[i] | R.bitVector[i];
  
      return temp;  //按位求"或", 由第三个集合返回
  };
  
  template <class T>
      bitSet<T>&  bitSet<T>::              //求集合this与R的交
  operator * (const bitSet<T>& R) {	
      assert (vectorSize == R.vectorSize);
      bitSet temp (setSize);
  
      for (int i = 0; i < vectorSize; i++)
          temp.bitVector[i] = bitVector[i] & R.bitVector[i];
  
      return temp;  //按位求“与”, 由temp返回
  };
  
  template <class T>
      bitSet<T>&  bitSet<T>::		//求集合this与R的差
  operator - (const bitSet<T>& R) {	
      assert (vectorSize == R.vectorSize); 
      bitSet temp (setSize);
      for (int i = 0; i < vectorSize; i++)
          temp.bitVector[i] =  bitVector[i] & (~R.bitVector[i]);
  
      return temp;			//由第三个集合返回
  };
  
  template <class T>
  bool bitSet<T>::subSet (bitSet<T>& R) {
  //判this是否R的子集（即是否存在一位this中为1R中为0）
       assert (setSize == R.setSize);
       for (int i = 0; i < vectorSize; i++)   //按位判断
            if (bitVector[i] & (~R.bitVector[i])) return false;
  
  	return true;	
  };
  
  ```

#### 使用链表实现集合

- 使用有序链表表示集合，链表中的每个结点表示集合的一个成员

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231109233325590.png" alt="image-20231109233325590" style="zoom:33%;" />

- ```c++
  template <class T>
      struct SetNode {		//集合的结点类定义
          T data;			//每个成员的数据
          SetNode<T> *link;	//链接指针
          SetNode() : link (NULL);		//构造函数
          SetNode (const T& x, SetNode<T> *next = NULL) 
              : data (x), link (next);		//构造函数
      };
  template <class T>
      class LinkedSet {		//集合的类定义
          private:
          SetNode<T> *first, *last;      //有序链表表头指针, 表尾指针				
          public:
          LinkedSet () { first = last = new SetNode<T>; }	
          LinkedSet (LinkedSet<T>& R);	//复制构造函数 
          ～LinkedSet () { makeEmpty();  delete first; }	
          void makeEmpty();			//置空集合
          bool addMember (const T& x);
          bool delMember (const T& x);
          LinkedSet<T>& operator = (LinkedSet<T>& R);
          LinkedSet<T>& operator + (LinkedSet<T>& R);
          LinkedSet<T>& operator * (LinkedSet<T>& R);
          LinkedSet<T>& operator - (LinkedSet<T>& R);
          bool Contains (const T x);	//判x是否集合的成员
          bool operator == (LinkedSet<T>& R);							//判集合this与R相等
          bool Min (T& x);	//返回集合最小元素的值
          bool Max (T& x);	//返回集合最大元素的值
          bool subSet (LinkedSet<T >& R);						  	//判this是否R的子集
      };
  
  template <class T>
      LinkedSet<T>&  LinkedSet<T>::
  operator + (LinkedSet<T>& R) {
      //求集合this与集合R的并
      SetNode<T> *pb = R.first->link;	//R扫描指针
      SetNode<T> *pa = first->link;	//this扫描指针
      LinkedSet<T> temp;			//创建空链表
      SetNode<T> *p, *pc = temp.first;	//结果存放指针
      while (pa != NULL && pb != NULL) {
          if (pa->data == pb->data) {	//两集合共有
              pc->link = new SetNode<T>(pa->data);
              pa = pa->link;  pb = pb->link;
          }
          else if (pa->data < pb->data) {	//this元素值小
              pc->link = new SetNode<T>(pa->data);
              pa = pa->link;
          }
          else {			//R集合元素值小
              pc->link = new SetNode<T>(pb->data);
              pb = pb->link;
          }
          pc = pc->link;
      }
      if (pa != NULL) p = pa;	//this集合未扫完
      else p = pb;			//或R集合未扫完
      while (p != NULL) {		//向结果链逐个复制
          pc->link = new SetNode<T>(p->data);
          pc = pc->link;  p = p->link;
      }
      pc->link = NULL;  temp.last = pc;        //链表收尾
      return temp;
  }；
  
  ```

### 等价类与并查集

- 等价类具有：自反性、对称性、传递性
- 确定等价类的过程
  - 读入并存储等价对
  - 标记和输出
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231109233945417.png" alt="image-20231109233945417" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231109233952530.png" alt="image-20231109233952530" style="zoom:33%;" />

- 三种操作：合并、查找、构造函数
- 并查集使用**树的双亲表示**存储
- 非根结点的下标对应元素表示父元素，根节点为 $-k$ 表示**集合中的元素个数**（初始时都初始化为-1）
  - 注意使用这种方法时
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231109234451925.png" alt="image-20231109234451925" style="zoom:33%;" />

- ```c++
  const int DefaultSize = 10;
  class UFSets {	//集合中的各个子集合互不相交
      public:
      UFSets (int sz = DefaultSize);	//构造函数
      ～UFSets() { delete []parent; }	//析构函数
      UFSets& operator = (UFSets& R);    //集合赋值
      void Union (int Root1, int Root2);	     //子集合并
      int Find (int x);				//查找x的根
      void WeightedUnion (int Root1, int Root2);
      //改进例程:加权的合并算法
      private:
      int *parent;		  //集合元素数组(双亲表示)
      int size;			  //集合元素的数目
  };
  
  UFSets::UFSets (int sz) {	
      //构造函数：sz 是集合元素个数，双亲数组的范围
      //为parent[0]～parent[size-1]。
      size = sz;			  //集合元素个数
      parent = new int[size];  //创建双亲数组
      for (int i = 0; i < size; i++) parent[i] = -1;	  
      //每个自成单元素集合
  }; 
  //朴素方式
  int UFSets::Find (int x) {
      //函数搜索并返回包含元素x的树的根。
      if (parent[x] < 0) return x;   //根的parent[]值小于0  (值小于0表示是根，直接用下标，而不是负数，负数表示的是数目，不是唯一标识)
      else return (Find (parent[x]));
  };
  void UFSets::Union (int Root1, int Root2) {
      //求两个不相交集合Root1与Root2的并
      parent[Root1] += parent[Root2];
      parent[Root2] = Root1;
      /将Root2连接到Root1下面
  };
  //按秩和并、路径压缩
  void UFSets :: 
  WeightedUnion (int Root1, int Root2) {
      //按Union的加权规则改进的算法
      int temp = parent[Root1] + parent[Root2];
      if (parent[Root2] < parent[Root1]) {
          parent[Root1] = Root2;     //Root2中结点数多
          parent[Root2] = temp;      //Root1指向Root2
      }
      else {  
          parent[Root2] = Root1;    //Root1中结点数多
          parent[Root1] = temp;      //Root2指向Root1
      }
  };
  int UFSets::Find (int x) {
      //函数搜索并返回包含元素x的树的根。
      if (parent[x] < 0) return x;
      else{
          parent[x] = Find (parent[x])
      	return parent[x]；
      }
  };
  ```

### 字典

- 字典是元素的集合，每个元素有一个称作关键码（key）的域，不同元素的关键码不同；<名字-属性>

#### 字典的线性表描述

- 字典保存在线性序列中，关键码从左到右依次增大，可以使用有序顺序表或有序链表

- 有序顺序表

  - ```c++
    #include <iostream.h>
    #include “SeqList.h”
    const int defaultSize = 50;
    template <class K, class E> 
        class SortedList : public SeqList {
            public:
            int Search (K k1) const;			     //搜索
            void Insert (const K k1, E& e1);	     //插入
            bool Remove (const K k1, E& e1);	     //删除
        };
    template <class K, class E> 
        int SortedList<K, E>::Search (K k1) const {
            //顺序搜索关键码为k1的数据对象
            int n = last+1;
            for (int i = 1;  i <= n;  i++)
                if (data[i-1] == k1) return i;         //成功
            else if (data[i-1] > k1) break;
            return 0;       //顺序搜索失败, 返回失败信息
        };//因为键是从小到达排列，因此大于了就表示查找失败
    ```

  - 衡量一个搜索算法的时间效率的标准是：在搜索过程中**关键码平均比较次数**，也称为**平均搜索长度ASL**。搜索第 $i$ 个元素的概率为 $p_i$ ，搜索到时所需的比较次数为 $c_i$ ，搜索成功的平均搜索长度 $ASL_{succ}=\sum_{i=1}^{n}p_i\cdot{c_i}$

  - 本实现中成功查找的平均比较次数为$\frac1n\frac{(n+1)n}2=\frac{n+1}2$

  - 搜索不成功时不需一直比较到表尾，只要发现下一个元素的值比给定值大，就可断定搜索不成功

- 使用判定树描述顺序查找

  - 搜索成功时停在内结点，搜索失败时停在外结点
  - 判定树是一种**扩充二叉树**。内结点代表顺序表中**已有的元素**，外结点代表**失败结点**，它表示在两个**相邻已有元素值之间的值**。
  - $ASL_{unsucc}=\frac1{n+1}(\sum^n_{i=1}i+n)$
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110001215892.png" alt="image-20231110001215892" style="zoom:50%;" />

- 使用判定树描述折半查找

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110001625405.png" alt="image-20231110001625405" style="zoom:33%;" />

- 有序链表

  - ```c++
    #include <assert.h>
    template <class K, class E>
        struct ChainNode {		//链表结点类定义
            K key;
            E attr;
            ChainNode<K, E> *link;
            ChainNode() : link (NULL) { };	 //构造函数
            ChainNode (K k1, E& e1,                      //构造函数
            ChainNode<K,E> *next = NULL): key (k1), attr (e1), link (next) { };
        };
    template <class K, class E>
        class SortedChain {		//有序链表类定义
            public:
            SortedChain () {		//构造函数
                first = new ChainNode<K, E>;
                assert (first != NULL);
            };
            ～SortedChain ();		//析构函数
            ChainNode<K, E> *Search (K k1);    	     //搜索
            void Insert (const K k1, E& e1);		     //插入
            bool Remove (const K k1, E& e1);	     //删除  
            ChainNode<K, E> *Begin () { return first->link; }	                                         //定位第一个
            ChainNode<K, E> *Next (ChainNode<K, E> 
                                   *current) const {	//定位下一个
                if (current != NULL) return current->link;
                else return NULL;
            }
            private:
            ChainNode<K, E> *first;	//链表的头指针
        };
    
    template <class K, class E>
        ChainNode<K, E> *SortedChain<T>::
    Search (K k1) const {
        ChainNode<K, E> *p = first->link;
        while (p != NULL && p->key< k1) 
            p = p->link;		      //重载：元素判小于
        if ( p != NULL && p->key== k1) return p;			                          //重载：元素判等于
        else return NULL;
    };
    
    template <class K, class E>
        void SortedChain<K, E>::
    Insert (const K k1,  E& e1) {
        ChainNode<K, E> *p = first->link, *pre = first；   
            ChainNode<K, E> *newNode;
        while (p != NULL && p->key<= k1)				       //重载：元素判小于等于
        { pre = p;  p = p->link; }	     //寻找插入位置
        if (p != NULL && p->key== k1) p->attr= e1;     
        else {
            newNode = new ChainNode<K, E>(k1,e1);
            if (newNode == NULL) {        
                cerr << “存储分配失败！” << endl;
                exit (1); 
            }
            newNode->link = p;   pre->link = newNode; 
        }
    };
    
    template <class K, class E>
        bool SortedChain<K, E>::Remove (const K k1,  E& e1) { 
            ChainNode<K, E> *p = first->link, *pre = first；
                while (p != NULL && p->key< k1) 
                { pre = p;  p = p->link; }	        //寻找删除位置
            if (p != NULL && p->key== k1) {				            //重载：元素关键码判等于
                pre->link = p->link;
                e1 = p->attr;  
                delete p;
                return true;
            }
            else return false;		      //未找到删除结点
        };
    
    ```

### 散列表

- 在元素存储位置与其关键码之间建立一个确定的对应函数关系Hash()， 使得每个关键码与唯一的存储位置相对应`Address ＝ Hash(key)`
- 在插入时依此函数计算存储位置并**按此位置存放**。在搜索时对元素的关键码进行同样的计算，把求得的函数值当做元素存储位置，然后按此位置搜索。这就是散列方法
- 称这些产生冲突的散列地址相同的不同关键码为同义词。

#### 散列函数

- 要求
  - 散列函数应是简单的，能在较短的时间内计算出结果。
  - 散列函数的定义域必须**包括需要存储的全部关键码**，如果散列表允许有 m 个地址时，其值域必须在 0 到 m-1 之间。
  - 散列函数计算出来的地址应能**均匀分布**在整个地址空间中 : 若 key 是从关键码集合中随机抽取的一个关键码,  散列函数应能以同等概率取0 到 m-1 中的每一个值。
- 直接定址法
  - 取关键码的线性函数值为散列地址 $Hash(key)=a*key+b$
  - 这类散列函数是**一对一的映射**，一般不会产生冲突。但它要求散列地址空间的大小与关键码集合的**大小相同。**
- 数字分析法
  - 设有 n 个 d 位数,   每一位可能有 r 种不同的符号。这 r 种不同符号在各位上出现的频率不一定相同。根据散列表的大小,  **选取其中各种符号分布均匀的若干位**作为散列地址。
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110003436992.png" alt="image-20231110003436992" style="zoom:33%;" />
    - 选取 $\lambda_k$小的位
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110003530403.png" alt="image-20231110003530403" style="zoom:33%;" />
    - 应该取关键码的456位作为散列地址
  - 数字分析法仅适用于**事先明确知道表中所有关键码每一位数值的分布情况**，它完全依赖于关键码集合。如果换一个关键码集合，选择哪几位要重新决定。
- 除留余数法
  - 设散列表中允许地址数为m，取一个不大于 m，但最接近于或等于 m 的**质数 p** 作为除数 $hash(key)=key\%p \ p<=m$
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110003758347.png" alt="image-20231110003758347" style="zoom:33%;" />
  - 可按计算出的地址存放记录。注意,  **使用散列函数计算出的地址范围是 0 到 22**，而 23、24 这几个地址实际上不能用散列函数计算出来，只能在**处理冲突**时达到这些地址。
- 平方取中法
  - 首先计算构成关键码的**标识符的内码的平方**, 然后按照散列表的大小取**中间的若干位**作为散列地址。
  - 因为内码平方数的**中间几位**一般是由标识符**所有字符**决定, 所以对不同的标识符计算出的散列地址**大多不相同。**
  - 一般取散列地址为**8的某次幂**。例如, 若散列地址总数取为 m = 8^r^，则对内码的平方数取中间的 r 位。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110003954498.png" alt="image-20231110003954498" style="zoom:33%;" />
    - 使用八进制表示

- 折叠法

  - 此方法把关键码自左到右**分成位数相等的几部分**,  每一部分的位数应与散列表地址位数相同,  只有**最后一部分的位数可以短一些**。把这些部分的**数据叠加起来**,  就可以得到具有该关键码的记录的散列地址。

  - 叠加方式
    - 移位法：把各部分**最后一位对齐相加**；
    - 分界法：各部分**不折断**，沿各部分的分界**来回折叠**, 然后对齐相加。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110004306263.png" alt="image-20231110004306263" style="zoom:33%;" />
  - 一般当关键码的位数很多，而且关键码每一位上数字的分布**大致比较均匀时**，可用这种方法得到散列地址。
  - 假设地址空间为HT[**400**]，利用以上函数计算，取其中3位，取值范围在**0～999，可能超出地址空间范围**，为此必须将0～999压缩到0～399。可将计算出的地址**乘以一个压缩因子0.4**，把计算出的地址压缩到允许范围。

####  冲突处理

- 闭散列方式：线性探查法
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110005301946.png" alt="image-20231110005301946" style="zoom:33%;" />
  - 发生冲突时**顺次查找$H_i=(H_{i-1}+1)\%m,i=1,2,\dots,m-1$**
    - 注意线性探测需要**在到达数组末尾时回到数组开头**
  - 搜索成功的平均搜索长度（实际位置-散列位置+1）
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110005625170.png" alt="image-20231110005625170" style="zoom:33%;" />
  - 搜索不成功的平均搜索长度为：
    - 假设每种字母出现概率相同（这决定从什么位置开始搜索直到末尾）
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110005807834.png" alt="image-20231110005807834" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110005906375.png" alt="image-20231110005906375" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110005917223.png" alt="image-20231110005917223" style="zoom:33%;" />
  - 搜索成功的平均比对次数 $(1+1/(1-\alpha))/2$
- 开散列方式：链地址法
  - 若设散列表地址空间的位置从 0～m-1, 则关键码集合中的所有关键码被划分为 m 个子集，**具有相同地址的关键码归于同一子集**。我们称同一子集中的关键码互为同义词。**每一个子集称为一个桶。**
  - 通常各个桶中的表项通过一个**单链表链接**起来，称之为**同义词子表**。
  - 所有桶号相同的表项都链接在同一个同义词子表中，各链表的表头结点**组成一个向量**。**向量的元素个数与桶数一致**。**桶号为i**的同义词子表的表头结点是向量中第 i 个元素。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110010357022.png" alt="image-20231110010357022" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110010406307.png" alt="image-20231110010406307" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110010414230.png" alt="image-20231110010414230" style="zoom:33%;" />
  - 每个节点指向的桶，一个桶可能有多个页表（比如一个页表30条），页表之间使用链式连接，查询一个页表相当于进行一次磁盘读取
  - 搜索成功的平均比对次数 $1+\al$

## 搜索结构

- 静态环境，搜索结构在插入和删除等操作的前后不发生改变。（静态搜索表）
- 动态环境，为保持较高的搜索效率, 搜索结构在执行插入和删除等操作的前后将自动进行调整，结构可能发生变化。（动态搜索表）

### 静态搜索结构

#### 数组实现

- 数据节点键值对

  - ```c++
    #include <iostream.h>
    #include <assert.h>
    const int defaultSize = 100;
    template <class K, class E>
        class dataList;		//数据表类的前视定义, K为关键码对应的类，E为其他属性对应的类
    template <class K, class E >
        class dataNode {		//数据表中结点类的定义
            friend class dataList<K, E>;						              //声明其友元类为dataList
            public:
            dataNode (const K x, const E e) : key(x), other(e) { }	    //构造函数
            K getKey() const { return key; }	    //读取关键码
            void setKey (K x) { key = x; }	    //修改关键码
            private:
            K key;			//关键码域  
            E other;		          //其他域（视问题而定）
        }; 
    
    ```

- ```c++
  template <class K, class E >
      class dataList {		//数据表类定义
          public:
          dataList (int sz = defaultSize) 
              : ArraySize(sz), CurrentSize(0) {
                  Element = new dataNode<K, E>[sz];   
                  assert (Element != NULL);
              }
          dataList (dataList<K, E>& R);   //复制构造函数
          virtual ～dataList() { delete []Element; }	 //析构函数
          virtual int Length() { return CurrentSize; }	
          //求表的长度
          virtual K getKey (int i) const { 				                           //提取第 i个（从1开始）元素的key值 
              assert (i > 0 & i <= CurrentSize); 
              return Element[i-1].key;
          } 
          virtual void setKey (K x, int i) {				                //修改第 i个（从1开始）元素的key值
              assert (i > 0 & i <= CurrentSize);
              Element[i-1].key = x;
          }	
          virtual int SeqSearch (const K x) const;	    //搜索
          virtual bool Insert (K x , E e1);	    	    //插入
          virtual bool Remove (K x, E& e1);	    //删除
          friend ostream& operator << (ostream& out, 
                                       const dataList<K, E>& OutList);             //输出
          friend istream& operator >> (istream& in,dataList<K, E>& InList);                        //输入
          protected:
          dataNode<K, E> *Element;	   //数据表存储数组
          int ArraySize, CurrentSize;					                            //数组最大长度和当前长度
      };
  
  template <class K, class E>
      bool dataList<K, E>::Insert (K k, E e1) {
          //在dataList的尾部插入新元素, 若插入失败,函数返
          //回false, 否则返回true.
          if (CurrentSize == ArraySize) return false;
          dataNode<K, E>  node =  dataNode<K, E> (k,e1);
          Element[CurrentSize] = node; //插入在尾端
          CurrentSize++;  return true;
      };
  
  template <class K, class E>
      bool dataList<K, E>::Remove (K x, E& e1) {
          //在dataList中删除关键码为x的元素, 通过e1返回。
          //用尾元素填补被删除元素。
          if (CurrentSize == 0) return false;
          for (int i == 0; i < CurrentSize && 
               Element[i].key != x; i++)  //在表中顺序寻找
              if (i == CurrentSize) return false;	         //未找到
          e1 = Element[i].other;	     //找到,保存被删元素的值
          Element[i] = Element[CurrentSize-1];    //填补
          CurrentSize--;  return true;
      };
  
  ```

##### 顺序搜索

- **监视哨**：设在数据表 dataList 中顺序搜索关键码与 给定值 x 相等的数据元素，要求数据元素在表中从下标 0 开始存放, 下标为 CurrentSize 的元素作为控制搜索过程**自动结束**的“监视哨”使用。若搜索失败，则函数返回 CurrentSize+1。

  - ```c++
    template <class K, class E>
    int dataList<K, E>::SeqSearch (const K x) const {
         Element[CurrentSize].key = x;
    	 int i = 0;		                    //将x设置为监视哨
         while (Element[i].key != x) i++;//这个循环中进行比对（即对目标的搜索）				                                        //从前向后顺序搜索
         return i+1;
    };
    ```

- 平均比对次数

  - 设表中 $n$ 个元素，搜索到第 $i$ 个元素的概率为 $p_i$ ，平均比较次数为 $c_i$ ，则搜索成功的平均搜索长度 $ASL_{succ}=\sum^n_{i=1}p_i\cdot c_i$
  - 对于顺序搜索 $ASL——{succ} = \sum^n_{i=1}p_i\cdot i=\sum^n_{i=1}\frac1n\cdot i=\frac{n+1}2$
  - 搜索不成功 $ASL_{unsucc}=n+1$

- 有序顺序表的折半查找

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124111014885.png" alt="image-20231124111014885" style="zoom:50%;" />



### 二叉搜索树

- 定义：二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树

  - 每个结点都有一个作为搜索依据的关键码(key)，所有结点的**关键码互不相同**。
  - 左子树（如果非空）上所有结点的关键码都**小于**根结点的关键码。
  - 右子树（如果非空）上所有结点的关键码都**大于**根结点的关键码。
  - 左子树和右子树也是二叉搜索树。

- **中序遍历**可以得到从小到达的排序

- 结构定义

  - ```c++
    #include <iostream.h>
    #include <stdlib.h>
    template <class K, class E>
        struct BSTNode  {			    //二叉树结点类
            K key;                                             // 关键码
            E data;			 //除关键码外的其他数据域
            BSTNode<K, E> *left, *right;  //左子女和右子
            BSTNode() { left = NULL; right = NULL; }   //构造函数
    
            BSTNode (const K k1, const E x, BSTNode<K, E> *L = NULL,  BSTNode<K, E> *R = NULL) { 
                key = k1; data = x; left = L; right = R;
            }  //构造函数
            ～BSTNode() {}				//析构函数
            void setData (K k1, E x) { key = k1; data = x; }	//修改	
            E getData() { return data; }		//提取
            bool operator < (const BSTNode  & x) //判小于
            { return key < x.key; } 
            bool operator > (const BSTNode  & x) 	//判大于
            { return key > x.key; }
            bool operator == (const BSTNode  & x) 	//判等于
            { return key == x.key; }
        };  
    template <class K, class E>
        class BST {				  //二叉搜索树类定义
            public:
            BST() { root = NULL; }	  //构造函数
            BST(K value);			  //构造函数
            ～BST() {};			  //析构函数	
            bool Search (const K x) const	//搜索 
            { return Search(x,root) != NULL; }
            BST<K, E>& operator = (const BST<K, E>& R);		     				//重载：赋值
            void makeEmpty() 			//置空
            { makeEmpty (root); root = NULL;}
            void PrintTree() const { PrintTree (root); }    //输出
            E Min() { return Min(root)->data; }	 //求最小
    
            E Max() { return Max(root)->data; }	 //求最大
    
            bool Insert (const E& e1)                //插入新元素
            { return Insert(e1, root);}
    
            bool Remove (const K x) { return Remove(x, root);} 	  //删除含x的结点
            private: 
            BSTNode<K, E> *root;	//根指针
            K RefValue;	 		//输入停止标志
            BSTNode<K, E> * 		//递归：搜索
                Search (const K x, BSTNode<K, E> *ptr);
            void makeEmpty (BSTNode<K, E> *& ptr);						//递归：置空
            void PrintTree (BSTNode<K, E> *ptr) const;						//递归：打印
            BSTNode<K, E> *		//递归：复制
                Copy (const BSTNode<K, E> *ptr);		
            BSTNode<K, E>* Min (BSTNode<K, E>* ptr);						//递归：求最小
            BSTNode<K, E>* Max (BSTNode<K, E>* ptr);					//递归：求最大
            bool Insert (const K k1, const E& e1, BSTNode<K, E>*& ptr);		//递归：插入
            bool Remove (const K x, BSTNode<K, E>*& ptr);					//递归：删除
        };
    ```

- 搜索

  - ```c++
    template<class K, class E>
    BSTNode<K, E>* BST<K, E>::
    Search (const K x, BSTNode<K, E> *ptr) {
    //私有递归函数：在以ptr为根的二叉搜索树中搜
    //索含x的结点。若找到，则函数返回该结点的
    //地址，否则函数返回NULL值。
        if (ptr == NULL) return NULL; 
        else if (x < ptr->key) return Search(x, ptr->left);
        else if (x > ptr->key) return Search(x, ptr->right);
        else return ptr;				//搜索成功
    };
    
    //非递归版本
    template<class K, class E>
        BSTNode<K, E>* BST<K, E>::
    Search (const K x, BSTNode<K, E> *ptr) {
        //叉搜索树中搜索含x的结点。若找到，则函数返
        //回该结点的地址，否则函数返回NULL值。
        if (ptr == NULL) return NULL; 
        BSTNode<K, E>* temp = ptr;
        while (temp != NULL) {
            if (x == temp->key) return temp;
            if (x < temp->key) temp = temp->left;
            else temp = temp->right;
        }
        return NULL;
    };
    ```

- 插入

  - ```c++
    template <class K, class E>
        bool BST<K, E>::Insert (const K k1, const E& e1, BSTNode<K, E> *& ptr) {	   
            //私有函数：在以ptr为根的二叉搜索树中插入值为
            //<k1,e1>的结点。若在树中已有含<k1,e1>的结点则不插入
            if (ptr == NULL) {	   //新结点作为叶结点插入
                ptr = new BSTNode<K, E>(k1,e1); //创建新结点
                if (ptr == NULL)
                { cerr << "Out of space" << endl;  exit(1); }
                return true;
            }
            else if (k1 < ptr->key) Insert (k1,e1, ptr->left);	 	//左子树插入
            else if (k1 > ptr->key) Insert (k1,e1, ptr->right);		//右子树插入
            else return false;	      //已在树中,不再插入
        };
    
    ```
    
  - 为了向二叉搜索树中插入一个新元素，必须先检查这个元素是否在树中已经存在。即要先进行一次搜索，搜索成功测说明**不需要再插入**，搜索不成功则说明要将将新元素插入到**操作停止的位置**

  - 利用二叉树的插入算法来建立二叉树

    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124112504803.png" alt="image-20231124112504803" style="zoom:50%;" />

- 删除维护

  - 删除叶结点，只需将其双亲结点指向它的指针清零，再释放它即可。
    
  - 被删结点右子树为空，可以拿它的左子女结点顶替它的位置，再释放它。
    
  - 被删结点左子树为空，可以拿它的右子女结点顶替它的位置，再释放它。
    
  - 被删结点左、右子树都不为空，可以在它的**右子树中**寻找中序下的第一个结点(关键码最小),(左子树最后一个即)用它的值填补到被删结点中，再来处理这个结点的删除问题。
    
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124121813205.png" alt="image-20231124121813205" style="zoom:33%;" />
    
  - ```c++
    template <class K, class E>
        bool BST<K, E>::Remove (const K x, 
                                BSTNode<K, E> *& ptr) {
            //在以 ptr 为根的二叉搜索树中删除含 x 的结点
            BSTNode<K, E> *temp;
            if (ptr != NULL) {//为null表示不存在
                if (x < ptr->key) Remove (x, ptr->left);	
                //在左子树中执行删除
                else if (x > ptr->key) Remove (x, ptr->right);
                //在右子树中执行删除（找到目标了）
                else if (ptr->left != NULL && ptr->right != NULL)
                {       //ptr指示关键码为x的结点，它有两个子女
                    temp = ptr->right;  
                    //到右子树搜寻中序下第一个结点
                    while (temp->left != NULL) 
                        temp = temp->left;
                    ptr->key = temp->key;
                    ptr->data = temp->data;
                    //用该结点数据代替根结点数据（从右子出发去删除这个换上来的点）
                    Remove (ptr->key, ptr->right);
                }
                //至少一个为空
                else {	//ptr指示关键码为x的结点有一个子女
                    temp = ptr;
                    if (ptr->left == NULL) ptr = ptr->right;
                    else ptr = ptr->left;
                    delete temp;
                    return true;
                }
            }
            return false;
        }; 
    ```

### AVL树

- AVL树是一种高度平衡的二叉树，或者是空树，或者满足左右子树都是AVL树，并且**高度差绝对值不超过1**

- 平衡因子

  - 每个节点附加一个数字，给出**右子树的高度减去左子树的高度**所得的高度差，即节点的平衡因子bf
  - 取值：-1，0，1（否则就失去了平衡不是AVL树了）

- 高度和平均搜索长度可以保持在$O(log_2n)$

  - 搜索、插入、删除一个结点并做平衡化旋转所需时间

- 基本定义

  - ```c++
    #include <iostream.h>
    #include “stack.h”
    template <class K, class E>
        struct AVLNode : public BSTNode<K, E> {
            //AVL树结点的类定义  
            int bf;
            AVLNode() { left = NULL; right = NULL; bf = 0; }
            AVLNode (K k, E x, AVLNode<K, E> *l = NULL,  
                     AVLNode<K, E> *r = NULL) 
            { key = k; data = x;  left = l;  right = r;  bf = 0; }
        };
    template <class K, class E>
        class AVLTree : public BST<K, E> {
            //平衡的二叉搜索树（AVL）类定义
            public:
            AVLTree() { root = NULL; }		//构造函数
            AVLTree (K Ref) { RefValue = Ref; root = NULL; }
            //构造函数：构造非空AVL树
            int Height() const; //使用指针引用返回结果
            AVLNode<K, E>* Search (K x, AVLNode<K, E> *& ptr) const;	         //搜索
            bool Insert (K x, E& e1) { return Insert (root, x, e1); } //插入
            bool Remove (K x, E& e1)
            { return Remove (root, x, e1); } 	         //删除
            friend istream& operator >> (istream& in, 
                                         AVLTree<K, E>& Tree);		       //重载：输入
            friend ostream& operator << (ostream& out,
                                         const AVLTree<K, E>& Tree);        //重载：输出
            protected:
            int Height (AVLNode<K, E> *ptr) const; 
            bool Insert (AVLNode<K, E>*& ptr, K x, E& e1);
            bool Remove (AVLNode<K, E>*& ptr, K x, E& e1);
            void RotateL (AVLNode<K, E>*& ptr); 	  //左单旋
            void RotateR (AVLNode<K, E>*& ptr);	  //右单旋
            void RotateLR (AVLNode<K, E>*& ptr);		//先左后右双旋
            void RotateRL (AVLNode<K, E>*& ptr);		//先右后左双旋
        };
    
    ```

#### 平衡化旋转

- 插入或者删除后可能造成不平衡，需要通过旋转进行调整

- 左单旋转

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124135422714.png" alt="image-20231124135422714" style="zoom:50%;" />

  - ```c++
    template <class K, class E> 
    void AVLTree<K, E>:://ptr会返回为新的跟
    RotateL (AVLNode<K, E> *& ptr) {
    //右子树比左子树高: 做左单旋转后新根在ptr
         AVLNode<K, E> *subL = ptr;
        ptr = subL->right;
        subL->right = ptr->left;
        ptr->left = subL; 
        ptr->bf = subL->bf = 0;
    };
    ```

- 右单旋转

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124135633148.png" alt="image-20231124135633148" style="zoom:50%;" />

  - ```c++
    template <class K, class E>
    void AVLTree<K, E>::
    RotateR (AVLNode<K, E> *& ptr) { 
    //左子树比右子树高, 旋转后新根在ptr
        AVLNode<K, E> *subR = ptr;   //要右旋转的结点
        ptr = subR->left;
        subR->left = ptr->right;	
        ptr->right = subR;		
        ptr->bf = subR->bf = 0;
    };
    ```

- 先左后右

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124140410239.png" alt="image-20231124140410239" style="zoom: 50%;" />

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124140501524.png" alt="image-20231124140501524" style="zoom:50%;" />

  - ```c++
    template <class K, class E>
    void AVLTree<K, E>:: RotateLR (AVLNode<K, E> *& ptr) {
        AVLNode<K, E> *subR = ptr;
        AVLNode<K, E> *subL = subR->left;
        ptr = subL->right;
        subL->right = ptr->left;
        ptr->left = subL;
        if (ptr->bf <= 0) subL->bf = 0;
        else subL->bf = -1;
        subR->left = ptr->right;
        ptr->right = subR;	
        if (ptr->bf == -1) subR->bf = 1;
        else subR->bf = 0;
        ptr->bf = 0;
    };
    ```

- 先右后左

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124150329550.png" alt="image-20231124150329550" style="zoom: 50%;" />

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124150401610.png" alt="image-20231124150401610" style="zoom:50%;" />

  - ```c++
    template <class K, class E>
    void AVLTree<K, E>::
    RotateRL (AVLNode<K, E> *& ptr) {
        AVLNode<K, E> *subL = ptr;
        AVLNode<K, E> *subR = subL->right;
        ptr = subR->left;
        subR->left = ptr->right; 
        ptr->right = subR;
        if (ptr->bf >= 0) subR->bf = 0;
        else subR->bf = 1;
        subL->right = ptr->left;
        ptr->left = subL;
        if (ptr->bf == 1) subL->bf = -1;
        else subL->bf = 0;
        ptr->bf = 0;
    }; 
    ```

- 补充：旋转的原理*

  - 单旋转

    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124142916619.png" alt="image-20231124142916619" style="zoom: 33%;" />

    - 假设某次操作后哦 $bf(D)=-2$ 假设 $h(A)>=h(C)$

    - $$
      设h(E)=x,则
      \begin{cases}
          h(B)=x+2\\
          h(A)=x+1\\
          x\leq h(C)\leq x+1
      \end{cases}
      $$

    - 对D向右旋转，则<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124143857668.png" alt="image-20231124143857668" style="zoom:33%;" />

    - $$
      \begin{cases}
          0\leq h(C)-h(E)\leq 1\\
          x+1\leq h'(D)=\max(h(C),h(E))+1=h(C)+1\leq x+2\\
          0\leq h'(D)-h(A)\leq 1
      \end{cases}
      $$

  - 双旋转

    - $h(A)<h(C)$

    - $$
      \begin{cases}
          h(B)=x+2\\
          h(C)=x+1\\
          h(A)=x
      \end{cases}
      $$

    - 先对节点 B 进行一次左旋操作，再对节点 D 进行一次右旋操作

    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124144734158.png" alt="image-20231124144734158" style="zoom:33%;" />

    - $$
      \begin{cases}
          x-1\leq h'(rs_B),h'(ls_D)\leq x\\
          0\leq h(A)-h'(rs_B)\leq 1\\
          0\leq h(E)-h'(ls_D)\leq 1\\
          h'(B)=\max(h(A),h'(rs_B))+1=x+1\\
          h'(D)=\max(h(E),h'(ls_D))+1=x+1\\
          h'(B)-h'(D)=0
      \end{cases}
      $$

#### 插入

- 在插入新结点后（向二叉搜索树那样进行失败的查询后在原位置进行插入），需从插入结点**沿通向根的路径向上回溯**。 如果在某一结点发现高度不平衡，停止回溯。从发生不平衡的结点起，**沿刚才回溯的路径取直接下两层**的结点。
  - 如果这三个结点处于**一条直线上**，则采用**单旋转**进行平衡化。单旋转可按其方向分为左单旋转和右单旋转。 如果这三个结点处于**一条折线**上，则采用**双旋转**进行平衡化。双旋转分为先左后右和先右后左两类。
- 插入新结点并修改pr的平衡因子值后，pr的平衡因子值有三种情况：
  - 结点pr的平衡因子为0：什么也不需要做（说明向矮的树插入），树的高度不发生变化
  - $|bf|=1$
    - 说明插入前pr的平衡因子是0，不需要旋转，但是子树**高度加一**，需要继续考察双亲节点的平衡状态
  - $bf=-2$
    - 在较高的子树插入，需要旋转转化
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124151451461.png" alt="image-20231124151451461" style="zoom:50%;" />
  - $bf=2$
    - 右子树高
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124151416103.png" alt="image-20231124151416103" style="zoom:50%;" />
- 例：输入关键码序列为 { 16, 3, 7, 11, 9, 26, 18, 14, 15 }
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124151639598.png" alt="image-20231124151639598" style="zoom: 50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124151655002.png" alt="image-20231124151655002" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124151712299.png" alt="image-20231124151712299" style="zoom:50%;" />


#### 删除

- 如果被删结点x最多只有一个子女，可做简单删除:
  - 将结点x从树中删去。
  - 如果结点x有一个子女，可以简单地把x的双亲中原来指向x的指针改成指到这个子女结点；
  - 如果结点x没有子女，x双亲原来指向x的指针置为NULL。
  - 将原来以结点x的父结点为根的**子树的高度减1。**

- 如果被删结点 x 有两个子女:
  -  搜索x在中序次序下的直接前驱 y (同样也可以找直接后继)。
  -  把结点 y 的内容传送给结点 x，现在**问题转移到删除结点 y**，把结点 y 当作被删结点。
  -  因为结点 y 最多有一个子女，可以简单地用 1. 给出的方法进行删除。

- 删除x之后的维护（必须沿结点x的父结点通向根的路径**反向追踪**高度的变化对路径上各个结点的影响）
  - 用shorter（一个bool变量）指明子树高度是否缩短，初始为True，在向上遍历检查中，如果shorter编程false算法终止，否则要进行检查及操作
  - 若节点的bf为0，则有一个子树缩短，bf变为-1/1，但是shorter为false，停止向上
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153016874.png" alt="image-20231124153016874" style="zoom:50%;" />

  - 若bf 不为0且较高的子树被缩短。则 p 的 bf 改为0，同时shorter置为True。还要继续**检查上层结点**的平衡因子。
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153059726.png" alt="image-20231124153059726" style="zoom:50%;" />

  - 结点 p 的 bf 不为0，且较矮的子树又被缩短。则在结点 p **发生不平衡**。需要进行平衡化旋转来恢复平衡。（假设高子树根为q）
    - 如果 q（较高的子树）的 bf 为0，执行一个单旋转来恢复结点 p 的平衡，置shorter为False。**无需检查上层结点的平衡因子**。<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153359641.png" alt="image-20231124153359641" style="zoom:50%;" />
    - 如果 q 的 bf 与 p 的 bf **相同**，则执行一个单旋转来恢复平衡，结点 p 和 q 的 bf 均改为0，同时置shorter为True。**还要继续检查上层结点的平衡因子。**<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153430823.png" alt="image-20231124153430823" style="zoom:50%;" />
    - 如果 p 与 q 的 bf **相反**，则执行一个双旋转来恢复平衡。新根结点的 bf 置为0，其他结点的 bf 相应处理，同时置shorter为True。**还要继续检查上层结点的**平衡因子。<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153614636.png" alt="image-20231124153614636" style="zoom:50%;" />

- 例子
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153736125.png" alt="image-20231124153736125" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153754433.png" alt="image-20231124153754433" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153804464.png" alt="image-20231124153804464" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153815889.png" alt="image-20231124153815889" style="zoom:50%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124153827947.png" alt="image-20231124153827947" style="zoom:50%;" />

## 图

### 图的基本概念

- 图是由**顶点集合以及顶点之间的关系集合**组成的一种数据结构：
  G＝( V, E )    
- 完全图：若有 n 个顶点的无向图有 n(n-1)/2 条边, 则此图为无向完全图。若有 n 个顶点的有向图有n(n-1) 条边, 则此图为**有向完全图**。
- 邻接顶点   如果 (u, v) 是 E(G) 中的一条边，则称 u 与 v 互为邻接顶点。
- 简单路径   若路径上各顶点 v1, v2, ..., vm 均不互相重复, 则称这样的路径为简单路径。
- 

### 图的存储结构

- 图的模板基类（带权无向图）

  - ```c++
    template <class T, class E>
        class Graph {			    //图的类定义
            protected:
            int maxVertices;		    //图中最大顶点数
            int numEdges;			    //当前边数
            int numVertices;		    //当前顶点数
            virtual int getVertexPos (T vertex);	
            //给出顶点vertex在图中位置
            public: 
            Graph (int sz = DefaultVertices);  	//构造函数
            ～Graph();				//析构函数
            bool GraphEmpty () const 		//判图空否
            { return numEdges == 0; }	
            int NumberOfVertices () { return numVertices; }
            //返回当前顶点数
            int NumberOfEdges () { return numEdges; }
            //返回当前边数
            virtual T getValue (int i);		//取顶点 i 的值
            virtual E getWeight (int v1, int v2);  //取边上权值
            virtual int getFirstNeighbor (int v);
            //取顶点 v 的第一个邻接顶点
            virtual int getNextNeighbor (int v, int w);
            //取邻接顶点 w 的下一邻接顶点
            virtual bool insertVertex (const T vertex);
            //插入一个顶点vertex
            virtual bool insertEdge (int v1, int v2, E cost);
            //插入边(v1,v2), 权为cost
            virtual bool removeVertex (int v);	
            //删去顶点 v 和所有与相关联边
            virtual bool removeEdge (int v1, int v2);	
            //在图中删去边(v1,v2)
        };
    ```

#### 邻接矩阵表示

- 在图的邻接矩阵表示中，有一个记录各个顶点信息的顶点表，还有一个表示各个顶点之间关系的邻接矩阵
- 存储带权图
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209180138116.png" alt="image-20231209180138116" style="zoom:33%;" />

#### 邻接表

- 把邻接矩阵的各行分别组织为一个单链表
- 无向图
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209181018735.png" alt="image-20231209181018735" style="zoom:33%;" />
- 有向图的（邻接表和逆邻接表）
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209181039623.png" alt="image-20231209181039623" style="zoom:33%;" />

#### **邻接多重表** 

- 无向图的邻接表表示中，每条边被存**储了两遍**，既浪费了空间，又造成为边做标记等有关边的处理的不方便
- 在邻接多重表中, **每一条边只有一个边结点**。为有关边的处理提供了方便。
- **无向图**
  - 边结构<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209181912923.png" alt="image-20231209181912923" style="zoom:33%;" />
    - vertex1和vertex2是该边两顶点位置。path1域是链接指针, 指向下一条**依附顶点vertex1的边**；path2 是指向下**一条依附顶点vertex2的**边链接指针。
  - 点结构<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209181946722.png" alt="image-20231209181946722" style="zoom:33%;" />
    - data 存放与该顶点相关的信息，firstout 是指向依附于该顶点的**第一条边的指针。**
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209182013312.png" alt="image-20231209182013312" style="zoom:33%;" />
- **有向图**
  - 用有向图的邻接多重表可以结合邻接表和逆邻接表
  - 点结构<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209182121133.png" alt="image-20231209182121133" style="zoom:33%;" />
    - 数据成员data存放与该顶点相关的信息，指针firstout指向以该顶点为始顶点的**出边表**的第一条边， firstin 指向以该顶点为终顶点的**入边表**的第一条边。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209182155568.png" alt="image-20231209182155568" style="zoom:33%;" />

### 最小生成树

- 克鲁斯卡尔：并查集+堆
- 普里姆(Prim)：每次选已经确定的点最近的点加入

### 最短路径

- Dijkstra

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216160515589.png" alt="image-20231216160515589" style="zoom:33%;" />

- Floyd

  - ```c++
    template <class T, class E>
        void Floyd (Graph<T, E>& G, E a[][], int path[][]) {
        //a[i][j]是顶点i和j之间的最短路径长度。path[i][j]
        //是相应路径上顶点j的前一顶点的顶点号。
        for (i = 0; i < n; i++)//矩阵a与path初始化
            for (j = 0; j < n; j++) {
                a[i][j] = G.getWeight (i, j);
                if (i != j && a[i][j] < maxValue) path[i][j] = i;
                else path[i][j] = 0;
            }
        for (k = 0; k < n; k++)//针对每一个k, 产生a(k)及path(k)       
            for (i = 0; i < n; i++)
                for (j = 0; j < n; j++)
                    if (a[i][k] + a[k][j] < a[i][j]) { 
                        a[i][j] = a[i][k] + a[k][j];               
                        path[i][j] = path[k][j]; 
                        //缩短路径长度, 绕过 k 到 j
                    }
    };
    ```

  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216155534762.png" alt="image-20231216155534762" style="zoom:33%;" />

### 活动网络(拓扑排序任务调度)

#### AOV网络

- 对给定的AOV网络，必须先判断它是否存在有向环，如果出现了有向环，则意味着某项活动应以自己作为先决条件。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209183331470.png" alt="image-20231209183331470" style="zoom:33%;" />
- 拓扑排序
  - bfs（逐渐删去度为0的点）

#### AOE网络

- 在无有向环的带权有向图中, 用**有向边表示一个工程中的活动** , 用边上权值表示活动持续时间 ,  用**顶点表示事件** ,  则这样的有向图叫做用边表示活动的网络
- 表示完成全部任务需要的最少时间
- 整个工程只有一个开始点和一个完成点，开始点（即入度为零的顶点）称为**源点**，结束点（即出度为零的顶点）称为**汇点**。
  - 完成整个工程所需的时间取决于从源点到汇点的**最长路径长度**，这条路径长度最长的路径就叫做**关键路径**
  - 关键路径上的所有活动都是**关键活动**
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209184606697.png" alt="image-20231209184606697" style="zoom:33%;" />
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209184600500.png" alt="image-20231209184600500" style="zoom:33%;" />
- 先求解Ve、Vl
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209184826624.png" alt="image-20231209184826624" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209184846084.png" alt="image-20231209184846084" style="zoom:33%;" />
- 计算Ae、Al
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209184957786.png" alt="image-20231209184957786" style="zoom:33%;" />
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231209185008828.png" alt="image-20231209185008828" style="zoom:33%;" />

## 排序

- 内排序与外排序:   内排序是指在排序期间数据元素全部存放在内存的排序；外排序是指在排序期间全部元素个数太多，不能同时存放在内存，必须根据排序过程的要求，不断在内、外存之间移动的排序。
- 排序的复杂度：排序码的比较次数和元素移动次数

![image-20231216130305703](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216130305703.png)

### 插入排序

- 每步将一个待排序的元素，按其排序码大小，插入到前面已经排好序的一组元素的适当位置上, 直到元素全部插入为止。

#### 直接插入排序

- 即传统的插入排序，从后向前比较插入，不能放就交换位置，即将元素向后移动
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216115343430.png" alt="image-20231216115343430" style="zoom:33%;" />

- ```c++
  for (i = left+1; i <= right; i++)
      if (L[i] < L[i-1]) {
          temp = L[i];  j = i-1;	
          do {
              L[j+1] = L[j];  j--;
          } while (j >= left && temp < L[j]);
          L[j+1] = temp;  
      }
  }
  ```

- 事件复杂度分析

  - 最好情况下如元素已经排好序，则比较次数为n-1移动次数为0
  - 最坏情况下逆序，比较和移动均为$n^2/2$
  - 平均为$O(n^2)$

- 稳定排序

#### 折半插入排序

- 在查找位置时使用折半查找而不是从后向前逐一比对

- ```c++
  int i, low, high, middle, k;
  for (i = left+1; i <= right; i++) {
      temp = L[i];  low = left;  high = i-1; 
      while (low <= high) {	//折半搜索寻找插入位置
          middle = (low+high)/2;	//取中点
          if (temp < L[middle])	  //插入值小于中点值
              high = middle-1;	  //向左缩小区间
          else low = middle+1;	  //否则, 向右缩小区间
      }
      for (k = i-1; k >= low; k--) L[k+1] = L[k];
      //成块移动,空出插入位置
      L[low] = temp;	     //插入
  }
  ```

- 平均比较次数<img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216120538672.png" alt="image-20231216120538672" style="zoom: 25%;" />

- 折半插入排序的元素移动次数与直接插入排序都**依赖于元素的初始排列**。

- 当 n 较大时，总排序码比较次数比直接插入排序的最坏情况要好得多，但**比其最好情况要差**。

- 稳定的排序方法

#### 希尔排序

- 取一个整数 gap < n 作为间隔，将全部元素分为 gap 个子序列，所有距离为 gap 的元素放在同一个子序列中，在每一个子序列中分别施行**直接插入排序**。然后缩小间隔 gap, 例如取 gap = gap/2，重复上述的子序列划分和排序工作。直到最后取 gap == 1，将所有元素放在同一个序列中排序为止。
- 开始时 gap 的值较大，子序列中的元素较少，排序速度较快;  随着排序进展，gap 值逐渐变小, 子序列中元素个数逐渐变多，由于前面工作的基础，大多数元素已基本有序，所以排序速度仍然很快。
- 示例
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216121145103.png" alt="image-20231216121145103" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216121153754.png" alt="image-20231216121153754" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216121202148.png" alt="image-20231216121202148" style="zoom:33%;" />

- ```c++
  void ShellSort (dataList<T>& L, 
                  const int left, const int right) {
      int i, j, gap = right-left+1;		//增量的初始值
      Element<T> temp;
      do {
          gap = gap/3+1;			//求下一增量值
          for (i = left+gap; i <= right; i++)
              if (L[i] < L[i-gap]) {		//逆序
                  temp = L[i];  j = i-gap;
                  do {
                      L[j+gap] = L[j];  j = j-gap;
                  } while (j >= left && temp < L[j]);
                  L[j+gap] = temp;	//将vector[i]回送
              }
      } while (gap > 1);
  };
  ```

- 复杂度约为$n^{1.25}$

- 不稳定排序

### 快速排序

- 不稳定的排序方法（partition引起）
- 对于 n 较大的平均情况而言, 快速排序是“快速”的, 但是当 n 很小时, 这种排序方法往往比其它简单排序方法还要慢。

### 交换排序

#### 冒泡排序

- ```c++
  while (pass <= right && exchange) {
      exchange = 0;		    	//标志为0假定未交换
      for (int j = right;  j >= pass;  j--)      
          if (L[j-1] > L[j]) { 	//逆序
              Swap (L[j-1], L[j]); 	//交换
              exchange = 1;        	//标志置为1,有交换
          }
      pass++;
  }
  ```

- 在元素的初始排列已经按排序码从小到大排好序时，此算法**只执行一趟起泡**，做n-1次排序码比较，不移动元素。这是最好的情形。

- 最坏的情形是算法执行n-1趟起泡,第i趟 (1≤ in) 做n-i次排序码比较, 执行n-i次元素交换。

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216122522417.png" alt="image-20231216122522417" style="zoom: 33%;" />

- 稳定的排序

### 选择排序

- 基本思想是:  每一趟 (例如第 i 趟, i = 0, 1, …, n-2) 在后面 n-i 个待排序元素中选出排序码最小的元素，作为有序元素序列的第 i 个元素。待到第 n-2 趟作完，待排序元素只剩下1个,  就不用再选了。

#### 直接选择排序

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216123058842.png" alt="image-20231216123058842" style="zoom: 50%;" />

- ```c++
  void SelectSort (dataList<T>& L, 
            const int left, const int right) {
      for (int i = left; i < right; i++) {
          int k = i;    //在L[i]到L[right]之间找最小排序码元素
          for (int j = i+1;  j <= right;  j++) 
              if (L[j] < L[k]) k = j;
          if (k != i) Swap (L[i], L[k]);	//交换 
      }
  };
  ```

- 比较次数固定为$\frac{n(n-1)}2$

- 当这组元素初始状态是按其排序码从小到大有序的时候,  元素的移动次数达到最少RMN = 0，
  最坏情况是每一趟都要进行交换，总的元素移动次数为 RMN = 3(n-1)。

- 不稳定的排序方法(交换过程引起，可能破坏相同元素的顺序)

#### 锦标赛排序

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216124219257.png" alt="image-20231216124219257" style="zoom:50%;" />
- 示例
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216124454645.png" alt="image-20231216124454645" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216124504173.png" alt="image-20231216124504173" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216124515669.png" alt="image-20231216124515669" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216124558765.png" alt="image-20231216124558765" style="zoom:33%;" />
- 第一次为构建树，之后只需要对树进行更新即可
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216124713381.png" alt="image-20231216124713381" style="zoom:33%;" />
- 稳定的排序方法

#### 堆排序

- ```c++
  template <class T>
      siftDown (dataList<T>& L, const int start, const int m){
      //私有函数: 从结点start开始到m自上向下比较, 
      //如果子女的值大于双亲的值, 则相互交换, 将一
      //个集合局部调整为最大堆。
      int i = start;  int j = 2*i+1;	 //j是i的左子女
      Element<T> temp = L[i];	 //暂存子树根结点
      while (j <= m) {		   	 //逐层比较
          if (j < m && L[j] < L[j+1]) j++;
          //让j指向两子女中的大者
          if (temp >= L[j]) break;	 //temp排序码大,不调整
          else {			    //否则子女中的大者上移
              L[i] = L[j];
              i = j;  j = 2*j+1;  	    //i下降到子女位置
          }
      }
      L[i] = temp;		    //temp放到合适位置
  };
  template <class T>
      void HeapSort (dataList<T>& L) {
      //对表L.Vector[0]到L.Vector[n-1]进行排序, 使得表
      //中各个元素按其排序码非递减有序
      int i, n = L.length();
      for (i = (n-2)/2; i >= 0; i--) 	//建堆
          siftDown (L, i, n-1);	
      for (i = n-1; i >= 0; i--) {		//修堆
          L.Swap(0, i);  siftDown (L, 0, i-1);
      }
  };
  ```

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216125259784.png" alt="image-20231216125259784" style="zoom:33%;" />
- 示例
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216125321501.png" alt="image-20231216125321501" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216125327873.png" alt="image-20231216125327873" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216125337392.png" alt="image-20231216125337392" style="zoom:33%;" />

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216125445021.png" alt="image-20231216125445021" style="zoom:33%;" />
- 堆排序是一个不稳定的排序方法（每次将堆顶移动到尾部的交换引起）。

### 归并排序

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216125751339.png" alt="image-20231216125751339" style="zoom:33%;" />
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231216125930199.png" alt="image-20231216125930199" style="zoom:33%;" />
- 归并排序是一个稳定的排序方法。

## 文件

### 主存储器和外存储器

#### 磁带

- 磁带带面每一横排9位二进制，8位数据位1位奇偶校验位
- 磁带的存储密度BPI
  - 6250BPI（=246排/mm）、1600BPI（=64排/mm）、800BPI（32排/mm）。正常走带速度为3～5m/Sec
- 传送速度=存储密度*走带速度
- 应用中发使用文件进行数据处理的基本单位为（逻辑）记录，磁带上存储的为（物理）记录
- 在使用磁带或磁盘存放逻辑记录时，常常把若 干个逻辑记录**打包**进行存放，把这个过程叫做 “块化”（blocking）。经过块化处理的物理 记录叫做**块化记录**。
- 磁带每次启停都有 一个加速与减速的过程，在这段时间内走带不稳定，只能走空带，这段空带叫做**记录间间隙**（块间间隙IBG）
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231228000040266.png" alt="image-20231228000040266" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231228000328437.png" alt="image-20231228000328437" style="zoom: 33%;" />
- 读写一个块的实践$t_{IO}=t_a+t_b$
  - $t_a$：延时时间（读写磁头到达待读写块所需的时间）
  - $t_b$：对一个块读写的时间（数据传输时间+IBG）
- 磁带设备只能用于处理**变化少，只进行顺序存取**的大量数据。

#### 磁盘

- ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228000901.png)
	- 数据存储在盘面的**磁道**上，磁道划分为若干段（扇区）
	- 每个盘面都有磁头，磁头同步在磁道之间移动，所处的磁道合起来称为柱面

- 读取：
	- 先选定柱面，并移动磁头寻查（机械动作较慢）
	- 确定读写的磁道（电子线路）
	- 确定扇区，旋转延迟（机械动作）
	- 进行读写
	- $t_{io}=t_{seek}+t_{latency}+t_{rw}$
	- 平均寻查时间+平均等待时间（旋转延迟）+数据传输时间

- 在 MS-DOS 系统中，**多个扇区集结成组**，称为簇，作为文件分配的最小单位。
- UNIX 系统中不使用簇，文件分配的最小单位和读写的最小单位是**一个扇区**，称为一个块

#### 缓冲区

- 在磁盘读写时内存需要开辟区域用于存方读入/写出的信息，即输入缓冲区和输出缓冲区。
- 缓冲区大小应与操作系统一次读写的块的大小相适应，这样就可以通过一次读写完成操作
- 如果缓冲区大小与磁盘上的块大小不适配，就会造成存储空间的浪费
- 缓冲区的构造可以看作一个**先进先出**的队列。

- 目标：减少磁盘 io，一次多读/多写一点

```cpp
template <class T>
    void buffer<T>::OutputInfo (ostream& out, T x) {
        if (current == maxSize) {
        //一次性输出
            for (int i = 0; i < maxSize; i++) out << data[i];
            current = 0;
        }
        data[current] = x; current++;
    };
    template <class T>
        void buffer<T>::InputInfo (istream& in, T& x) {
            if (current < maxSize) {
                x = data[current];
                current++;
            }
            else {
            //一次性读取
                for (int i = 0; i < maxSize; i++) in >> data[i];
                current = 0;
            }
        };
```

### 文件组织

- 文件是存储在外存上的数据结构，一般是在**逻辑上具有完整意义的一组相关信息项的有序序列**。
- 操作系统文件：流式文件，没有结构的字符流，按物理记录读写
- 数据库文件：具有结构的数据集合，按页块读写

#### 文件的组成

- 文件由记录组成（文件存取的基本单位），记录由数据项（文件可使用的基本单位）组成
- 文件记录分为逻辑记录和物理记录。前者是**面向用户**的基本存取单位，后者是**面向外设**的基本存取单位。

- 能够**唯一标识**一个记录的数据项或数据项集称为**主关键码项**，其值称为主关键码；
- **不唯一标识**一个记录的数据项或数据项集称为**次关键码项**，其值称为次关键码。

- 文件结构：**逻辑结构、存储结构、操作**
	- 文件的逻辑结构是线性的
	- 文件的存储结构：顺序存储、直接存取组织（散列函数）、索引组织
	- 操作定义在逻辑结构、实现在存储结构
		- ![|300](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228003141.png)

- 评价文件组织的效率
	- 执行文件操作所花费的时间
	- 文件组织所需要的空间

- 顺序存取设备：磁带
- 直接存取设备：磁盘

#### 顺序文件

- 顺序文件中的记录按它们**进入文件的先后顺序存放**，其逻辑顺序与物理顺序**一致**
- 如果按**主关键码有序**，则称为**顺序有序**文件，否则为顺序无序文件
- 在顺序存取设备上只能顺序搜索存取，存放在**直接存取**设备上时才能进行折半搜索等操作

- 顺序文件的存取方式
	- 连续文件：记录顺序的存放在外存的连续区域
		- 速度快、存储利用率高
		- 不能扩充区域大小
	- 串联文件：成块存放，但块与块之间可以不连续，通过块状指针顺序链接
		- 文件可以扩充、存储利用率高
		- 影响了存取和修改的效率。

#### 直接存取文件

- 散列文件，利用散列组织文件，记录的逻辑顺序与物理顺序不一定相同，通过记录的关键码可直接确定该记录的地址
- 使用散列函数把关键码集合映射到地址集合

- 冲突和处理
- 按桶散列
	- 记录成组存放，若干组构成桶
	- 若一个桶能存放 m 个记录，则 m 个互为同义词的记录可以存放在同一地址的桶中。当第 m+1 个同义词出现时，发生**溢出**。
	- 溢出链：将第 m+1 个同义词存放到“**溢出桶**”。并称存放前 m 个同义词的桶为“**基桶**”。溢出桶和基桶大小相同。当在基桶中检索不成功，就循指针到溢出桶中检索。
		- ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228005110.png)
		- 删除记录时，因为可能需要重新链接，所以只需做一个**逻辑删除标记**即可，待系统做周期性重构时再做物理删除。
	- 分布式溢出空间：
		- 出桶按照一定的间隔分布在基桶之间。如果有**一个基桶溢出了**，系统就将记录**存放在下一个溢出桶中**。如果溢出桶溢出了，则溢出到**下一个溢出桶**
		- ![image.png|225](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228005639.png)
	- 相继溢出法：
		- 不设置溢出桶，当发生溢出时，溢出记录直接存方到下一个相继的桶中（下一个不是已满的桶中）
		- 优点是对溢出不需要漫长的寻找。紧邻的桶通常相距不多于一次磁盘旋转。但当邻近的多个桶被挤满时，则为了查找空闲空间就需要检查许多桶。如果桶的容量很小更是如此。
		- ![image.png|225](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228005846.png)

- 可扩充散列
	- 基于数字搜索树，根据桶的大小进行合并、分裂等操作

- 优点：随机存放、记录不需进行排序、插入删除方便、存取速度快、不需要索引区和节省存储空间等优点。
- 缺点：不能顺序存取，只能按**关键码随机存取**。在经过多次插入、删除后，可能出现溢出桶满而基桶内多数记录已被删除的情况。此时需要**重新组织文件**。

#### 索引文件

- 由**索引表和数据表（主文件）** 组成，索引表指示逻辑记录与物理记录的对应关系，是按关键码有序的表

- 索引顺序文件：主文件也按关键码有序。此时可对主文件分组，**一组记录对应一个索引项**。称这种索引表为**稀疏索引**。
	- 即一个索引项对应数据表中的**一组记录**
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228125653.png)

- 索引非顺序文件：主文件中记录未按关键码有序。此时，**每一个主文件记录必须对应一个索引项**。称这种索引表为**稠密索引**
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228125641.png)


- **静态索引**：多级索引结构，每一级索引都是一个有序表，结构简单，但是不方便修改，修改需要重组索引
	- 数据装入时就已经定型，在整个运行期间，**结构不发生变化**。
- **动态索引**：动态调整的**平衡搜索树结构**，方便插入搜索删除
	- 在整个系统运行期间, 结构随数据的增删及时调整, 以保持最佳的搜索效率。

- 搜索的时间代价取决于访问外存的次数，即**索引树的高度**

- 索引顺序文件
	- 先在索引表搜索给定的值 k, 使 i 满足 $ID[i-1].max\_key<K<ID[i].max\_key$ 得到子表项
	- 在第 i 个子表中搜索记录
	- 根据存储的方式，可以使用顺序搜索或折半搜索
- 索引顺序文件的搜索成功平均搜索长度 $ASL_{IndexSeq}=ASL_{Index}+ASL_{SubList}$
	- 搜索子表位置的平均搜搜常速+子表内搜索的平均搜索长度
	- 把长度为 n 的表分成均等的 b 个表，每个表 s 个记录，则 $ASL_{IndexSeq}=\frac{b+1}{2}+\frac{s+1}{2}$
	- 其中 $b=\left\lceil  \frac{n}{s}  \right\rceil$ ，因而 $l=\sqrt{ n }$ 时取得最小长度

#### 倒排表

- 用主关键码建立索引叫**主索引**
	- $key|addr$
- 但是只使用关键码有时无法回答根据存储内容进行筛选的查询，使得只能进行低效率的**顺序搜索**
	- 因此除了主关键码外可以把经常搜索的属性设定为**次关键码**，并针对次关键码的属性，建立**次索引**
	- 次索引中**列出属性的取值**，对取值建立有序链表，把具有相同属性值得记录按存放地址/主关键码的顺序**连接**。由次关键码、链表长度、链表本身三部分组成。
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228133114.png)
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228133951.png)
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228134008.png)
	- 通过此索引得到链并进行布尔运算就可以通过属性实现查询

- **倒排表**是次索引的一种实现。在表中所有次关键码的链都保存在次索引中，仅通过**搜索次索引**就能找到所有具有相同属性值的记录。

- 在倒排表中各个属性链表的长度大小不一, 管理比较困难。为此引入**单元式倒排表**。
	- 索引项中不存放记录的存储地址, 而是**存放该记录所在硬件区域**（即存储区域）的标识。（一次 I / O 操作能存取的存储空间作为硬件区域）
	- 为使索引空间最小, 在索引中标识这个硬件区域时可以使用一个能转换成地址的**二进制数**, 整个次索引形成一个 (二进制数的) **位矩阵**
	- 二进位的值为 **1** 的硬件区域**包含具有该次关键码的记录**。（即状态压缩）
	- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228134645.png)
	- 针对一个查询：按照此索引抽取属性的位相量，按位进行布尔运算，就求得满足查询要求的记录**在哪些硬件区域中**，再读入这些硬件区域，从中查找所需的数据记录。
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228134800.png)

#### 多级索引结构

- 数据记录比较大时索引表也会太大，可以建立索引的索引
- 二级索引可以**常驻内存**，二级索引中一个索引项对应一个索引块，登记该索引块的最大关键码及该索引块的存储地址。

- 多级索引结构用 m 叉树表示，称为 m 路搜索
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20231228152750.png)

##### 静态索引结构（ISAM 索引顺序存取方法文件）

- 典型的例子是对磁盘上的数据文件建立**盘组、柱面、磁道三级地址**的多级索引。
- ISAM 文件用柱面索引对各个柱面进行索引。一个柱面索引项保存该柱面上的**最大关键码** （最后一个记录）以及柱面**开始地址指针**。
- 

##### 动态索引结构（m 路路搜索树）



#### [[算法/数据结构#*B树（数据库）|B树]]



#### [[算法/数据结构#B+树|B+树]]****



####  外排序

