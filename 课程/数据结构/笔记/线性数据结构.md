### 线性表

- $n(\ge0)$ 个表项的有限序列 $L=(a_1,\dots,a_n)$
- 顺序表：顺序存储方式
  - **存储利用率高**，存取速度**快**
  - 插入、删除等操作时需要**移动大量数据**
- 链表：链表存储方式
  - 适应表的**动态**增长和删除
  - 需要**额外**的指针存储**空间**

#### 顺序表

顺序表类的定义
```c++
#include <iostream.h>	       //定义在“seqList.h”中
#include <stdlib.h>
#include “linearList.h"
const int defaultSize = 100;
template < class E>
    class SeqList: public LinearList<E> {
        protected:
        E *data;		     //存放数组
        int maxSize;	     //最大可容纳表项的项数
        int last;		     //当前已存表项的最后位置
        void reSize(int newSize);	//改变数组空间大小
        public:
        SeqList(int sz = defaultSize);          //构造函数
        SeqList(SeqList<E>& L);	           //复制构造函数
        ～SeqList() {delete[ ] data;}	           //析构函数
        int Size() const {return maxSize;}	 //求表最大容量
        int Length() const {return last+1;}  //计算表长度
        int Search(E& x) const;	
        //搜索x在表中位置，函数返回表项序号
        int Locate(int i) const;
        //定位第 i 个表项，函数返回表项序号
        bool getData(int i, E& x) const;  //取第i个表项的值
        bool Insert(int i, E x);			//插入
        bool Remove(int i, E& x);		//删除
    };

#include <stdlib.h>      //操作“exit”存放在此
#include “seqList.h”    //操作实现放在“seqList.cpp”
template <class E>
    SeqList<E>::SeqList(int sz) { 
        if (sz > 0) {
            maxSize = sz;  last = -1;
            data = new E[maxSize];	   //创建表存储数组
            if (data == NULL){   //动态分配失败
                cerr << "存储分配错误！" << endl;  
                exit(1); 
            }
        }
    };
template <class E>
    SeqList<E>::SeqList ( SeqList<E>& L ) {
        maxSize = L.Size(); 
        last = L.Length()-1; 
        E value;
        data = new E[maxSize];	//创建存储数组
        if (data == NULL)		//动态分配失败
        {cerr << "存储分配错误！" << endl;     exit(1);}
        for (int i = 1; i <= last+1; i++)    //传送各个表项
        {L.getData(i, value); data[i-1] = value;}
    };
template <class E>
    int SeqList<E>::Search(E & x) const {
        //在表中顺序搜索与给定值 x 匹配的表项，找到则
        //函数返回该表项是第几个元素，否则函数返回0
        for (int i = 0; i <= last; i++)	//顺序搜索
            if ( data[i] == x ) 
                return i+1; //表项序号和表项位置差1
        return 0;		    //搜索失败
    };
template <class E> 
    bool SeqList<E>::Insert (int i, E x) {
        //将新元素x插入到表中第i (1≤i≤last+2) 个表项位
        //置。
        if (last == maxSize-1) return false;        //表满
        if (i < 1 || i > last+2) return false;  //参数i不合理
        for (int j = last; j >= i-1; j--)                 //依次后移
            data[j+1] = data[j]; 
        data[i-1] = x;	      //插入(第 i 表项在data[i-1]处)
        last++;
        return true;		           //插入成功
    };
template <class E>
    bool SeqList<E>::Remove (int i, E& x) {
        //从表中删除第 i (1≤i≤last+1) 个表项，通过引用型
        //参数 x 返回被删元素。
        if (last == -1) return false;	           //表空
        if (i < 1 || i > last+1) return false;//参数i不合理
        x = data[i-1];  	
        for (int j = i; j <= last; j++)      //依次前移，填补
            data[j-1] = data[j];
        last--;
        return true; 	
    };	

```
- 查找元素的代价（比较次数）
  - 比较成功 $\frac1n*(1+\dots+n)=\frac{1+n}2$
  - 比较失败 $n$
- 顺序表插入的时间代价（移动次数）
  - $\frac1{1+n}*(n+\cdots+1+0)=\frac n2$
- 删除元素的代价（移动次数）
  - $\frac 1n *(n-1+\cdots+1)=\frac{n-1}2$

- 实现集合运算
```c++
void Union ( SeqList<int> & LA,SeqList<int> & LB ) {
    int n = LA.Length ( );
    int m = LB.Length ( );
    int x;
    for ( int i = 1; i <= m; i++ ) {
        LB.getData(i, x);     //在LB中取一元素
        int k = LA.Search (x);     //在LA中搜索它
        if ( k == 0 )                //若未找到插入它
        {n++; LA.Insert (n, x);}
    }
}
void Intersection ( SeqList<int> & LA, SeqList<int> & LB ) {
    int n = LA.Length ( );
    int m = LB.Length ( );  int i = 1; int x;
    while ( i <= n ) {
        LA.getData (i, x);    //在LA中取一元素
        int k = LB.Search (x);      //在LB中搜索它	
        if ( k == 0 ) { LA.Remove (i,x);  n--;}
        //未找到,在LA中删除它
        else i++;                
    }
}
```

#### 链表

- 插入元素：头中尾三种情况
```c++
bool List::Insert(int i, int x) {
    //将新元素 x 插入到第 i 个结点之后。i 从1开始，
    //i = 0 表示插入到首元结点之前。
    if (first == NULL || i == 0) {	  //空表或首元结点前
        LinkNode *newNode = new LinkNode(x);		  //建立一个新结点
        newNode->link = first;  first = newNode;
        //新结点成为首元结点
    }			 		
    else {                     //否则，寻找插入位置
        LinkNode *current = first;	  int k = 1;     
        while (k < i && current != NULL)    //找第i结点
        { current = current->link;  k++; }
        if (current == NULL && first != NULL)    //链短
        {cerr << “无效的插入位置!\n”;  return false;}
        else {		 //插入在链表的中间
            LinkNode *newNode = new LinkNode(x);
            newNode->link = current->link;
            current->link = newNode;
        }
    }
    return true; 
};

```

- 删除元素：两种情况，头节点或其它节点
```c++
bool List::Remove (int i, int& x) {
//将链表中的第 i 个元素删去, i 从1开始。
    LinkNode *del;		//暂存删除结点指针
	if (i <= 1)  { del = first;  first = first->link; }
	else { 
        LinkNode *current = first;  k = 1;   //找i-1号结点
	    while (k < i-1 && current != NULL)	
  		  { current = current->link;   k++; }
	    if (current == NULL || current->link == NULL) { 	  cout << “无效的删除位置!\n”;  return false;
        }	
        del = current->link;  	 //删中间/尾结点
	 	 current->link = del->link;		
	  }
	  x = del->data;  delete del; 	//取出被删结点数据
	  return true;			
};

```

- 使用附加头节点统一操作
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231108142313329.png" alt="image-20231108142313329" style="zoom:33%;" />
  - ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240104174324.png)
  - ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240104174332.png)


- 循环链表
	- 搜索：从表头出发，再次回到表头是终止

- 带头节点的双向循环链表
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929182712053.png" alt="image-20230929182712053" style="zoom: 25%;" />
	- ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240104174920.png)

- 静态链表 [[图论#链式前向星]]
	- 为数组中每一个元素**附加一个链接指针**，就形成静态链表结构。
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929190709672.png" alt="image-20230929190709672" style="zoom:33%;" />

- 应用：多项式计算
	- 使用链表可以更好地处理（阶差别较大的）**1**多项式
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929185343560.png" alt="image-20230929185343560" style="zoom:25%;" />

### 栈

- 栈和队列都是**限制存取位置的线性结构**

-  n 个元素入栈，**可能的出栈顺序数目**：
  - 枚举第一个元素的出栈时间，分治 $f(n) = \sum_{i=1}^{i=n}{f(i-1)*f(n-i)}$（卡特兰数），通项为 $f(n) = \frac{C_{2n}^{n}}{n+1}$ 
  - 在于在第一个元素入栈之后出栈之前有 i-1 个元素入栈又出栈，这可以作为一个类似的子问题

### 队列



### 数组



### 矩阵



### 字符串

- 

#难点 
### 广义表

- 

