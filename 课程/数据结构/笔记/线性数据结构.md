### 线性表

- $n(\ge0)$ 个表项的有限序列 $L=(a_1,\dots,a_n)$
- 顺序表：顺序存储方式
  - **存储利用率高**，存取速度**快**
  - 插入、删除等操作时需要**移动大量数据**
- 链表：链表存储方式
  - 适应表的**动态**增长和删除
  - 需要**额外**的指针存储**空间**

#### 顺序表

顺序表类的定义
```c++
#include <iostream.h>	       //定义在“seqList.h”中
#include <stdlib.h>
#include “linearList.h"
const int defaultSize = 100;
template < class E>
    class SeqList: public LinearList<E> {
        protected:
        E *data;		     //存放数组
        int maxSize;	     //最大可容纳表项的项数
        int last;		     //当前已存表项的最后位置
        void reSize(int newSize);	//改变数组空间大小
        public:
        SeqList(int sz = defaultSize);          //构造函数
        SeqList(SeqList<E>& L);	           //复制构造函数
        ～SeqList() {delete[ ] data;}	           //析构函数
        int Size() const {return maxSize;}	 //求表最大容量
        int Length() const {return last+1;}  //计算表长度
        int Search(E& x) const;	
        //搜索x在表中位置，函数返回表项序号
        int Locate(int i) const;
        //定位第 i 个表项，函数返回表项序号
        bool getData(int i, E& x) const;  //取第i个表项的值
        bool Insert(int i, E x);			//插入
        bool Remove(int i, E& x);		//删除
    };

#include <stdlib.h>      //操作“exit”存放在此
#include “seqList.h”    //操作实现放在“seqList.cpp”
template <class E>
    SeqList<E>::SeqList(int sz) { 
        if (sz > 0) {
            maxSize = sz;  last = -1;
            data = new E[maxSize];	   //创建表存储数组
            if (data == NULL){   //动态分配失败
                cerr << "存储分配错误！" << endl;  
                exit(1); 
            }
        }
    };
template <class E>
    SeqList<E>::SeqList ( SeqList<E>& L ) {
        maxSize = L.Size(); 
        last = L.Length()-1; 
        E value;
        data = new E[maxSize];	//创建存储数组
        if (data == NULL)		//动态分配失败
        {cerr << "存储分配错误！" << endl;     exit(1);}
        for (int i = 1; i <= last+1; i++)    //传送各个表项
        {L.getData(i, value); data[i-1] = value;}
    };
template <class E>
    int SeqList<E>::Search(E & x) const {
        //在表中顺序搜索与给定值 x 匹配的表项，找到则
        //函数返回该表项是第几个元素，否则函数返回0
        for (int i = 0; i <= last; i++)	//顺序搜索
            if ( data[i] == x ) 
                return i+1; //表项序号和表项位置差1
        return 0;		    //搜索失败
    };
template <class E> 
    bool SeqList<E>::Insert (int i, E x) {
        //将新元素x插入到表中第i (1≤i≤last+2) 个表项位
        //置。
        if (last == maxSize-1) return false;        //表满
        if (i < 1 || i > last+2) return false;  //参数i不合理
        for (int j = last; j >= i-1; j--)                 //依次后移
            data[j+1] = data[j]; 
        data[i-1] = x;	      //插入(第 i 表项在data[i-1]处)
        last++;
        return true;		           //插入成功
    };
template <class E>
    bool SeqList<E>::Remove (int i, E& x) {
        //从表中删除第 i (1≤i≤last+1) 个表项，通过引用型
        //参数 x 返回被删元素。
        if (last == -1) return false;	           //表空
        if (i < 1 || i > last+1) return false;//参数i不合理
        x = data[i-1];  	
        for (int j = i; j <= last; j++)      //依次前移，填补
            data[j-1] = data[j];
        last--;
        return true; 	
    };	

```
- 查找元素的代价（比较次数）
  - 比较成功 $\frac1n*(1+\dots+n)=\frac{1+n}2$
  - 比较失败 $n$
- 顺序表插入的时间代价（移动次数）
  - $\frac1{1+n}*(n+\cdots+1+0)=\frac n2$
- 删除元素的代价（移动次数）
  - $\frac 1n *(n-1+\cdots+1)=\frac{n-1}2$

- 实现集合运算
```c++
void Union ( SeqList<int> & LA,SeqList<int> & LB ) {
    int n = LA.Length ( );
    int m = LB.Length ( );
    int x;
    for ( int i = 1; i <= m; i++ ) {
        LB.getData(i, x);     //在LB中取一元素
        int k = LA.Search (x);     //在LA中搜索它
        if ( k == 0 )                //若未找到插入它
        {n++; LA.Insert (n, x);}
    }
}
void Intersection ( SeqList<int> & LA, SeqList<int> & LB ) {
    int n = LA.Length ( );
    int m = LB.Length ( );  int i = 1; int x;
    while ( i <= n ) {
        LA.getData (i, x);    //在LA中取一元素
        int k = LB.Search (x);      //在LB中搜索它	
        if ( k == 0 ) { LA.Remove (i,x);  n--;}
        //未找到,在LA中删除它
        else i++;                
    }
}
```

#### 链表

- 插入元素：头中尾三种情况
```c++
bool List::Insert(int i, int x) {
    //将新元素 x 插入到第 i 个结点之后。i 从1开始，
    //i = 0 表示插入到首元结点之前。
    if (first == NULL || i == 0) {	  //空表或首元结点前
        LinkNode *newNode = new LinkNode(x);		  //建立一个新结点
        newNode->link = first;  first = newNode;
        //新结点成为首元结点
    }			 		
    else {                     //否则，寻找插入位置
        LinkNode *current = first;	  int k = 1;     
        while (k < i && current != NULL)    //找第i结点
        { current = current->link;  k++; }
        if (current == NULL && first != NULL)    //链短
        {cerr << “无效的插入位置!\n”;  return false;}
        else {		 //插入在链表的中间
            LinkNode *newNode = new LinkNode(x);
            newNode->link = current->link;
            current->link = newNode;
        }
    }
    return true; 
};

```

- 删除元素：两种情况，头节点或其它节点
```c++
bool List::Remove (int i, int& x) {
//将链表中的第 i 个元素删去, i 从1开始。
    LinkNode *del;		//暂存删除结点指针
	if (i <= 1)  { del = first;  first = first->link; }
	else { 
        LinkNode *current = first;  k = 1;   //找i-1号结点
	    while (k < i-1 && current != NULL)	
  		  { current = current->link;   k++; }
	    if (current == NULL || current->link == NULL) { 	  cout << “无效的删除位置!\n”;  return false;
        }	
        del = current->link;  	 //删中间/尾结点
	 	 current->link = del->link;		
	  }
	  x = del->data;  delete del; 	//取出被删结点数据
	  return true;			
};

```

- 使用附加头节点统一操作
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231108142313329.png" alt="image-20231108142313329" style="zoom:33%;" />
  - ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240104174324.png)
  - ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240104174332.png)


- 循环链表
	- 搜索：从表头出发，再次回到表头是终止

- 带头节点的双向循环链表
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929182712053.png" alt="image-20230929182712053" style="zoom: 25%;" />
	- ![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240104174920.png)

- 静态链表 [[图论#链式前向星]]
	- 为数组中每一个元素**附加一个链接指针**，就形成静态链表结构。
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929190709672.png" alt="image-20230929190709672" style="zoom:33%;" />

- 应用：多项式计算
	- 使用链表可以更好地处理（阶差别较大的）**1**多项式
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929185343560.png" alt="image-20230929185343560" style="zoom:25%;" />

### 栈

- 栈和队列都是**限制存取位置的线性结构**

-  n 个元素入栈，**可能的出栈顺序数目**：
  - 枚举第一个元素的出栈时间，分治 $f(n) = \sum_{i=1}^{i=n}{f(i-1)*f(n-i)}$（**卡特兰数**），通项为 $f(n) = \frac{C_{2n}^{n}}{n+1}$ 
  - 在**第一个元素**入栈之后出栈**之前**有 i-1 个元素**入栈又出栈**，这可以作为一个类似的子问题

- 双栈共享空间
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929192722735.png" alt="image-20230929192722735" style="zoom:33%;" />

- 链式栈
	- **栈顶在链头**，插入与删除仅在栈顶处执行
	-  ![image-20230929193637012](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929193637012.png)

#### 应用：表达式求值

#难点 
- 中缀转化为后缀
	- `A + B * (C - D) - E / F ` -> `ABCD-*+EF/-`
	- 手动转化：先对中缀表达式按运算优**先次序加上括号**，再**把操作符后移到右括号的后面**并以就近移动为原则，最后将所有括号消去。
		- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231108151451666.png" alt="image-20231108151451666" style="zoom:50%;" />
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929194833254.png" alt="image-20230929194833254" style="zoom:33%;" />
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929194856002.png" alt="image-20230929194856002" style="zoom:33%;" />
    - 如果是**数字直接输出**
    - `;` 用作标识，开始之前先将 `;` **入栈**，并且中缀表达式**末尾**也有一个 `;`（用作结束时**清空栈**）
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231107212727767.png" alt="image-20231107212727767" style="zoom:50%;" />
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231107212737135.png" alt="image-20231107212737135" style="zoom:50%;" />

- 后缀表达式求值
	- 遍历后缀表达式，遇到数就压栈，遇到操作复就从栈中取数进行计算，再放回栈中
	- 栈中剩下的最后一个元素就是计算结果

#### 应用：栈与递归

- **单向递归和尾递归**可直接用迭代实现其非递归过程其他情形必须**借助栈实现非递归过程**

- 单项递归：如求解斐波那契数列（类似动态规划）
- 尾递归：如求解阶乘

### 队列

- 顺序队列（数组表示）
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20230929202943266.png" alt="image-20230929202943266" style="zoom:33%;" />
	- 进队：rear++；出队：front++
	- 队空时：rear=front；队满时：rear=maxSize
	- 随着元素进入与弹出，逐渐无法使用，出现**假溢出**（使用环形队列解决）

- 循环队列
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231107220444662.png" alt="image-20231107220444662" style="zoom:33%;" />
	- 队头指针进 1: front = (front+1) % maxSize; 
	- 队尾指针进 1: rear = (rear+1) % maxSize; 
	- 队列初始化：front = rear = 0; 
	- 队空条件：front == rear; 
	- **队满条件**：(rear+1) % maxSize == front

- 链式队列
	- ![image.png|350](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240104184824.png)
	- 队头在链头，队尾在链尾。
	- 注意操作时需要**讨论是否为空**

- 优先级队列
	- 每次从队列中取出的是具有最高优先权 (优先级)的元素
	  - 数组实现：每次**插入到相应位置维护顺序**
	  - ![image.png|325](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240104184950.png)

- 应用：计算杨辉三角
	- 从前一行的数据可以计算得到下一行的数据（类似一个 BFS 的过程）
	- 在每一行左右加上零统一递推式
	- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231107222221641.png" alt="image-20231107222221641" style="zoom: 50%;" />
```cpp
void YANGHVI(int n) {
    Queue q(n+3); //队列初始化
    q.makeEmpty();
    q.EnQueue(1);
    q.EnQueue(1); 
    int s = 0, t;
    for (int i = 1; i <= n; i++) { //逐行计算
        cout << endl;
        q.EnQueue(0); 
        for (int j = 1; j <= i+2; j++) { //下一行
            q.DeQueue(t);
            q.EnQueue(s + t);
            s = t;
            if (j != i+2) 
                cout << s << ' '; 
        } 
    } 
}
```

### 数组

- 数组是相同类型的数据元素的集合
-  n 维数组元素存储地址 $a+(\sum_{j=1}^{n-1}(i_j*\prod^n_{k=j+1}m_{k})+i_n)*l$
	- i 表示对应下标的值，m 表示对应维度的容量

- 对称矩阵（一定是方阵）
	- 只需要存储为上三角矩阵/下三角矩阵
	- 总共需要存储 $n*(n+1)/2$ 个元素
	- ![image.png|300](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240104205004.png)
	- ![image-20231024004056130|300](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231024004056130.png)
	- **下三角矩阵中**，对于 $i>=j$ 数组元素 $A[i][j]$ 在数组中存放位置为 $1+2+\cdots+i+j=(i+1)*i/2+j$
	- 已知位于位置 k，则 $i*(i+1)/2<=k<(i+1)*(i+2)/2$ 的 i 及 $j=k-i*(i+1)/2$ 的到元素的下标
	- 对于**上三角矩阵**$A[i][j]$ (i<=)位于 $n+(n-1)+\dots+(n-i+1)+j-i=(2*n-i-1)*i/2+j$

- 对三角矩阵
	- 

### 字符串

- 

#难点 
#### KMP

- 

#难点 
### 广义表

- 

