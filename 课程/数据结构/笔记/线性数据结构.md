### 线性表

- $n(\ge0)$ 个表项的有限序列 $L=(a_1,\dots,a_n)$
- 顺序表：顺序存储方式
  - **存储利用率高**，存取速度**快**
  - 插入、删除等操作时需要**移动大量数据**
- 链表：链表存储方式
  - 适应表的**动态**增长和删除
  - 需要**额外**的指针存储**空间**

#### 顺序表

顺序表类的定义
```c++
#include <iostream.h>	       //定义在“seqList.h”中
#include <stdlib.h>
#include “linearList.h"
const int defaultSize = 100;
template < class E>
    class SeqList: public LinearList<E> {
        protected:
        E *data;		     //存放数组
        int maxSize;	     //最大可容纳表项的项数
        int last;		     //当前已存表项的最后位置
        void reSize(int newSize);	//改变数组空间大小
        public:
        SeqList(int sz = defaultSize);          //构造函数
        SeqList(SeqList<E>& L);	           //复制构造函数
        ～SeqList() {delete[ ] data;}	           //析构函数
        int Size() const {return maxSize;}	 //求表最大容量
        int Length() const {return last+1;}  //计算表长度
        int Search(E& x) const;	
        //搜索x在表中位置，函数返回表项序号
        int Locate(int i) const;
        //定位第 i 个表项，函数返回表项序号
        bool getData(int i, E& x) const;  //取第i个表项的值
        bool Insert(int i, E x);			//插入
        bool Remove(int i, E& x);		//删除
    };

#include <stdlib.h>      //操作“exit”存放在此
#include “seqList.h”    //操作实现放在“seqList.cpp”
template <class E>
    SeqList<E>::SeqList(int sz) { 
        if (sz > 0) {
            maxSize = sz;  last = -1;
            data = new E[maxSize];	   //创建表存储数组
            if (data == NULL){   //动态分配失败
                cerr << "存储分配错误！" << endl;  
                exit(1); 
            }
        }
    };
template <class E>
    SeqList<E>::SeqList ( SeqList<E>& L ) {
        maxSize = L.Size(); 
        last = L.Length()-1; 
        E value;
        data = new E[maxSize];	//创建存储数组
        if (data == NULL)		//动态分配失败
        {cerr << "存储分配错误！" << endl;     exit(1);}
        for (int i = 1; i <= last+1; i++)    //传送各个表项
        {L.getData(i, value); data[i-1] = value;}
    };
template <class E>
    int SeqList<E>::Search(E & x) const {
        //在表中顺序搜索与给定值 x 匹配的表项，找到则
        //函数返回该表项是第几个元素，否则函数返回0
        for (int i = 0; i <= last; i++)	//顺序搜索
            if ( data[i] == x ) 
                return i+1; //表项序号和表项位置差1
        return 0;		    //搜索失败
    };
template <class E> 
    bool SeqList<E>::Insert (int i, E x) {
        //将新元素x插入到表中第i (1≤i≤last+2) 个表项位
        //置。
        if (last == maxSize-1) return false;        //表满
        if (i < 1 || i > last+2) return false;  //参数i不合理
        for (int j = last; j >= i-1; j--)                 //依次后移
            data[j+1] = data[j]; 
        data[i-1] = x;	      //插入(第 i 表项在data[i-1]处)
        last++;
        return true;		           //插入成功
    };
template <class E>
    bool SeqList<E>::Remove (int i, E& x) {
        //从表中删除第 i (1≤i≤last+1) 个表项，通过引用型
        //参数 x 返回被删元素。
        if (last == -1) return false;	           //表空
        if (i < 1 || i > last+1) return false;//参数i不合理
        x = data[i-1];  	
        for (int j = i; j <= last; j++)      //依次前移，填补
            data[j-1] = data[j];
        last--;
        return true; 	
    };	

```
- 查找元素的代价（比较次数）
  - 比较成功 $\frac1n*(1+\dots+n)=\frac{1+n}2$
  - 比较失败 $n$
- 顺序表插入的时间代价（移动次数）
  - $\frac1{1+n}*(n+\cdots+1+0)=\frac n2$
- 删除元素的代价（移动次数）
  - $\frac 1n *(n-1+\cdots+1)=\frac{n-1}2$

- 实现集合运算
```c++
void Union ( SeqList<int> & LA,SeqList<int> & LB ) {
    int n = LA.Length ( );
    int m = LB.Length ( );
    int x;
    for ( int i = 1; i <= m; i++ ) {
        LB.getData(i, x);     //在LB中取一元素
        int k = LA.Search (x);     //在LA中搜索它
        if ( k == 0 )                //若未找到插入它
        {n++; LA.Insert (n, x);}
    }
}
void Intersection ( SeqList<int> & LA, SeqList<int> & LB ) {
    int n = LA.Length ( );
    int m = LB.Length ( );  int i = 1; int x;
    while ( i <= n ) {
        LA.getData (i, x);    //在LA中取一元素
        int k = LB.Search (x);      //在LB中搜索它	
        if ( k == 0 ) { LA.Remove (i,x);  n--;}
        //未找到,在LA中删除它
        else i++;                
    }
}
```

#### 链表

- 

### 栈

- 栈和队列都是**限制存取位置的线性结构**

### 队列

### 数组

### 矩阵

### 字符串

### 广义表

