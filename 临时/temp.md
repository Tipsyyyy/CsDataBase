## 离散化

- stl实现

  - ```c++
    sort(X,X+num);
    int m=unique(X,X+num)-X;//离散化
    for(int i=0; i<n; i++)
    {
        int l=lower_bound(X,X+m,li[i])-X;//寻找位置
        int r=lower_bound(X,X+m,ri[i])-X;
        update(l,r,i,0,m,1);
    }
    ```

- 对区间进行离散化时可以如果两个区间之间不是连续的，应该插入额外元素

  - \[1,100]\[200,500]->\[1,2]\[4,5]（如区间覆盖问题，本来来没覆盖，变成覆盖了）
  - 重完毕后，进行一个处理,如果相邻数字**间距大于1**的话**,在其中加上任意一个数字**。这样会把原来的缝隙留出来.

## 输入输出

| 格式字符 | 意义                                                         |
| :------- | :----------------------------------------------------------- |
| a, A     | 以十六进制形式输出浮点数(C99 新增)。实例 **printf("pi=%a\n", 3.14);** 输出 **pi=0x1.91eb86p+1**。 |
| d        | 以十进制形式输出带符号整数(正数不输出符号)                   |
| o        | 以八进制形式输出无符号整数(不输出前缀0)                      |
| x,X      | 以十六进制形式输出无符号整数(不输出前缀Ox)                   |
| u        | 以十进制形式输出无符号整数                                   |
| f        | 以小数形式输出单、双精度实数                                 |
| e,E      | 以指数形式输出单、双精度实数                                 |
| g,G      | 以%f或%e中较短的输出宽度输出单、双精度实数                   |
| c        | 输出单个字符                                                 |
| s        | 输出字符串                                                   |
| p        | 输出指针地址                                                 |
| lu       | 32位无符号整数                                               |
| llu      | 64位无符号整数                                               |

### 快读

- ```c++
  template<typename T>
  inline void read(T &a)
  {
     T s = 0, w = 1;
     char c = getchar();
     while(c < '0' || c > '9')
     {
         if(c == '-') w = -1;
         c = getchar();
     }
     while(c >= '0' && c <= '9')
     {
         s = (s << 1) + (s << 3) + (c ^ 48);
         c = getchar();
     }
     a = s*w;
  }
  ```

### getline

- `istream& getline ( istream &is , string &str [, char delim ]);`
  - is常用cin
  - delim表示读取到该字符串时停止，默认为`\n`回车

