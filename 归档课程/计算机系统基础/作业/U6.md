##### 211275022田昊东

#### 3、

1. 需要在位上拓展8倍（$512/64=8$），故一个内存条上需要8个DRAM芯片

2. 需要4个内存条（$2048/512=4$）

3. - 需要32位主存地址（$4GB=2^{32}B$）

   - 单个存储芯片的结构为：

     - $64*1024*1024$=$2^{13}*2^{13}$
     - 故芯片内地址位数为26
     - 行地址、列地址均为13位
   
   - 由于一条内存有8个芯片，因此3位用于选择芯片

   - | 行号 | 列号 | 选片 |
     | ---- | ---- | ---- |
     | 13   | 13   | 3    |

#### 4、

1. 
   - RAM区的地址范围：`8000~FFFF`
     - $32KB=32*1024=2^{15}$
   - 需要4块RAM芯片（$32/16*8/4=4$）
   - 地址线中的第一位用于区分ROM区和RAM区
2. - 若地址线为24根，则内存总大小为$2^{24}=16MB$
   - 需要RAM芯片的总数目为：$2*16*1024/16-4=2044$

#### 5、

- 程序处理时间为：$20000/(500*10^6)=40*10^{-6}s=0.04ms$
- 平均旋转等待时间：$60/7200/2=4.17ms$
- 数据传输时间：$(4*2^{10})/(40*10^{6})=0.1024ms$
- 由此一次读出处理写回的时间为$(2ms+10ms+4.17ms+0.1024ms)*2+0.04ms=32.58ms$
- 固 每秒完成的操作次数为$1000/32.58=30$

#### 8、

1. - $1GB=2^{30}$ 故贮存地址应该有30位

   - $128B=2^{7}$ 故块内偏移量应该为7位

   - $64KB/128B=2^{16-7}=2^9$ 故index有9位

   - 那么tag有$30-7-9=14$位

   - 故内存地址划分如下：

     - | tag  | index | offset |
       | ---- | ----- | ------ |
       | 14   | 9     | 7      |

2. $512*(1+14+128*8)=519.5Kbit$

#### 12、

1. x、y都是数组，并且都按照下标访问，即访问的是连续的内存空间，因此具有良好的空间局限性；但是针对数组中的每一个元素都只会访问一次，因此时间局限性较差。在大多情况下，命中率较好，但具体的情况与cache的大小及算法策略相关。

2. - $32B/16B=2$，故cache中只有两个块

   - ​							

     | i    | x         | 对应块号 | y         | 对应块号 |
     | ---- | --------- | -------- | --------- | -------- |
     | 0    | 0x8049040 | 8407301  | 0x8049060 | 8407303  |
     | 1    | 0x8049044 | 8407301  | 0x8049064 | 8407303  |
     | 2    | 0x8049048 | 8407301  | 0x8049068 | 8407303  |
     | 3    | 0x804904c | 8407301  | 0x804906c | 8407303  |
     | 4    | 0x8049050 | 8407302  | 0x8049070 | 8407304  |
     | 5    | 0x8049054 | 8407302  | 0x8049074 | 8407304  |
     | 6    | 0x8049058 | 8407302  | 0x8049078 | 8407304  |
     | 7    | 0x804905c | 8407302  | 0x804907c | 8407304  |

   - 不难看出i相同的x[i]y与y[i]根据直接应设法会对应到同一块cache，因此在整个过程中cache命中率为0

3. - cache会被分为2组，每组各有容量为8B的两行

   - | i    | x         | 对应块号 | y         | 对应块号 |
     | ---- | --------- | -------- | --------- | -------- |
     | 0    | 0x8049040 | 16814600 | 0x8049060 | 16814604 |
     | 1    | 0x8049044 | 16814600 | 0x8049064 | 16814604 |
     | 2    | 0x8049048 | 16814601 | x8049068  | 16814605 |
     | 3    | 0x804904c | 16814601 | 0x804906c | 16814605 |
     | 4    | 0x8049050 | 16814602 | 0x8049070 | 16814606 |
     | 5    | 0x8049054 | 16814602 | 0x8049074 | 16814606 |
     | 6    | 0x8049058 | 16814603 | 0x8049078 | 16814607 |
     | 7    | 0x804905c | 16814603 | 0x804907c | 16814607 |

   - i=0时会将块16814600和16814604缓存到cache组1中，之后i=1时会全部命中；i=2时又会将块缓存到组2中以此类推
   - 即命中率为50%

4. - 

   - | i    | x         | 对应块号 | y         | 对应块号 |
     | ---- | --------- | -------- | --------- | -------- |
     | 0    | 0x8049040 | 8407301  | 0x8049070 | 8407304  |
     | 1    | 0x8049044 | 8407301  | 0x8049074 | 8407304  |
     | 2    | 0x8049048 | 8407301  | 0x8049078 | 8407304  |
     | 3    | 0x804904c | 8407301  | 0x804907c | 8407304  |
     | 4    | 0x8049050 | 8407302  | 0x8049080 | 8407305  |
     | 5    | 0x8049054 | 8407302  | 0x8049084 | 8407305  |
     | 6    | 0x8049058 | 8407302  | 0x8049088 | 8407305  |
     | 7    | 0x804905c | 8407302  | 0x804908c | 8407305  |
     | 8    | 0x8049060 | 8407303  | 0x8049090 | 8407306  |
     | 9    | 0x8049064 | 8407303  | 0x8049094 | 8407306  |
     | 10   | 0x8049068 | 8407303  | 0x8049098 | 8407306  |
     | 11   | 0x804906c | 8407303  | 0x804909c | 8407306  |

   - 对于前四次访问，x会被缓存在cache1中，y会被在cache2中，因此会命中6次。
   - 即命中率为75%

#### 13、

- dst是列优先访问、src是行优先访问
- dst起始点对应的块是8408064，src对应的块为8408068，数组中的一行对应一个块

1. - $32B/16B=2$，故cache中只有2个块

   - |       | col=0  | col=1  | col=2  | col=3  | col=0  | col=1  | col=2  | col=3  |
     | ----- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
     | row=0 | 0/miss | 0/miss | 0/hit  | 0/miss | 0/miss | 0/miss | 0/miss | 0/miss |
     | row=1 | 1/miss | 1/hit  | 1/miss | 1/hit  | 1/miss | 1/miss | 1/miss | 1/miss |
     | row=2 | 0/miss | 0/miss | 0/hit  | 0/miss | 0/miss | 0/miss | 0/miss | 0/miss |
     | row=3 | 1/miss | 1/hit  | 1/miss | 1/hit  | 1/miss | 1/miss | 1/miss | 1/miss |

2. - $128B/16B=8$，故cache中有8个块

   - $8408064mod8=0$   $8408068mod8=4$ 

   - |       | col=0  | col=1 | col=2 | col=3 | col=0  | col=1 | col=2 | col=3 |
     | ----- | ------ | ----- | ----- | ----- | ------ | ----- | ----- | ----- |
     | row=0 | 4/miss | 4/hit | 4/hit | 4/hit | 0/miss | 0/hit | 0/hit | 0/hit |
     | row=1 | 5/miss | 5/hit | 5/hit | 5/hit | 1/miss | 1/hit | 1/hit | 1/hit |
     | row=2 | 6/miss | 6/hit | 6/hit | 6/hit | 2/miss | 2/hit | 2/hit | 2/hit |
     | row=3 | 7/miss | 7/hit | 7/hit | 7/hit | 3/miss | 3/hit | 3/hit | 3/hit |

#### 19、

- $256B/32B=8$即cache有8行
- s=64时两个a[j]之间刚好相差8个块，即意味着会被应为着会被映射到同一个cache块中

1. - s=64
     - 在循环中会反复访问a[0]和a[64]，也就输cache会被反复替换，缺失率为100%
   - s=63
     - a[63]和a[126]会被映射到同一个cache发生替换，而a[0]会被映射到不同的cache，因此a[0]只有第一次会miss之后都会hit而a[63]和a[126]每次都会miss
     - 故缺失率约为67.7%
2. - s=64
     - a[0]和a[64]会被映射到同一组的不同行，即只有第一次会miss之后都会hit，缺失率约为0%
   - s=63
     - a[0]会被映射到单独的组，而a[63]和a[126]会被映射到同一组的不同行，即只有第一次会miss之后都会hit，缺失率约为0%

#### 20、

- $2^{40}/2^{14}=2^{26}$即一共会有$2^{26}$页
- 页表中一项需要占用$40+4+36-26-14-14=26$字节
- 也就说整个页表会非常大（几MB）远大于页的大小，无法直接进行存储，因此要引入多级页表机制。

#### 21、

1. - $128=2^{7}$ 即页内偏移量为7位
   - 因此虚拟地址中前9位表示虚拟页号，后7位表示页内偏移量
   - 因为TLB有4个组（$16/4=4$）故TLB索引应该为2位
   - 即虚拟页号中前7位为TLB标记，后2位位TLB索引
2. 物理地址中前5位为物理页号，后7位表示页内偏移量
3. - cache有16行，因此行索引字段应该有4位，cache块大小为4，因此块内偏移量为2位
   - 即标记字段为前6位，行索引字段为后面4位，块内地址字段为最后2位
4. - `067a`转化为二进制`0000011 00 1111010`
   - TLB标记为3，TLB索引为0，发现对应项的有效位为0，TLB miss
   - 在页表中寻找虚拟页号为0c的项，得到页框号19
   - 即得到物理地址`110011 1110 10`
   - 在E行找到标记位为33的项，其中第2(10)字节的内容为4a，第三字节2d，即short变量为`0x2d4a`

#### 23、

1. ```assembly
   mov $0, %ecx
   .loop
   cmp %ebx,%ecx
   jge .end
   add (%edx,%ecx,4),%eax
   add $1,%ecx
   jmp .loop
   .end
   ```

2. 都是1，因为已经进入了保护模式并开启了分页

3. `add (%edx,%ecx,4),%eax`使用内存寻址和寄存器寻址

   - 其中内存寻址使用基址比例变址偏移量模式

4. - 指令的线性地址为：`0x8048c08`
   - 转化为二进制为`0000100000 0001001000 110000001000`
     - 由于页大小为4KB可知页内偏移量为12位
     - 虚页号为`8048`(`00001000000001001000`)
   - 由于页数有1024页，故页表索引有10位，页目录索引也为10位
     - 故页目录索引为`0000100000`，页表索引为`0001001000`，页内偏移量为`110000001000`
   - 页目录项位于`0x3d000`；页表项位于`0x5c8000`；指令 I位于`0x8048c08`
   - p=1;R/W=0;U/S=1;A=1;D=0;

5. - 通常发生缺页，指令I和操作数a[0]都不位于页的头部，即在按顺序执行前面的页时就已经完成了页的加载；
   - 但是如果a[0]前面的数据没有被访问，那a[0]可能发生缺页。如果发生，地址为`0x8049000`，存储在CR2寄存器。

6. - 可能发生缺失，与(5)同理，取a[0]时可能发生TLB的缺失。
   - 虚页号中前18位为TLB标记，后2位为TLB索引
   - 指令1的TLB标记为`02012`，TLB索引为`0`而对应项不在该TLB表中？？（出现了故障？）

7. - $8*1024/32=2^{13-5}=2^8$即cache中有$2^8$块，分为$2^7$组
   - 同理指令I不位于主存块的起始位置，因此不会发生cache缺失
   - 对地址划分，块内偏移量有5位，块索引有7位，而块标记为前20位，
   - 块索引号为96，即映射到96组

8. - 此时数组a占用空间的大小为$8KB$，因此会占用2个页面，虚页号分别为`0000 10000 0000 0100 1101`和`0000 10000 0000 0100 1110`
   - a[1200]位于有一个页面中