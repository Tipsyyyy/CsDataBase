##### 211275022田昊东

#### 3、

- 易知所有对都存在重叠区间

- P1-P2:是
- P1-P3:是
- P1-P4:是
- P2-P3:是
- P3-P4:是

#### 4、

1. 不可能，上述7条指令位于同一个页中，并且第一条指令不位于页的起点，因此在指令执行之前页已经被加载到主存，因此不可能发生缺页错误

2. - 执行第一条指令时需要从`0x80497d0`读取数据而该页并不在主存中，因此会发生缺页的异常，这是可以恢复的异常。

     - ```
       		用户进程
       		   |     缺页故障       OS异常处理程序
       指令1       |———————————————————————>
       		   |						|从磁盘读取缺失的内容
       继续执行用户 |<——————————————————————	|装载到主存
       程序... 	 |
       ```

   - 执行第二条指令时需要从`0x804a324`读取数据而该页并不在主存中，因此会发生缺页的异常，这是可以恢复的异常。

   - 执行第六条指令时不会发生异常，但是实际上已经发生了数据越界，覆盖了k的值。

   - 执行第七条指令时可能已经超出了用户可读写的范围，可能出现段错误，这是不可以恢复的错误。

     - ```
       		用户进程
       		   |     页故障       OS异常处理程序
       指令7	      |———————————————————————>
       									|检测到地址越界
       									|发送SIGSEG信号
       									|给用户进程
       ```

3. 程序没有为k赋值，由于.bss节会被初始化为全0，因此k通常会具有默认值0，因此在取余数操作时会出现不可恢复的除以零的异常。

#### 5、

1. 执行这段代码时系统处于用户态，前四条指令是由用户程序进行系统调用的参数传递过程，第5条指令是传送指令后的陷阱指令，执行完第5行后会内陷到内核态。
2. 第5行指令属于陷阱指令，这条指令(int 0x80)属于系统门，中断类型号为128(0x80)，P=1，DPL=3，TYPE=1111B；GDT中基地址为0，限界为0xFFFFFFFF，G=1,S=1,TYPE=1010,DPL=0,D=1,P=1
3. - 首先通过int的参数0x80得到中断类型号128，从IDTR中取出IDT的首地址并取出第128个表项
   - 根据IDT提供的段选择符及偏移量，从GDT中取出对应的段描述符
   - 执行`int 0x80`指令，开始进行用户态向内核态的转化
     - 读取TR寄存器，访问TSS并将TSS中保存的内核栈的段寄存器内容和栈指针装入SS和ESP
     - 一次将执行完int指令时的SS ESP EFLAGS CS EIP的内容保存到内核栈中
     - 将IDT中的段选择符装入CS，偏移地址装入EIP，指向system_call的第一条指令
     - 当内核系统调用执行完成后调用iret，复原寄存器，回到第5行后继续执行