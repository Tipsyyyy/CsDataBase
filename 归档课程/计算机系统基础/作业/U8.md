##### 211275022田昊东

#### p3

- 进行标准输出stdout，输出'Hello, World.'
- 执行`inr $0x80`时
- 使用了两个系统调用：4号`write`和1号`exit`

#### p4

- ```
  |		ebp		|<-ebp
  |		14		|
  |0x..(字符串地址) |
  |		1		|<-esp
  ```

- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/Snipaste_2023-06-04_17-49-18.png" alt="Snipaste_2023-06-04_17-49-18" style="zoom:33%;" />

- 上一题使用汇编直接调用系统服务，这种方法显然更为麻烦，不易书写，并且容易出现安全问题，本题使用操作系统封装的IO进行操作，安全便捷；本题因为使用封装的IO，因此其性能会差于上一题中的系统调用

#### p5

- 因为printf函数是包含在c标准库中的，因此可以通过`#include <stdio.h>`来引入。编译器通过符号解析以及连接等步骤，可以从c标准库中引入printf函数。

- - 预处理：去除并展开宏定义，去掉注释
  - 编译：生成汇编语言程序
  - 汇编：将汇编文件转化为可重定向的机器语言文件
  - 链接：将多个可重定向文件链接起来得到可执行文件

- `printf`有默认输出设备stdout，因此会自动输出到屏幕不需要指定

- 用16进制表示`48 65 6c 6c 2c 77 6f 72 6c 64 0a 00`，在只读数据节`.rodata`，位于只读代码段

- 在c标准库中`libc.a`，映射到制度代码段，动态链接时在共享库区域

- ```c
  //保存被调用者保存寄存器ebx
  //将要写入的字符串长度存入寄存器edx
  //将字符串地址写入寄存器ecx
  //将文件描述符fd写入寄存器ebx
  //将系统调用号保存到寄存器eax
  //自陷到内核态
  //恢复被调用者保存寄存器ebx
  //将西永调用返回值（写入字节的数目）与0xfffff001进行比较
  //如果大于等于则转到异常处理
  //退出函数调用，返回返回地址
  ```

  - 由于进行无符号数的比较，%eax>=$0xfffff001的含义就是-4095<=%eax<=-1故最大错误号为4095

- 相比之下本题的使用更为安全便捷，并且可以在不同平台运行，不依赖于操作系统，并且引入了缓冲区机制，拥有更好的性能

#### p8

- 使用中断控制时，每秒需要中断$6*4000/60=400$次，所需要的时钟周期为$400*1000=4*10^6<5*10^8$，故可以使用

#### p9

- 数据缓存器为16位也就是说一次中断可以传递两个字节，每秒的中断次数为$20KB/2B=10^4$次，需要的时钟周期为$10^4*500=5*10^6<5*10^8$因此可以
- 此时的中断次数为$2MB/2B=10^6$，需要的时钟周期为，因此加上中断相应的时间后cpu不足以进行处理，对于这种需要告诉传输的情况，不应该再使用中断的方法

#### p12

- DMA每$2B/16*512/(8.192*10^{-3})=2ys$占用一次总线，也就要说CPU没执行4条指令会被阻塞一次$250ns$，即速度降低$12.5$%