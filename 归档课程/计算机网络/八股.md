### HTTP

1. **定义**：HTTP 是一个应用层协议，用于传输超文本（如 HTML 文件）。
2. **无状态协议**：HTTP 本身是**无状态**的，意味着服务器不会保存关于客户端请求的任何信息。
3. **明文传输**：在 HTTP 中，数据是以**明文**形式发送的，这使其容易受到中间人攻击，攻击者可以捕获和查看传输的数据。

#### HTTPS

1. **定义**：HTTPS 实际上就是在 HTTP 上添加了一层**安全套接层/传输层安全**（SSL/TLS）。
2. **加密传输**：与 HTTP 不同，HTTPS 通过 SSL/TLS 对传输的**数据进行加密，确保数据的隐私性和完整性**。
3. **证书和握手**：在 HTTPS 连接建立过程中，会进行一个 SSL/TLS 握手，其中一步是**服务器向客户端发送其证书**。这个证书包含了公钥和由权威证书颁发机构（CA）的签名。

#### GET与POST

1. **用途**：
   - **GET**：通常用于**请求**服务器上的**资源**。
   - **POST**：通常用于向服务器**提交数据**进行处理，例如表单提交。
2. **参数传递方式**：
   - **GET**：参数**直接附加在 URL** 上，形如 `http://example.com/api?param1=value1&param2=value2`。
   - **POST**：参数放在请求的**主体** (body) 中，并不直接暴露在 URL 上。
3. **数据长度**：
   - **GET**：由于参数是附加在 URL 上的，因此受到 URL 长度的限制，通常是受浏览器或服务器的限制。
   - **POST**：理论上没有长度限制，受到请求主体的大小和服务器配置的限制。
4. **安全性**：
   - **GET**：较为**不安全**，因为参数直接暴露在 URL 中，容易被保存在浏览器历史或服务器日志中。
   - **POST**：**相对**更安全，因为数据不会暴露在 URL 中。但仍然可以通过网络抓包工具查看。
5. **服务器行为**：
   - **GET**：应该是幂等的，意味着多次重复的 GET 请求应产生相**同的结果**。
   - **POST**：不必是幂等的，每次 POST **可能产生不同的结果**或副作用。

### DNS

1. **定义**：DNS 是一个分布式的系统，用于将人类可读的**域名**（如 `www.example.com`）**转换为与之相关的 IP 地址**（如 `192.0.2.1`）。
2. **分层结构**：DNS 有一个分层的结构，包括根服务器、顶级域服务器（TLD）、权威名称服务器和本地DNS服务器。
3. **缓存**：为了提高性能并减少不必要的查询，DNS 结果通常会在多个级别（如浏览器、操作系统、本地DNS服务器）进行缓存。

#### 分层查询过程

1. DNS客户端（通常是你的设备）

   - 当你在浏览器中输入一个域名，例如 `www.example.com`，查询首先从你的设备开始：

   - **浏览器缓存**：浏览器可能已缓存了之前查询的域名的结果。

   - **操作系统缓存**：如果浏览器缓存中没有该域名的记录，操作系统也可能有一个缓存的解析结果。

2. 本地DNS服务器
   - 如果上述两个级别都没有缓存结果，你的设备会向为你配置的**本地DNS服务器**发送查询，通常是你的网络服务提供商或你使用的其他DNS服务（如Google DNS、Cloudflare等）提供的。
   - 本地DNS服务器的主要功能是**为客户端提供DNS解析服务**。它们接收来自客户端的域名查询请求，然后进行一系列的查询，直到找到正确的答案，并将其返回给客户端。**不属于层次结构**

3. 根DNS服务器
   - 如果本地DNS服务器也没有缓存的结果，它会开始一个递归查询。首先，它会询问根DNS服务器。根服务器不会直接知道答案，但它知道如何**引导查询到下一**级。

4. 顶级域(TLD) DNS服务器
   - 根据上述例子中的 `.com`，根DNS服务器会指向负责 `.com` 顶级域的TLD服务器。再次，TLD服务器可能不知道 `www.example.com`，但它知道哪个权威DNS服务器负责 `example.com` 域。

5. 权威DNS服务器
   - 权威服务器是保存特定域名信息的服务器。在这个步骤中，TLD服务器将查询路由到负责 `example.com` 的权威服务器。这个权威服务器知道 `www.example.com` 的IP地址，并将其返回给本地DNS服务器。

6. 返回给客户端
   - 一旦**本地DNS服务器获得** `www.example.com` 的IP地址，它会将这个地址**返回**给请求的客户端（你的设备）。此外，它还会在其**缓存**中保存这个地址一段时间，以便下次有相同的请求时能更快地提供答案。

### CDN

1. **定义**：CDN 是一个**分布式**的服务器网络，旨在快速、可靠、高效地为用户交付 Web 内容和应用程序。
2. **工作方式**：CDN 会将网站内容（如图片、视频、样式表和 JavaScript 文件）**缓存到各地的边缘服务器上**。当用户请求这些内容时，CDN 会将请求路由到最近的边缘服务器，从而减少延迟并加速内容的加载。
3. **优势**：
   - **性能**：通过将内容放在靠近用户的地方，CDN 可以显著减少延迟和提高页面加载速度。
   - **可靠性**：如果一个边缘服务器出现故障，CDN 可以轻松地将流量路由到另一个服务器。
   - **缩放性**：CDN 可以处理大量的流量，保护源服务器免受流量峰值的影响。
   - **安全性**：某些 CDN 提供安全性功能，如 DDoS 攻击缓解和 Web 应用程序防火墙。

### cookies与session

#### Cookies

1. **定义**：Cookies 是小段数据，**存储在用户的浏览器上**。
2. **作用**：用于保存用户的**偏好设置、登录状态**、购物车内容等。
3. **生命周期**：可以是临时的（即浏览器关闭时删除）或长时间的，取决于其过期设置。
4. **限制：**
   - 浏览器通常限制每个域的 Cookie 数量。
   - Cookie 的**大小通常有限制**（大约 4KB）。
5. **安全性**：如果**不使用特定的安全措施**（如 HTTPS 和设置为 HttpOnly），Cookies 可能会**被截获或篡改**。

#### Session

1. **定义**：Session 是在服务器上为**特定用户或浏览器会话**存储的数据。
2. **作用**：用于**跟踪用户状态**，如登录信息、用户偏好、购物车等。
3. **存储位置**：与 Cookies 不同，Session 数据存**储在服务器端**。
4. **生命周期**：通常，Session 在**一定时间内不活跃后会过期**，或当用户显式地注销或关闭浏览器时结束。
5. **关联**：Session 通常使用一个标识符（通常称为 Session ID）**与特定用户相关联**。这个 Session ID 可以存储在 Cookie 中，也可以通过 URL 参数传递。

#### Cookies 与 Session 的关系

尽管 Cookies 和 Session 看起来很相似，但它们解决问题的方式是不同的：

- **存储位置**：Cookies 在客户端（浏览器）上存储，而 Session 在服务器上存储。
- **存储数据量**：由于浏览器对每个域的 Cookies 有大小和数量限制，因此 Cookies 适合存储小量数据。而 Session 在服务器端，理论上其存储量只受到服务器存储能力的限制。
- **生命周期**：Cookies 可以设置为长时间保持，甚至在浏览器关闭后依然存在，而 Session 的生命周期通常比较短，与特定的会话关联。
- **安全性**：存储在客户端的 Cookies 比存储在服务器上的 Session 更容易受到攻击（如 XSS、CSRF 攻击）。但也可以采取措施（如设置 Cookie 的 HttpOnly 和 Secure 标志）来提高安全性。

### TCP与UDP

#### TCP 

1. **连接导向**：TCP 是一个**面向连接的协议**。这意味着在数据传输开始之前，通信的两个端点必须首先建立连接。
2. **可靠性**：TCP 提供了数据的**可靠**传输。它确保数据按照发送的顺序到达，并且不会出现丢失或重复。
3. **流控制**：TCP 使用窗口机制来控制数据的流动，防止接收方被**过多的数据**淹没。
4. **拥塞控制**：TCP 会根据网络的状况动态地调整数据的发送速率，以防止**网络拥塞**。
5. **顺序保证**：TCP 会确保数据按照发送的**顺序**被接收。
6. **应用场景**：适用于那些需要可靠数据传输的场景，例如 web 服务器、数据库服务器和电子邮件传输。

##### TCP的3次握手（建立连接）

三次握手的目的是在客户端和服务器之间同步序列号和确认序列号，以便之后的数据传输。

1. **SYN**：客户端选择一个初始的序列号 `x` 并发送一个 SYN 包到服务器，这个动作表示客户端想要建立一个连接。
2. **SYN + ACK**：服务器收到 SYN 包后，选择一个初始的序列号 `y` 并发送一个 SYN+ACK 包回客户端。这个包确认了客户端的 SYN （使用序列号 `x+1`）并且也发送了服务器的 SYN。
3. **ACK**：客户端收到服务器的 SYN+ACK 包后，会发送一个 ACK 包给服务器确认服务器的 SYN。这个确认将使用序列号 `y+1`。

##### TCP的4次挥手（断开连接）

四次挥手的目的是在连接的两端都能安全地关闭连接。

1. **FIN**：当数据发送完毕，发送方（通常是客户端，但服务器也可以）会发送一个 FIN 包，表示我已经完成了发送操作。
2. **ACK**：接收方收到 FIN 包后，会发送一个 ACK 包作为确认，表示我知道你想要关闭连接了。
3. **FIN**：当接收方也发送完了所有数据，它也会发送一个 FIN 包给发送方。
4. **ACK**：发送方收到这个 FIN 包后，会发送一个 ACK 作为确认。

#### UDP

1. **无连接**：UDP 是一个**无连接**的协议。这意味着没有连接建立和终止的过程，数据可以直接发送到目的地。
2. **不可靠性**：UDP **不保证数据的可靠传输**。数据包可能会丢失、重复或乱序。
3. **没有流控制**：与 TCP 不同，UDP 不进行流控制，因此数据包可能会由于网络拥塞而丢失。
4. **无状态**：UDP 是**无状态**的，意味着每个数据包的处理都是**独立**的。
5. **低延迟**：由于 UDP 没有建立连接、确认和拥塞控制的开销，通常比 TCP 有更低的延迟。
6. **应用场景**：适用于那些不需要数据可靠传输，但需要低延迟的场景，例如流媒体、实时通信和在线游戏。

### 网络安全

#### RSA

1. **定义**：RSA 是一种公开密钥加密算法，用于数据加密和数字签名。
2. **密钥对**：RSA 使用一对密钥：公钥和私钥。公钥用于加密数据，而对应的私钥用于解密数据。
3. **工作原理**：RSA 的基础是**大数因子分解**的难度。它使用两个大质数的乘积作为模数，这使得解密和签名只能使用私钥进行，而加密和验证则可以使用公钥。
4. **应用场景**：在 SSL/TLS 握手过程中，RSA 可以用于安全地交换会话密钥或者用于证书的数字签名。